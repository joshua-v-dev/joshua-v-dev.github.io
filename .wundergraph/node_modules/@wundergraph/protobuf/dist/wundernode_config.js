"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JwksBasedAuthentication = exports.ApiAuthenticationConfig = exports.Api = exports.Logging = exports.Certificate = exports.Server = exports.WunderNodeConfig = exports.configurationVariableKindToJSON = exports.configurationVariableKindFromJSON = exports.ConfigurationVariableKind = exports.analyticsRequestTypeToJSON = exports.analyticsRequestTypeFromJSON = exports.AnalyticsRequestType = exports.argumentRenderConfigurationToJSON = exports.argumentRenderConfigurationFromJSON = exports.ArgumentRenderConfiguration = exports.argumentSourceToJSON = exports.argumentSourceFromJSON = exports.ArgumentSource = exports.hTTPMethodToJSON = exports.hTTPMethodFromJSON = exports.HTTPMethod = exports.signingMethodToJSON = exports.signingMethodFromJSON = exports.SigningMethod = exports.upstreamAuthenticationKindToJSON = exports.upstreamAuthenticationKindFromJSON = exports.UpstreamAuthenticationKind = exports.dataSourceKindToJSON = exports.dataSourceKindFromJSON = exports.DataSourceKind = exports.operationTypeToJSON = exports.operationTypeFromJSON = exports.OperationType = exports.claimToJSON = exports.claimFromJSON = exports.Claim = exports.injectVariableKindToJSON = exports.injectVariableKindFromJSON = exports.InjectVariableKind = exports.apiCacheKindToJSON = exports.apiCacheKindFromJSON = exports.ApiCacheKind = exports.authProviderKindToJSON = exports.authProviderKindFromJSON = exports.AuthProviderKind = exports.logLevelToJSON = exports.logLevelFromJSON = exports.LogLevel = exports.protobufPackage = void 0;
exports.ConfigurationVariable = exports.CorsConfiguration = exports.UserDefinedApi = exports.S3UploadConfiguration = exports.WunderGraphConfiguration = exports.WunderNodeAnalyticsData = exports.RequestAnalyticsRecord = exports.ArgumentConfiguration = exports.TypeField = exports.FieldConfiguration = exports.TypeConfiguration = exports.HTTPHeader = exports.URLQueryConfiguration = exports.RESTSubscriptionConfiguration = exports.JwtUpstreamAuthenticationWithAccessTokenExchange = exports.JwtUpstreamAuthenticationConfig = exports.UpstreamAuthentication = exports.FetchConfiguration_HeaderEntry = exports.FetchConfiguration = exports.GraphQLSubscriptionConfiguration = exports.DatasourcecustomStatic = exports.GraphQLFederationConfiguration = exports.DatasourcecustomDatabase = exports.DatasourcecustomGraphql = exports.StatusCodeTypeMapping = exports.DatasourcecustomRest = exports.DirectiveConfiguration = exports.DataSourceConfiguration = exports.EngineConfiguration = exports.OperationCacheConfig = exports.OperationAuthenticationConfig = exports.OperationLiveQueryConfig = exports.ClaimConfig = exports.OperationRoleConfig = exports.OperationAuthorizationConfig = exports.MockResolveHookConfiguration = exports.OperationHooksConfiguration = exports.VariableInjectionConfiguration = exports.OperationVariablesConfiguration = exports.Operation = exports.RedisCacheConfig = exports.InMemoryCacheConfig = exports.ApiCacheConfig = exports.OpenIDConnectAuthProviderConfig = exports.GithubAuthProviderConfig = exports.AuthProvider = exports.CookieBasedAuthentication = exports.ApiAuthenticationHooks = exports.JwksAuthProvider = void 0;
/* eslint-disable */
const minimal_1 = require("protobufjs/minimal");
const Long = require("long");
const timestamp_1 = require("./google/protobuf/timestamp");
const duration_1 = require("./google/protobuf/duration");
exports.protobufPackage = "wgpb";
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 1] = "INFO";
    LogLevel[LogLevel["ERROR"] = 2] = "ERROR";
    LogLevel[LogLevel["WARNING"] = 3] = "WARNING";
    LogLevel[LogLevel["PANIC"] = 4] = "PANIC";
    LogLevel[LogLevel["FATAL"] = 5] = "FATAL";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
function logLevelFromJSON(object) {
    switch (object) {
        case 0:
        case "DEBUG":
            return LogLevel.DEBUG;
        case 1:
        case "INFO":
            return LogLevel.INFO;
        case 2:
        case "ERROR":
            return LogLevel.ERROR;
        case 3:
        case "WARNING":
            return LogLevel.WARNING;
        case 4:
        case "PANIC":
            return LogLevel.PANIC;
        case 5:
        case "FATAL":
            return LogLevel.FATAL;
        default:
            throw new globalThis.Error("Unrecognized enum value " + object + " for enum LogLevel");
    }
}
exports.logLevelFromJSON = logLevelFromJSON;
function logLevelToJSON(object) {
    switch (object) {
        case LogLevel.DEBUG:
            return "DEBUG";
        case LogLevel.INFO:
            return "INFO";
        case LogLevel.ERROR:
            return "ERROR";
        case LogLevel.WARNING:
            return "WARNING";
        case LogLevel.PANIC:
            return "PANIC";
        case LogLevel.FATAL:
            return "FATAL";
        default:
            return "UNKNOWN";
    }
}
exports.logLevelToJSON = logLevelToJSON;
var AuthProviderKind;
(function (AuthProviderKind) {
    AuthProviderKind[AuthProviderKind["AuthProviderGithub"] = 0] = "AuthProviderGithub";
    AuthProviderKind[AuthProviderKind["AuthProviderOIDC"] = 1] = "AuthProviderOIDC";
})(AuthProviderKind = exports.AuthProviderKind || (exports.AuthProviderKind = {}));
function authProviderKindFromJSON(object) {
    switch (object) {
        case 0:
        case "AuthProviderGithub":
            return AuthProviderKind.AuthProviderGithub;
        case 1:
        case "AuthProviderOIDC":
            return AuthProviderKind.AuthProviderOIDC;
        default:
            throw new globalThis.Error("Unrecognized enum value " + object + " for enum AuthProviderKind");
    }
}
exports.authProviderKindFromJSON = authProviderKindFromJSON;
function authProviderKindToJSON(object) {
    switch (object) {
        case AuthProviderKind.AuthProviderGithub:
            return "AuthProviderGithub";
        case AuthProviderKind.AuthProviderOIDC:
            return "AuthProviderOIDC";
        default:
            return "UNKNOWN";
    }
}
exports.authProviderKindToJSON = authProviderKindToJSON;
var ApiCacheKind;
(function (ApiCacheKind) {
    ApiCacheKind[ApiCacheKind["NO_CACHE"] = 0] = "NO_CACHE";
    ApiCacheKind[ApiCacheKind["IN_MEMORY_CACHE"] = 1] = "IN_MEMORY_CACHE";
    ApiCacheKind[ApiCacheKind["REDIS_CACHE"] = 2] = "REDIS_CACHE";
})(ApiCacheKind = exports.ApiCacheKind || (exports.ApiCacheKind = {}));
function apiCacheKindFromJSON(object) {
    switch (object) {
        case 0:
        case "NO_CACHE":
            return ApiCacheKind.NO_CACHE;
        case 1:
        case "IN_MEMORY_CACHE":
            return ApiCacheKind.IN_MEMORY_CACHE;
        case 2:
        case "REDIS_CACHE":
            return ApiCacheKind.REDIS_CACHE;
        default:
            throw new globalThis.Error("Unrecognized enum value " + object + " for enum ApiCacheKind");
    }
}
exports.apiCacheKindFromJSON = apiCacheKindFromJSON;
function apiCacheKindToJSON(object) {
    switch (object) {
        case ApiCacheKind.NO_CACHE:
            return "NO_CACHE";
        case ApiCacheKind.IN_MEMORY_CACHE:
            return "IN_MEMORY_CACHE";
        case ApiCacheKind.REDIS_CACHE:
            return "REDIS_CACHE";
        default:
            return "UNKNOWN";
    }
}
exports.apiCacheKindToJSON = apiCacheKindToJSON;
var InjectVariableKind;
(function (InjectVariableKind) {
    InjectVariableKind[InjectVariableKind["UUID"] = 0] = "UUID";
    InjectVariableKind[InjectVariableKind["DATE_TIME"] = 1] = "DATE_TIME";
    InjectVariableKind[InjectVariableKind["ENVIRONMENT_VARIABLE"] = 2] = "ENVIRONMENT_VARIABLE";
})(InjectVariableKind = exports.InjectVariableKind || (exports.InjectVariableKind = {}));
function injectVariableKindFromJSON(object) {
    switch (object) {
        case 0:
        case "UUID":
            return InjectVariableKind.UUID;
        case 1:
        case "DATE_TIME":
            return InjectVariableKind.DATE_TIME;
        case 2:
        case "ENVIRONMENT_VARIABLE":
            return InjectVariableKind.ENVIRONMENT_VARIABLE;
        default:
            throw new globalThis.Error("Unrecognized enum value " + object + " for enum InjectVariableKind");
    }
}
exports.injectVariableKindFromJSON = injectVariableKindFromJSON;
function injectVariableKindToJSON(object) {
    switch (object) {
        case InjectVariableKind.UUID:
            return "UUID";
        case InjectVariableKind.DATE_TIME:
            return "DATE_TIME";
        case InjectVariableKind.ENVIRONMENT_VARIABLE:
            return "ENVIRONMENT_VARIABLE";
        default:
            return "UNKNOWN";
    }
}
exports.injectVariableKindToJSON = injectVariableKindToJSON;
var Claim;
(function (Claim) {
    Claim[Claim["EMAIL"] = 0] = "EMAIL";
    Claim[Claim["EMAIL_VERIFIED"] = 1] = "EMAIL_VERIFIED";
    Claim[Claim["NAME"] = 2] = "NAME";
    Claim[Claim["NICKNAME"] = 3] = "NICKNAME";
    Claim[Claim["LOCATION"] = 4] = "LOCATION";
    Claim[Claim["PROVIDER"] = 5] = "PROVIDER";
})(Claim = exports.Claim || (exports.Claim = {}));
function claimFromJSON(object) {
    switch (object) {
        case 0:
        case "EMAIL":
            return Claim.EMAIL;
        case 1:
        case "EMAIL_VERIFIED":
            return Claim.EMAIL_VERIFIED;
        case 2:
        case "NAME":
            return Claim.NAME;
        case 3:
        case "NICKNAME":
            return Claim.NICKNAME;
        case 4:
        case "LOCATION":
            return Claim.LOCATION;
        case 5:
        case "PROVIDER":
            return Claim.PROVIDER;
        default:
            throw new globalThis.Error("Unrecognized enum value " + object + " for enum Claim");
    }
}
exports.claimFromJSON = claimFromJSON;
function claimToJSON(object) {
    switch (object) {
        case Claim.EMAIL:
            return "EMAIL";
        case Claim.EMAIL_VERIFIED:
            return "EMAIL_VERIFIED";
        case Claim.NAME:
            return "NAME";
        case Claim.NICKNAME:
            return "NICKNAME";
        case Claim.LOCATION:
            return "LOCATION";
        case Claim.PROVIDER:
            return "PROVIDER";
        default:
            return "UNKNOWN";
    }
}
exports.claimToJSON = claimToJSON;
var OperationType;
(function (OperationType) {
    OperationType[OperationType["QUERY"] = 0] = "QUERY";
    OperationType[OperationType["MUTATION"] = 1] = "MUTATION";
    OperationType[OperationType["SUBSCRIPTION"] = 2] = "SUBSCRIPTION";
})(OperationType = exports.OperationType || (exports.OperationType = {}));
function operationTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "QUERY":
            return OperationType.QUERY;
        case 1:
        case "MUTATION":
            return OperationType.MUTATION;
        case 2:
        case "SUBSCRIPTION":
            return OperationType.SUBSCRIPTION;
        default:
            throw new globalThis.Error("Unrecognized enum value " + object + " for enum OperationType");
    }
}
exports.operationTypeFromJSON = operationTypeFromJSON;
function operationTypeToJSON(object) {
    switch (object) {
        case OperationType.QUERY:
            return "QUERY";
        case OperationType.MUTATION:
            return "MUTATION";
        case OperationType.SUBSCRIPTION:
            return "SUBSCRIPTION";
        default:
            return "UNKNOWN";
    }
}
exports.operationTypeToJSON = operationTypeToJSON;
var DataSourceKind;
(function (DataSourceKind) {
    DataSourceKind[DataSourceKind["STATIC"] = 0] = "STATIC";
    DataSourceKind[DataSourceKind["REST"] = 1] = "REST";
    DataSourceKind[DataSourceKind["GRAPHQL"] = 2] = "GRAPHQL";
    DataSourceKind[DataSourceKind["POSTGRESQL"] = 3] = "POSTGRESQL";
    DataSourceKind[DataSourceKind["MYSQL"] = 4] = "MYSQL";
    DataSourceKind[DataSourceKind["SQLSERVER"] = 5] = "SQLSERVER";
    DataSourceKind[DataSourceKind["MONGODB"] = 6] = "MONGODB";
    DataSourceKind[DataSourceKind["SQLITE"] = 7] = "SQLITE";
})(DataSourceKind = exports.DataSourceKind || (exports.DataSourceKind = {}));
function dataSourceKindFromJSON(object) {
    switch (object) {
        case 0:
        case "STATIC":
            return DataSourceKind.STATIC;
        case 1:
        case "REST":
            return DataSourceKind.REST;
        case 2:
        case "GRAPHQL":
            return DataSourceKind.GRAPHQL;
        case 3:
        case "POSTGRESQL":
            return DataSourceKind.POSTGRESQL;
        case 4:
        case "MYSQL":
            return DataSourceKind.MYSQL;
        case 5:
        case "SQLSERVER":
            return DataSourceKind.SQLSERVER;
        case 6:
        case "MONGODB":
            return DataSourceKind.MONGODB;
        case 7:
        case "SQLITE":
            return DataSourceKind.SQLITE;
        default:
            throw new globalThis.Error("Unrecognized enum value " + object + " for enum DataSourceKind");
    }
}
exports.dataSourceKindFromJSON = dataSourceKindFromJSON;
function dataSourceKindToJSON(object) {
    switch (object) {
        case DataSourceKind.STATIC:
            return "STATIC";
        case DataSourceKind.REST:
            return "REST";
        case DataSourceKind.GRAPHQL:
            return "GRAPHQL";
        case DataSourceKind.POSTGRESQL:
            return "POSTGRESQL";
        case DataSourceKind.MYSQL:
            return "MYSQL";
        case DataSourceKind.SQLSERVER:
            return "SQLSERVER";
        case DataSourceKind.MONGODB:
            return "MONGODB";
        case DataSourceKind.SQLITE:
            return "SQLITE";
        default:
            return "UNKNOWN";
    }
}
exports.dataSourceKindToJSON = dataSourceKindToJSON;
var UpstreamAuthenticationKind;
(function (UpstreamAuthenticationKind) {
    UpstreamAuthenticationKind[UpstreamAuthenticationKind["UpstreamAuthenticationJWT"] = 0] = "UpstreamAuthenticationJWT";
    UpstreamAuthenticationKind[UpstreamAuthenticationKind["UpstreamAuthenticationJWTWithAccessTokenExchange"] = 1] = "UpstreamAuthenticationJWTWithAccessTokenExchange";
})(UpstreamAuthenticationKind = exports.UpstreamAuthenticationKind || (exports.UpstreamAuthenticationKind = {}));
function upstreamAuthenticationKindFromJSON(object) {
    switch (object) {
        case 0:
        case "UpstreamAuthenticationJWT":
            return UpstreamAuthenticationKind.UpstreamAuthenticationJWT;
        case 1:
        case "UpstreamAuthenticationJWTWithAccessTokenExchange":
            return UpstreamAuthenticationKind.UpstreamAuthenticationJWTWithAccessTokenExchange;
        default:
            throw new globalThis.Error("Unrecognized enum value " +
                object +
                " for enum UpstreamAuthenticationKind");
    }
}
exports.upstreamAuthenticationKindFromJSON = upstreamAuthenticationKindFromJSON;
function upstreamAuthenticationKindToJSON(object) {
    switch (object) {
        case UpstreamAuthenticationKind.UpstreamAuthenticationJWT:
            return "UpstreamAuthenticationJWT";
        case UpstreamAuthenticationKind.UpstreamAuthenticationJWTWithAccessTokenExchange:
            return "UpstreamAuthenticationJWTWithAccessTokenExchange";
        default:
            return "UNKNOWN";
    }
}
exports.upstreamAuthenticationKindToJSON = upstreamAuthenticationKindToJSON;
var SigningMethod;
(function (SigningMethod) {
    SigningMethod[SigningMethod["SigningMethodHS256"] = 0] = "SigningMethodHS256";
})(SigningMethod = exports.SigningMethod || (exports.SigningMethod = {}));
function signingMethodFromJSON(object) {
    switch (object) {
        case 0:
        case "SigningMethodHS256":
            return SigningMethod.SigningMethodHS256;
        default:
            throw new globalThis.Error("Unrecognized enum value " + object + " for enum SigningMethod");
    }
}
exports.signingMethodFromJSON = signingMethodFromJSON;
function signingMethodToJSON(object) {
    switch (object) {
        case SigningMethod.SigningMethodHS256:
            return "SigningMethodHS256";
        default:
            return "UNKNOWN";
    }
}
exports.signingMethodToJSON = signingMethodToJSON;
var HTTPMethod;
(function (HTTPMethod) {
    HTTPMethod[HTTPMethod["GET"] = 0] = "GET";
    HTTPMethod[HTTPMethod["POST"] = 1] = "POST";
    HTTPMethod[HTTPMethod["PUT"] = 2] = "PUT";
    HTTPMethod[HTTPMethod["DELETE"] = 3] = "DELETE";
    HTTPMethod[HTTPMethod["OPTIONS"] = 4] = "OPTIONS";
})(HTTPMethod = exports.HTTPMethod || (exports.HTTPMethod = {}));
function hTTPMethodFromJSON(object) {
    switch (object) {
        case 0:
        case "GET":
            return HTTPMethod.GET;
        case 1:
        case "POST":
            return HTTPMethod.POST;
        case 2:
        case "PUT":
            return HTTPMethod.PUT;
        case 3:
        case "DELETE":
            return HTTPMethod.DELETE;
        case 4:
        case "OPTIONS":
            return HTTPMethod.OPTIONS;
        default:
            throw new globalThis.Error("Unrecognized enum value " + object + " for enum HTTPMethod");
    }
}
exports.hTTPMethodFromJSON = hTTPMethodFromJSON;
function hTTPMethodToJSON(object) {
    switch (object) {
        case HTTPMethod.GET:
            return "GET";
        case HTTPMethod.POST:
            return "POST";
        case HTTPMethod.PUT:
            return "PUT";
        case HTTPMethod.DELETE:
            return "DELETE";
        case HTTPMethod.OPTIONS:
            return "OPTIONS";
        default:
            return "UNKNOWN";
    }
}
exports.hTTPMethodToJSON = hTTPMethodToJSON;
var ArgumentSource;
(function (ArgumentSource) {
    ArgumentSource[ArgumentSource["OBJECT_FIELD"] = 0] = "OBJECT_FIELD";
    ArgumentSource[ArgumentSource["FIELD_ARGUMENT"] = 1] = "FIELD_ARGUMENT";
})(ArgumentSource = exports.ArgumentSource || (exports.ArgumentSource = {}));
function argumentSourceFromJSON(object) {
    switch (object) {
        case 0:
        case "OBJECT_FIELD":
            return ArgumentSource.OBJECT_FIELD;
        case 1:
        case "FIELD_ARGUMENT":
            return ArgumentSource.FIELD_ARGUMENT;
        default:
            throw new globalThis.Error("Unrecognized enum value " + object + " for enum ArgumentSource");
    }
}
exports.argumentSourceFromJSON = argumentSourceFromJSON;
function argumentSourceToJSON(object) {
    switch (object) {
        case ArgumentSource.OBJECT_FIELD:
            return "OBJECT_FIELD";
        case ArgumentSource.FIELD_ARGUMENT:
            return "FIELD_ARGUMENT";
        default:
            return "UNKNOWN";
    }
}
exports.argumentSourceToJSON = argumentSourceToJSON;
var ArgumentRenderConfiguration;
(function (ArgumentRenderConfiguration) {
    ArgumentRenderConfiguration[ArgumentRenderConfiguration["RENDER_ARGUMENT_DEFAULT"] = 0] = "RENDER_ARGUMENT_DEFAULT";
    ArgumentRenderConfiguration[ArgumentRenderConfiguration["RENDER_ARGUMENT_AS_GRAPHQL_VALUE"] = 1] = "RENDER_ARGUMENT_AS_GRAPHQL_VALUE";
    ArgumentRenderConfiguration[ArgumentRenderConfiguration["RENDER_ARGUMENT_AS_ARRAY_CSV"] = 2] = "RENDER_ARGUMENT_AS_ARRAY_CSV";
})(ArgumentRenderConfiguration = exports.ArgumentRenderConfiguration || (exports.ArgumentRenderConfiguration = {}));
function argumentRenderConfigurationFromJSON(object) {
    switch (object) {
        case 0:
        case "RENDER_ARGUMENT_DEFAULT":
            return ArgumentRenderConfiguration.RENDER_ARGUMENT_DEFAULT;
        case 1:
        case "RENDER_ARGUMENT_AS_GRAPHQL_VALUE":
            return ArgumentRenderConfiguration.RENDER_ARGUMENT_AS_GRAPHQL_VALUE;
        case 2:
        case "RENDER_ARGUMENT_AS_ARRAY_CSV":
            return ArgumentRenderConfiguration.RENDER_ARGUMENT_AS_ARRAY_CSV;
        default:
            throw new globalThis.Error("Unrecognized enum value " +
                object +
                " for enum ArgumentRenderConfiguration");
    }
}
exports.argumentRenderConfigurationFromJSON = argumentRenderConfigurationFromJSON;
function argumentRenderConfigurationToJSON(object) {
    switch (object) {
        case ArgumentRenderConfiguration.RENDER_ARGUMENT_DEFAULT:
            return "RENDER_ARGUMENT_DEFAULT";
        case ArgumentRenderConfiguration.RENDER_ARGUMENT_AS_GRAPHQL_VALUE:
            return "RENDER_ARGUMENT_AS_GRAPHQL_VALUE";
        case ArgumentRenderConfiguration.RENDER_ARGUMENT_AS_ARRAY_CSV:
            return "RENDER_ARGUMENT_AS_ARRAY_CSV";
        default:
            return "UNKNOWN";
    }
}
exports.argumentRenderConfigurationToJSON = argumentRenderConfigurationToJSON;
var AnalyticsRequestType;
(function (AnalyticsRequestType) {
    AnalyticsRequestType[AnalyticsRequestType["PersistedQuery"] = 0] = "PersistedQuery";
    AnalyticsRequestType[AnalyticsRequestType["PersistedMutation"] = 1] = "PersistedMutation";
    AnalyticsRequestType[AnalyticsRequestType["PersistedSubscription"] = 3] = "PersistedSubscription";
    AnalyticsRequestType[AnalyticsRequestType["PersistedLiveQuery"] = 4] = "PersistedLiveQuery";
    AnalyticsRequestType[AnalyticsRequestType["DynamicQuery"] = 5] = "DynamicQuery";
    AnalyticsRequestType[AnalyticsRequestType["DynamicMutation"] = 6] = "DynamicMutation";
    AnalyticsRequestType[AnalyticsRequestType["DynamicSubscription"] = 7] = "DynamicSubscription";
})(AnalyticsRequestType = exports.AnalyticsRequestType || (exports.AnalyticsRequestType = {}));
function analyticsRequestTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "PersistedQuery":
            return AnalyticsRequestType.PersistedQuery;
        case 1:
        case "PersistedMutation":
            return AnalyticsRequestType.PersistedMutation;
        case 3:
        case "PersistedSubscription":
            return AnalyticsRequestType.PersistedSubscription;
        case 4:
        case "PersistedLiveQuery":
            return AnalyticsRequestType.PersistedLiveQuery;
        case 5:
        case "DynamicQuery":
            return AnalyticsRequestType.DynamicQuery;
        case 6:
        case "DynamicMutation":
            return AnalyticsRequestType.DynamicMutation;
        case 7:
        case "DynamicSubscription":
            return AnalyticsRequestType.DynamicSubscription;
        default:
            throw new globalThis.Error("Unrecognized enum value " + object + " for enum AnalyticsRequestType");
    }
}
exports.analyticsRequestTypeFromJSON = analyticsRequestTypeFromJSON;
function analyticsRequestTypeToJSON(object) {
    switch (object) {
        case AnalyticsRequestType.PersistedQuery:
            return "PersistedQuery";
        case AnalyticsRequestType.PersistedMutation:
            return "PersistedMutation";
        case AnalyticsRequestType.PersistedSubscription:
            return "PersistedSubscription";
        case AnalyticsRequestType.PersistedLiveQuery:
            return "PersistedLiveQuery";
        case AnalyticsRequestType.DynamicQuery:
            return "DynamicQuery";
        case AnalyticsRequestType.DynamicMutation:
            return "DynamicMutation";
        case AnalyticsRequestType.DynamicSubscription:
            return "DynamicSubscription";
        default:
            return "UNKNOWN";
    }
}
exports.analyticsRequestTypeToJSON = analyticsRequestTypeToJSON;
var ConfigurationVariableKind;
(function (ConfigurationVariableKind) {
    ConfigurationVariableKind[ConfigurationVariableKind["STATIC_CONFIGURATION_VARIABLE"] = 0] = "STATIC_CONFIGURATION_VARIABLE";
    ConfigurationVariableKind[ConfigurationVariableKind["ENV_CONFIGURATION_VARIABLE"] = 1] = "ENV_CONFIGURATION_VARIABLE";
    ConfigurationVariableKind[ConfigurationVariableKind["PLACEHOLDER_CONFIGURATION_VARIABLE"] = 2] = "PLACEHOLDER_CONFIGURATION_VARIABLE";
})(ConfigurationVariableKind = exports.ConfigurationVariableKind || (exports.ConfigurationVariableKind = {}));
function configurationVariableKindFromJSON(object) {
    switch (object) {
        case 0:
        case "STATIC_CONFIGURATION_VARIABLE":
            return ConfigurationVariableKind.STATIC_CONFIGURATION_VARIABLE;
        case 1:
        case "ENV_CONFIGURATION_VARIABLE":
            return ConfigurationVariableKind.ENV_CONFIGURATION_VARIABLE;
        case 2:
        case "PLACEHOLDER_CONFIGURATION_VARIABLE":
            return ConfigurationVariableKind.PLACEHOLDER_CONFIGURATION_VARIABLE;
        default:
            throw new globalThis.Error("Unrecognized enum value " +
                object +
                " for enum ConfigurationVariableKind");
    }
}
exports.configurationVariableKindFromJSON = configurationVariableKindFromJSON;
function configurationVariableKindToJSON(object) {
    switch (object) {
        case ConfigurationVariableKind.STATIC_CONFIGURATION_VARIABLE:
            return "STATIC_CONFIGURATION_VARIABLE";
        case ConfigurationVariableKind.ENV_CONFIGURATION_VARIABLE:
            return "ENV_CONFIGURATION_VARIABLE";
        case ConfigurationVariableKind.PLACEHOLDER_CONFIGURATION_VARIABLE:
            return "PLACEHOLDER_CONFIGURATION_VARIABLE";
        default:
            return "UNKNOWN";
    }
}
exports.configurationVariableKindToJSON = configurationVariableKindToJSON;
const baseWunderNodeConfig = {};
exports.WunderNodeConfig = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.server !== undefined) {
            exports.Server.encode(message.server, writer.uint32(10).fork()).ldelim();
        }
        if (message.logging !== undefined) {
            exports.Logging.encode(message.logging, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.apis) {
            exports.Api.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseWunderNodeConfig };
        message.apis = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.server = exports.Server.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.logging = exports.Logging.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.apis.push(exports.Api.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseWunderNodeConfig };
        message.apis = [];
        if (object.server !== undefined && object.server !== null) {
            message.server = exports.Server.fromJSON(object.server);
        }
        else {
            message.server = undefined;
        }
        if (object.logging !== undefined && object.logging !== null) {
            message.logging = exports.Logging.fromJSON(object.logging);
        }
        else {
            message.logging = undefined;
        }
        if (object.apis !== undefined && object.apis !== null) {
            for (const e of object.apis) {
                message.apis.push(exports.Api.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.server !== undefined &&
            (obj.server = message.server ? exports.Server.toJSON(message.server) : undefined);
        message.logging !== undefined &&
            (obj.logging = message.logging
                ? exports.Logging.toJSON(message.logging)
                : undefined);
        if (message.apis) {
            obj.apis = message.apis.map((e) => (e ? exports.Api.toJSON(e) : undefined));
        }
        else {
            obj.apis = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseWunderNodeConfig };
        message.apis = [];
        if (object.server !== undefined && object.server !== null) {
            message.server = exports.Server.fromPartial(object.server);
        }
        else {
            message.server = undefined;
        }
        if (object.logging !== undefined && object.logging !== null) {
            message.logging = exports.Logging.fromPartial(object.logging);
        }
        else {
            message.logging = undefined;
        }
        if (object.apis !== undefined && object.apis !== null) {
            for (const e of object.apis) {
                message.apis.push(exports.Api.fromPartial(e));
            }
        }
        return message;
    },
};
const baseServer = {};
exports.Server = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.gracefulShutdownTimeout !== undefined) {
            duration_1.Duration.encode(message.gracefulShutdownTimeout, writer.uint32(10).fork()).ldelim();
        }
        if (message.keepAlive !== undefined) {
            duration_1.Duration.encode(message.keepAlive, writer.uint32(18).fork()).ldelim();
        }
        if (message.readTimeout !== undefined) {
            duration_1.Duration.encode(message.readTimeout, writer.uint32(26).fork()).ldelim();
        }
        if (message.writeTimeout !== undefined) {
            duration_1.Duration.encode(message.writeTimeout, writer.uint32(34).fork()).ldelim();
        }
        if (message.idleTimeout !== undefined) {
            duration_1.Duration.encode(message.idleTimeout, writer.uint32(42).fork()).ldelim();
        }
        for (const v of message.certificates) {
            exports.Certificate.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseServer };
        message.certificates = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.gracefulShutdownTimeout = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.keepAlive = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.readTimeout = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.writeTimeout = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.idleTimeout = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.certificates.push(exports.Certificate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseServer };
        message.certificates = [];
        if (object.gracefulShutdownTimeout !== undefined &&
            object.gracefulShutdownTimeout !== null) {
            message.gracefulShutdownTimeout = duration_1.Duration.fromJSON(object.gracefulShutdownTimeout);
        }
        else {
            message.gracefulShutdownTimeout = undefined;
        }
        if (object.keepAlive !== undefined && object.keepAlive !== null) {
            message.keepAlive = duration_1.Duration.fromJSON(object.keepAlive);
        }
        else {
            message.keepAlive = undefined;
        }
        if (object.readTimeout !== undefined && object.readTimeout !== null) {
            message.readTimeout = duration_1.Duration.fromJSON(object.readTimeout);
        }
        else {
            message.readTimeout = undefined;
        }
        if (object.writeTimeout !== undefined && object.writeTimeout !== null) {
            message.writeTimeout = duration_1.Duration.fromJSON(object.writeTimeout);
        }
        else {
            message.writeTimeout = undefined;
        }
        if (object.idleTimeout !== undefined && object.idleTimeout !== null) {
            message.idleTimeout = duration_1.Duration.fromJSON(object.idleTimeout);
        }
        else {
            message.idleTimeout = undefined;
        }
        if (object.certificates !== undefined && object.certificates !== null) {
            for (const e of object.certificates) {
                message.certificates.push(exports.Certificate.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.gracefulShutdownTimeout !== undefined &&
            (obj.gracefulShutdownTimeout = message.gracefulShutdownTimeout
                ? duration_1.Duration.toJSON(message.gracefulShutdownTimeout)
                : undefined);
        message.keepAlive !== undefined &&
            (obj.keepAlive = message.keepAlive
                ? duration_1.Duration.toJSON(message.keepAlive)
                : undefined);
        message.readTimeout !== undefined &&
            (obj.readTimeout = message.readTimeout
                ? duration_1.Duration.toJSON(message.readTimeout)
                : undefined);
        message.writeTimeout !== undefined &&
            (obj.writeTimeout = message.writeTimeout
                ? duration_1.Duration.toJSON(message.writeTimeout)
                : undefined);
        message.idleTimeout !== undefined &&
            (obj.idleTimeout = message.idleTimeout
                ? duration_1.Duration.toJSON(message.idleTimeout)
                : undefined);
        if (message.certificates) {
            obj.certificates = message.certificates.map((e) => e ? exports.Certificate.toJSON(e) : undefined);
        }
        else {
            obj.certificates = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseServer };
        message.certificates = [];
        if (object.gracefulShutdownTimeout !== undefined &&
            object.gracefulShutdownTimeout !== null) {
            message.gracefulShutdownTimeout = duration_1.Duration.fromPartial(object.gracefulShutdownTimeout);
        }
        else {
            message.gracefulShutdownTimeout = undefined;
        }
        if (object.keepAlive !== undefined && object.keepAlive !== null) {
            message.keepAlive = duration_1.Duration.fromPartial(object.keepAlive);
        }
        else {
            message.keepAlive = undefined;
        }
        if (object.readTimeout !== undefined && object.readTimeout !== null) {
            message.readTimeout = duration_1.Duration.fromPartial(object.readTimeout);
        }
        else {
            message.readTimeout = undefined;
        }
        if (object.writeTimeout !== undefined && object.writeTimeout !== null) {
            message.writeTimeout = duration_1.Duration.fromPartial(object.writeTimeout);
        }
        else {
            message.writeTimeout = undefined;
        }
        if (object.idleTimeout !== undefined && object.idleTimeout !== null) {
            message.idleTimeout = duration_1.Duration.fromPartial(object.idleTimeout);
        }
        else {
            message.idleTimeout = undefined;
        }
        if (object.certificates !== undefined && object.certificates !== null) {
            for (const e of object.certificates) {
                message.certificates.push(exports.Certificate.fromPartial(e));
            }
        }
        return message;
    },
};
const baseCertificate = { keyPem: "", certPem: "" };
exports.Certificate = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.keyPem !== "") {
            writer.uint32(18).string(message.keyPem);
        }
        if (message.certPem !== "") {
            writer.uint32(26).string(message.certPem);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseCertificate };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.keyPem = reader.string();
                    break;
                case 3:
                    message.certPem = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseCertificate };
        if (object.keyPem !== undefined && object.keyPem !== null) {
            message.keyPem = String(object.keyPem);
        }
        else {
            message.keyPem = "";
        }
        if (object.certPem !== undefined && object.certPem !== null) {
            message.certPem = String(object.certPem);
        }
        else {
            message.certPem = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.keyPem !== undefined && (obj.keyPem = message.keyPem);
        message.certPem !== undefined && (obj.certPem = message.certPem);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseCertificate };
        if (object.keyPem !== undefined && object.keyPem !== null) {
            message.keyPem = object.keyPem;
        }
        else {
            message.keyPem = "";
        }
        if (object.certPem !== undefined && object.certPem !== null) {
            message.certPem = object.certPem;
        }
        else {
            message.certPem = "";
        }
        return message;
    },
};
const baseLogging = { level: 0 };
exports.Logging = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.level !== 0) {
            writer.uint32(8).int32(message.level);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseLogging };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.level = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseLogging };
        if (object.level !== undefined && object.level !== null) {
            message.level = logLevelFromJSON(object.level);
        }
        else {
            message.level = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.level !== undefined && (obj.level = logLevelToJSON(message.level));
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseLogging };
        if (object.level !== undefined && object.level !== null) {
            message.level = object.level;
        }
        else {
            message.level = 0;
        }
        return message;
    },
};
const baseApi = {
    hosts: "",
    pathPrefix: "",
    enableSingleFlight: false,
    enableGraphqlEndpoint: false,
    primaryHost: "",
    deploymentId: "",
    apiConfigHash: "",
};
exports.Api = {
    encode(message, writer = minimal_1.Writer.create()) {
        for (const v of message.hosts) {
            writer.uint32(10).string(v);
        }
        if (message.pathPrefix !== "") {
            writer.uint32(18).string(message.pathPrefix);
        }
        if (message.engineConfiguration !== undefined) {
            exports.EngineConfiguration.encode(message.engineConfiguration, writer.uint32(26).fork()).ldelim();
        }
        if (message.enableSingleFlight === true) {
            writer.uint32(32).bool(message.enableSingleFlight);
        }
        if (message.enableGraphqlEndpoint === true) {
            writer.uint32(40).bool(message.enableGraphqlEndpoint);
        }
        for (const v of message.operations) {
            exports.Operation.encode(v, writer.uint32(50).fork()).ldelim();
        }
        if (message.corsConfiguration !== undefined) {
            exports.CorsConfiguration.encode(message.corsConfiguration, writer.uint32(58).fork()).ldelim();
        }
        if (message.primaryHost !== "") {
            writer.uint32(66).string(message.primaryHost);
        }
        if (message.deploymentId !== "") {
            writer.uint32(74).string(message.deploymentId);
        }
        if (message.cacheConfig !== undefined) {
            exports.ApiCacheConfig.encode(message.cacheConfig, writer.uint32(82).fork()).ldelim();
        }
        if (message.apiConfigHash !== "") {
            writer.uint32(90).string(message.apiConfigHash);
        }
        if (message.authenticationConfig !== undefined) {
            exports.ApiAuthenticationConfig.encode(message.authenticationConfig, writer.uint32(98).fork()).ldelim();
        }
        for (const v of message.s3UploadConfiguration) {
            exports.S3UploadConfiguration.encode(v, writer.uint32(106).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseApi };
        message.hosts = [];
        message.operations = [];
        message.s3UploadConfiguration = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hosts.push(reader.string());
                    break;
                case 2:
                    message.pathPrefix = reader.string();
                    break;
                case 3:
                    message.engineConfiguration = exports.EngineConfiguration.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.enableSingleFlight = reader.bool();
                    break;
                case 5:
                    message.enableGraphqlEndpoint = reader.bool();
                    break;
                case 6:
                    message.operations.push(exports.Operation.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.corsConfiguration = exports.CorsConfiguration.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.primaryHost = reader.string();
                    break;
                case 9:
                    message.deploymentId = reader.string();
                    break;
                case 10:
                    message.cacheConfig = exports.ApiCacheConfig.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.apiConfigHash = reader.string();
                    break;
                case 12:
                    message.authenticationConfig = exports.ApiAuthenticationConfig.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.s3UploadConfiguration.push(exports.S3UploadConfiguration.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseApi };
        message.hosts = [];
        message.operations = [];
        message.s3UploadConfiguration = [];
        if (object.hosts !== undefined && object.hosts !== null) {
            for (const e of object.hosts) {
                message.hosts.push(String(e));
            }
        }
        if (object.pathPrefix !== undefined && object.pathPrefix !== null) {
            message.pathPrefix = String(object.pathPrefix);
        }
        else {
            message.pathPrefix = "";
        }
        if (object.engineConfiguration !== undefined &&
            object.engineConfiguration !== null) {
            message.engineConfiguration = exports.EngineConfiguration.fromJSON(object.engineConfiguration);
        }
        else {
            message.engineConfiguration = undefined;
        }
        if (object.enableSingleFlight !== undefined &&
            object.enableSingleFlight !== null) {
            message.enableSingleFlight = Boolean(object.enableSingleFlight);
        }
        else {
            message.enableSingleFlight = false;
        }
        if (object.enableGraphqlEndpoint !== undefined &&
            object.enableGraphqlEndpoint !== null) {
            message.enableGraphqlEndpoint = Boolean(object.enableGraphqlEndpoint);
        }
        else {
            message.enableGraphqlEndpoint = false;
        }
        if (object.operations !== undefined && object.operations !== null) {
            for (const e of object.operations) {
                message.operations.push(exports.Operation.fromJSON(e));
            }
        }
        if (object.corsConfiguration !== undefined &&
            object.corsConfiguration !== null) {
            message.corsConfiguration = exports.CorsConfiguration.fromJSON(object.corsConfiguration);
        }
        else {
            message.corsConfiguration = undefined;
        }
        if (object.primaryHost !== undefined && object.primaryHost !== null) {
            message.primaryHost = String(object.primaryHost);
        }
        else {
            message.primaryHost = "";
        }
        if (object.deploymentId !== undefined && object.deploymentId !== null) {
            message.deploymentId = String(object.deploymentId);
        }
        else {
            message.deploymentId = "";
        }
        if (object.cacheConfig !== undefined && object.cacheConfig !== null) {
            message.cacheConfig = exports.ApiCacheConfig.fromJSON(object.cacheConfig);
        }
        else {
            message.cacheConfig = undefined;
        }
        if (object.apiConfigHash !== undefined && object.apiConfigHash !== null) {
            message.apiConfigHash = String(object.apiConfigHash);
        }
        else {
            message.apiConfigHash = "";
        }
        if (object.authenticationConfig !== undefined &&
            object.authenticationConfig !== null) {
            message.authenticationConfig = exports.ApiAuthenticationConfig.fromJSON(object.authenticationConfig);
        }
        else {
            message.authenticationConfig = undefined;
        }
        if (object.s3UploadConfiguration !== undefined &&
            object.s3UploadConfiguration !== null) {
            for (const e of object.s3UploadConfiguration) {
                message.s3UploadConfiguration.push(exports.S3UploadConfiguration.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.hosts) {
            obj.hosts = message.hosts.map((e) => e);
        }
        else {
            obj.hosts = [];
        }
        message.pathPrefix !== undefined && (obj.pathPrefix = message.pathPrefix);
        message.engineConfiguration !== undefined &&
            (obj.engineConfiguration = message.engineConfiguration
                ? exports.EngineConfiguration.toJSON(message.engineConfiguration)
                : undefined);
        message.enableSingleFlight !== undefined &&
            (obj.enableSingleFlight = message.enableSingleFlight);
        message.enableGraphqlEndpoint !== undefined &&
            (obj.enableGraphqlEndpoint = message.enableGraphqlEndpoint);
        if (message.operations) {
            obj.operations = message.operations.map((e) => e ? exports.Operation.toJSON(e) : undefined);
        }
        else {
            obj.operations = [];
        }
        message.corsConfiguration !== undefined &&
            (obj.corsConfiguration = message.corsConfiguration
                ? exports.CorsConfiguration.toJSON(message.corsConfiguration)
                : undefined);
        message.primaryHost !== undefined &&
            (obj.primaryHost = message.primaryHost);
        message.deploymentId !== undefined &&
            (obj.deploymentId = message.deploymentId);
        message.cacheConfig !== undefined &&
            (obj.cacheConfig = message.cacheConfig
                ? exports.ApiCacheConfig.toJSON(message.cacheConfig)
                : undefined);
        message.apiConfigHash !== undefined &&
            (obj.apiConfigHash = message.apiConfigHash);
        message.authenticationConfig !== undefined &&
            (obj.authenticationConfig = message.authenticationConfig
                ? exports.ApiAuthenticationConfig.toJSON(message.authenticationConfig)
                : undefined);
        if (message.s3UploadConfiguration) {
            obj.s3UploadConfiguration = message.s3UploadConfiguration.map((e) => e ? exports.S3UploadConfiguration.toJSON(e) : undefined);
        }
        else {
            obj.s3UploadConfiguration = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseApi };
        message.hosts = [];
        message.operations = [];
        message.s3UploadConfiguration = [];
        if (object.hosts !== undefined && object.hosts !== null) {
            for (const e of object.hosts) {
                message.hosts.push(e);
            }
        }
        if (object.pathPrefix !== undefined && object.pathPrefix !== null) {
            message.pathPrefix = object.pathPrefix;
        }
        else {
            message.pathPrefix = "";
        }
        if (object.engineConfiguration !== undefined &&
            object.engineConfiguration !== null) {
            message.engineConfiguration = exports.EngineConfiguration.fromPartial(object.engineConfiguration);
        }
        else {
            message.engineConfiguration = undefined;
        }
        if (object.enableSingleFlight !== undefined &&
            object.enableSingleFlight !== null) {
            message.enableSingleFlight = object.enableSingleFlight;
        }
        else {
            message.enableSingleFlight = false;
        }
        if (object.enableGraphqlEndpoint !== undefined &&
            object.enableGraphqlEndpoint !== null) {
            message.enableGraphqlEndpoint = object.enableGraphqlEndpoint;
        }
        else {
            message.enableGraphqlEndpoint = false;
        }
        if (object.operations !== undefined && object.operations !== null) {
            for (const e of object.operations) {
                message.operations.push(exports.Operation.fromPartial(e));
            }
        }
        if (object.corsConfiguration !== undefined &&
            object.corsConfiguration !== null) {
            message.corsConfiguration = exports.CorsConfiguration.fromPartial(object.corsConfiguration);
        }
        else {
            message.corsConfiguration = undefined;
        }
        if (object.primaryHost !== undefined && object.primaryHost !== null) {
            message.primaryHost = object.primaryHost;
        }
        else {
            message.primaryHost = "";
        }
        if (object.deploymentId !== undefined && object.deploymentId !== null) {
            message.deploymentId = object.deploymentId;
        }
        else {
            message.deploymentId = "";
        }
        if (object.cacheConfig !== undefined && object.cacheConfig !== null) {
            message.cacheConfig = exports.ApiCacheConfig.fromPartial(object.cacheConfig);
        }
        else {
            message.cacheConfig = undefined;
        }
        if (object.apiConfigHash !== undefined && object.apiConfigHash !== null) {
            message.apiConfigHash = object.apiConfigHash;
        }
        else {
            message.apiConfigHash = "";
        }
        if (object.authenticationConfig !== undefined &&
            object.authenticationConfig !== null) {
            message.authenticationConfig = exports.ApiAuthenticationConfig.fromPartial(object.authenticationConfig);
        }
        else {
            message.authenticationConfig = undefined;
        }
        if (object.s3UploadConfiguration !== undefined &&
            object.s3UploadConfiguration !== null) {
            for (const e of object.s3UploadConfiguration) {
                message.s3UploadConfiguration.push(exports.S3UploadConfiguration.fromPartial(e));
            }
        }
        return message;
    },
};
const baseApiAuthenticationConfig = {};
exports.ApiAuthenticationConfig = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.cookieBased !== undefined) {
            exports.CookieBasedAuthentication.encode(message.cookieBased, writer.uint32(10).fork()).ldelim();
        }
        if (message.hooks !== undefined) {
            exports.ApiAuthenticationHooks.encode(message.hooks, writer.uint32(18).fork()).ldelim();
        }
        if (message.jwksBased !== undefined) {
            exports.JwksBasedAuthentication.encode(message.jwksBased, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseApiAuthenticationConfig,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cookieBased = exports.CookieBasedAuthentication.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.hooks = exports.ApiAuthenticationHooks.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.jwksBased = exports.JwksBasedAuthentication.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseApiAuthenticationConfig,
        };
        if (object.cookieBased !== undefined && object.cookieBased !== null) {
            message.cookieBased = exports.CookieBasedAuthentication.fromJSON(object.cookieBased);
        }
        else {
            message.cookieBased = undefined;
        }
        if (object.hooks !== undefined && object.hooks !== null) {
            message.hooks = exports.ApiAuthenticationHooks.fromJSON(object.hooks);
        }
        else {
            message.hooks = undefined;
        }
        if (object.jwksBased !== undefined && object.jwksBased !== null) {
            message.jwksBased = exports.JwksBasedAuthentication.fromJSON(object.jwksBased);
        }
        else {
            message.jwksBased = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.cookieBased !== undefined &&
            (obj.cookieBased = message.cookieBased
                ? exports.CookieBasedAuthentication.toJSON(message.cookieBased)
                : undefined);
        message.hooks !== undefined &&
            (obj.hooks = message.hooks
                ? exports.ApiAuthenticationHooks.toJSON(message.hooks)
                : undefined);
        message.jwksBased !== undefined &&
            (obj.jwksBased = message.jwksBased
                ? exports.JwksBasedAuthentication.toJSON(message.jwksBased)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseApiAuthenticationConfig,
        };
        if (object.cookieBased !== undefined && object.cookieBased !== null) {
            message.cookieBased = exports.CookieBasedAuthentication.fromPartial(object.cookieBased);
        }
        else {
            message.cookieBased = undefined;
        }
        if (object.hooks !== undefined && object.hooks !== null) {
            message.hooks = exports.ApiAuthenticationHooks.fromPartial(object.hooks);
        }
        else {
            message.hooks = undefined;
        }
        if (object.jwksBased !== undefined && object.jwksBased !== null) {
            message.jwksBased = exports.JwksBasedAuthentication.fromPartial(object.jwksBased);
        }
        else {
            message.jwksBased = undefined;
        }
        return message;
    },
};
const baseJwksBasedAuthentication = {};
exports.JwksBasedAuthentication = {
    encode(message, writer = minimal_1.Writer.create()) {
        for (const v of message.providers) {
            exports.JwksAuthProvider.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseJwksBasedAuthentication,
        };
        message.providers = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.providers.push(exports.JwksAuthProvider.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseJwksBasedAuthentication,
        };
        message.providers = [];
        if (object.providers !== undefined && object.providers !== null) {
            for (const e of object.providers) {
                message.providers.push(exports.JwksAuthProvider.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.providers) {
            obj.providers = message.providers.map((e) => e ? exports.JwksAuthProvider.toJSON(e) : undefined);
        }
        else {
            obj.providers = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseJwksBasedAuthentication,
        };
        message.providers = [];
        if (object.providers !== undefined && object.providers !== null) {
            for (const e of object.providers) {
                message.providers.push(exports.JwksAuthProvider.fromPartial(e));
            }
        }
        return message;
    },
};
const baseJwksAuthProvider = { userInfoCacheTtlSeconds: 0 };
exports.JwksAuthProvider = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.jwksUrl !== undefined) {
            exports.ConfigurationVariable.encode(message.jwksUrl, writer.uint32(10).fork()).ldelim();
        }
        if (message.jwksJson !== undefined) {
            exports.ConfigurationVariable.encode(message.jwksJson, writer.uint32(18).fork()).ldelim();
        }
        if (message.userInfoEndpoint !== undefined) {
            exports.ConfigurationVariable.encode(message.userInfoEndpoint, writer.uint32(26).fork()).ldelim();
        }
        if (message.userInfoCacheTtlSeconds !== 0) {
            writer.uint32(32).int64(message.userInfoCacheTtlSeconds);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseJwksAuthProvider };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.jwksUrl = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.jwksJson = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.userInfoEndpoint = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.userInfoCacheTtlSeconds = longToNumber(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseJwksAuthProvider };
        if (object.jwksUrl !== undefined && object.jwksUrl !== null) {
            message.jwksUrl = exports.ConfigurationVariable.fromJSON(object.jwksUrl);
        }
        else {
            message.jwksUrl = undefined;
        }
        if (object.jwksJson !== undefined && object.jwksJson !== null) {
            message.jwksJson = exports.ConfigurationVariable.fromJSON(object.jwksJson);
        }
        else {
            message.jwksJson = undefined;
        }
        if (object.userInfoEndpoint !== undefined &&
            object.userInfoEndpoint !== null) {
            message.userInfoEndpoint = exports.ConfigurationVariable.fromJSON(object.userInfoEndpoint);
        }
        else {
            message.userInfoEndpoint = undefined;
        }
        if (object.userInfoCacheTtlSeconds !== undefined &&
            object.userInfoCacheTtlSeconds !== null) {
            message.userInfoCacheTtlSeconds = Number(object.userInfoCacheTtlSeconds);
        }
        else {
            message.userInfoCacheTtlSeconds = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.jwksUrl !== undefined &&
            (obj.jwksUrl = message.jwksUrl
                ? exports.ConfigurationVariable.toJSON(message.jwksUrl)
                : undefined);
        message.jwksJson !== undefined &&
            (obj.jwksJson = message.jwksJson
                ? exports.ConfigurationVariable.toJSON(message.jwksJson)
                : undefined);
        message.userInfoEndpoint !== undefined &&
            (obj.userInfoEndpoint = message.userInfoEndpoint
                ? exports.ConfigurationVariable.toJSON(message.userInfoEndpoint)
                : undefined);
        message.userInfoCacheTtlSeconds !== undefined &&
            (obj.userInfoCacheTtlSeconds = message.userInfoCacheTtlSeconds);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseJwksAuthProvider };
        if (object.jwksUrl !== undefined && object.jwksUrl !== null) {
            message.jwksUrl = exports.ConfigurationVariable.fromPartial(object.jwksUrl);
        }
        else {
            message.jwksUrl = undefined;
        }
        if (object.jwksJson !== undefined && object.jwksJson !== null) {
            message.jwksJson = exports.ConfigurationVariable.fromPartial(object.jwksJson);
        }
        else {
            message.jwksJson = undefined;
        }
        if (object.userInfoEndpoint !== undefined &&
            object.userInfoEndpoint !== null) {
            message.userInfoEndpoint = exports.ConfigurationVariable.fromPartial(object.userInfoEndpoint);
        }
        else {
            message.userInfoEndpoint = undefined;
        }
        if (object.userInfoCacheTtlSeconds !== undefined &&
            object.userInfoCacheTtlSeconds !== null) {
            message.userInfoCacheTtlSeconds = object.userInfoCacheTtlSeconds;
        }
        else {
            message.userInfoCacheTtlSeconds = 0;
        }
        return message;
    },
};
const baseApiAuthenticationHooks = {
    postAuthentication: false,
    mutatingPostAuthentication: false,
    revalidateAuthentication: false,
};
exports.ApiAuthenticationHooks = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.postAuthentication === true) {
            writer.uint32(8).bool(message.postAuthentication);
        }
        if (message.mutatingPostAuthentication === true) {
            writer.uint32(16).bool(message.mutatingPostAuthentication);
        }
        if (message.revalidateAuthentication === true) {
            writer.uint32(24).bool(message.revalidateAuthentication);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseApiAuthenticationHooks };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.postAuthentication = reader.bool();
                    break;
                case 2:
                    message.mutatingPostAuthentication = reader.bool();
                    break;
                case 3:
                    message.revalidateAuthentication = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseApiAuthenticationHooks };
        if (object.postAuthentication !== undefined &&
            object.postAuthentication !== null) {
            message.postAuthentication = Boolean(object.postAuthentication);
        }
        else {
            message.postAuthentication = false;
        }
        if (object.mutatingPostAuthentication !== undefined &&
            object.mutatingPostAuthentication !== null) {
            message.mutatingPostAuthentication = Boolean(object.mutatingPostAuthentication);
        }
        else {
            message.mutatingPostAuthentication = false;
        }
        if (object.revalidateAuthentication !== undefined &&
            object.revalidateAuthentication !== null) {
            message.revalidateAuthentication = Boolean(object.revalidateAuthentication);
        }
        else {
            message.revalidateAuthentication = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.postAuthentication !== undefined &&
            (obj.postAuthentication = message.postAuthentication);
        message.mutatingPostAuthentication !== undefined &&
            (obj.mutatingPostAuthentication = message.mutatingPostAuthentication);
        message.revalidateAuthentication !== undefined &&
            (obj.revalidateAuthentication = message.revalidateAuthentication);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseApiAuthenticationHooks };
        if (object.postAuthentication !== undefined &&
            object.postAuthentication !== null) {
            message.postAuthentication = object.postAuthentication;
        }
        else {
            message.postAuthentication = false;
        }
        if (object.mutatingPostAuthentication !== undefined &&
            object.mutatingPostAuthentication !== null) {
            message.mutatingPostAuthentication = object.mutatingPostAuthentication;
        }
        else {
            message.mutatingPostAuthentication = false;
        }
        if (object.revalidateAuthentication !== undefined &&
            object.revalidateAuthentication !== null) {
            message.revalidateAuthentication = object.revalidateAuthentication;
        }
        else {
            message.revalidateAuthentication = false;
        }
        return message;
    },
};
const baseCookieBasedAuthentication = {};
exports.CookieBasedAuthentication = {
    encode(message, writer = minimal_1.Writer.create()) {
        for (const v of message.providers) {
            exports.AuthProvider.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.authorizedRedirectUris) {
            exports.ConfigurationVariable.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.authorizedRedirectUriRegexes) {
            exports.ConfigurationVariable.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.hashKey !== undefined) {
            exports.ConfigurationVariable.encode(message.hashKey, writer.uint32(34).fork()).ldelim();
        }
        if (message.blockKey !== undefined) {
            exports.ConfigurationVariable.encode(message.blockKey, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseCookieBasedAuthentication,
        };
        message.providers = [];
        message.authorizedRedirectUris = [];
        message.authorizedRedirectUriRegexes = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.providers.push(exports.AuthProvider.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.authorizedRedirectUris.push(exports.ConfigurationVariable.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.authorizedRedirectUriRegexes.push(exports.ConfigurationVariable.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.hashKey = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.blockKey = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseCookieBasedAuthentication,
        };
        message.providers = [];
        message.authorizedRedirectUris = [];
        message.authorizedRedirectUriRegexes = [];
        if (object.providers !== undefined && object.providers !== null) {
            for (const e of object.providers) {
                message.providers.push(exports.AuthProvider.fromJSON(e));
            }
        }
        if (object.authorizedRedirectUris !== undefined &&
            object.authorizedRedirectUris !== null) {
            for (const e of object.authorizedRedirectUris) {
                message.authorizedRedirectUris.push(exports.ConfigurationVariable.fromJSON(e));
            }
        }
        if (object.authorizedRedirectUriRegexes !== undefined &&
            object.authorizedRedirectUriRegexes !== null) {
            for (const e of object.authorizedRedirectUriRegexes) {
                message.authorizedRedirectUriRegexes.push(exports.ConfigurationVariable.fromJSON(e));
            }
        }
        if (object.hashKey !== undefined && object.hashKey !== null) {
            message.hashKey = exports.ConfigurationVariable.fromJSON(object.hashKey);
        }
        else {
            message.hashKey = undefined;
        }
        if (object.blockKey !== undefined && object.blockKey !== null) {
            message.blockKey = exports.ConfigurationVariable.fromJSON(object.blockKey);
        }
        else {
            message.blockKey = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.providers) {
            obj.providers = message.providers.map((e) => e ? exports.AuthProvider.toJSON(e) : undefined);
        }
        else {
            obj.providers = [];
        }
        if (message.authorizedRedirectUris) {
            obj.authorizedRedirectUris = message.authorizedRedirectUris.map((e) => e ? exports.ConfigurationVariable.toJSON(e) : undefined);
        }
        else {
            obj.authorizedRedirectUris = [];
        }
        if (message.authorizedRedirectUriRegexes) {
            obj.authorizedRedirectUriRegexes =
                message.authorizedRedirectUriRegexes.map((e) => e ? exports.ConfigurationVariable.toJSON(e) : undefined);
        }
        else {
            obj.authorizedRedirectUriRegexes = [];
        }
        message.hashKey !== undefined &&
            (obj.hashKey = message.hashKey
                ? exports.ConfigurationVariable.toJSON(message.hashKey)
                : undefined);
        message.blockKey !== undefined &&
            (obj.blockKey = message.blockKey
                ? exports.ConfigurationVariable.toJSON(message.blockKey)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseCookieBasedAuthentication,
        };
        message.providers = [];
        message.authorizedRedirectUris = [];
        message.authorizedRedirectUriRegexes = [];
        if (object.providers !== undefined && object.providers !== null) {
            for (const e of object.providers) {
                message.providers.push(exports.AuthProvider.fromPartial(e));
            }
        }
        if (object.authorizedRedirectUris !== undefined &&
            object.authorizedRedirectUris !== null) {
            for (const e of object.authorizedRedirectUris) {
                message.authorizedRedirectUris.push(exports.ConfigurationVariable.fromPartial(e));
            }
        }
        if (object.authorizedRedirectUriRegexes !== undefined &&
            object.authorizedRedirectUriRegexes !== null) {
            for (const e of object.authorizedRedirectUriRegexes) {
                message.authorizedRedirectUriRegexes.push(exports.ConfigurationVariable.fromPartial(e));
            }
        }
        if (object.hashKey !== undefined && object.hashKey !== null) {
            message.hashKey = exports.ConfigurationVariable.fromPartial(object.hashKey);
        }
        else {
            message.hashKey = undefined;
        }
        if (object.blockKey !== undefined && object.blockKey !== null) {
            message.blockKey = exports.ConfigurationVariable.fromPartial(object.blockKey);
        }
        else {
            message.blockKey = undefined;
        }
        return message;
    },
};
const baseAuthProvider = { id: "", kind: 0 };
exports.AuthProvider = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.kind !== 0) {
            writer.uint32(16).int32(message.kind);
        }
        if (message.githubConfig !== undefined) {
            exports.GithubAuthProviderConfig.encode(message.githubConfig, writer.uint32(26).fork()).ldelim();
        }
        if (message.oidcConfig !== undefined) {
            exports.OpenIDConnectAuthProviderConfig.encode(message.oidcConfig, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseAuthProvider };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.kind = reader.int32();
                    break;
                case 3:
                    message.githubConfig = exports.GithubAuthProviderConfig.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.oidcConfig = exports.OpenIDConnectAuthProviderConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseAuthProvider };
        if (object.id !== undefined && object.id !== null) {
            message.id = String(object.id);
        }
        else {
            message.id = "";
        }
        if (object.kind !== undefined && object.kind !== null) {
            message.kind = authProviderKindFromJSON(object.kind);
        }
        else {
            message.kind = 0;
        }
        if (object.githubConfig !== undefined && object.githubConfig !== null) {
            message.githubConfig = exports.GithubAuthProviderConfig.fromJSON(object.githubConfig);
        }
        else {
            message.githubConfig = undefined;
        }
        if (object.oidcConfig !== undefined && object.oidcConfig !== null) {
            message.oidcConfig = exports.OpenIDConnectAuthProviderConfig.fromJSON(object.oidcConfig);
        }
        else {
            message.oidcConfig = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.kind !== undefined &&
            (obj.kind = authProviderKindToJSON(message.kind));
        message.githubConfig !== undefined &&
            (obj.githubConfig = message.githubConfig
                ? exports.GithubAuthProviderConfig.toJSON(message.githubConfig)
                : undefined);
        message.oidcConfig !== undefined &&
            (obj.oidcConfig = message.oidcConfig
                ? exports.OpenIDConnectAuthProviderConfig.toJSON(message.oidcConfig)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseAuthProvider };
        if (object.id !== undefined && object.id !== null) {
            message.id = object.id;
        }
        else {
            message.id = "";
        }
        if (object.kind !== undefined && object.kind !== null) {
            message.kind = object.kind;
        }
        else {
            message.kind = 0;
        }
        if (object.githubConfig !== undefined && object.githubConfig !== null) {
            message.githubConfig = exports.GithubAuthProviderConfig.fromPartial(object.githubConfig);
        }
        else {
            message.githubConfig = undefined;
        }
        if (object.oidcConfig !== undefined && object.oidcConfig !== null) {
            message.oidcConfig = exports.OpenIDConnectAuthProviderConfig.fromPartial(object.oidcConfig);
        }
        else {
            message.oidcConfig = undefined;
        }
        return message;
    },
};
const baseGithubAuthProviderConfig = {};
exports.GithubAuthProviderConfig = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.clientId !== undefined) {
            exports.ConfigurationVariable.encode(message.clientId, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientSecret !== undefined) {
            exports.ConfigurationVariable.encode(message.clientSecret, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseGithubAuthProviderConfig,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.clientId = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.clientSecret = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseGithubAuthProviderConfig,
        };
        if (object.clientId !== undefined && object.clientId !== null) {
            message.clientId = exports.ConfigurationVariable.fromJSON(object.clientId);
        }
        else {
            message.clientId = undefined;
        }
        if (object.clientSecret !== undefined && object.clientSecret !== null) {
            message.clientSecret = exports.ConfigurationVariable.fromJSON(object.clientSecret);
        }
        else {
            message.clientSecret = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.clientId !== undefined &&
            (obj.clientId = message.clientId
                ? exports.ConfigurationVariable.toJSON(message.clientId)
                : undefined);
        message.clientSecret !== undefined &&
            (obj.clientSecret = message.clientSecret
                ? exports.ConfigurationVariable.toJSON(message.clientSecret)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseGithubAuthProviderConfig,
        };
        if (object.clientId !== undefined && object.clientId !== null) {
            message.clientId = exports.ConfigurationVariable.fromPartial(object.clientId);
        }
        else {
            message.clientId = undefined;
        }
        if (object.clientSecret !== undefined && object.clientSecret !== null) {
            message.clientSecret = exports.ConfigurationVariable.fromPartial(object.clientSecret);
        }
        else {
            message.clientSecret = undefined;
        }
        return message;
    },
};
const baseOpenIDConnectAuthProviderConfig = {};
exports.OpenIDConnectAuthProviderConfig = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.issuer !== undefined) {
            exports.ConfigurationVariable.encode(message.issuer, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientId !== undefined) {
            exports.ConfigurationVariable.encode(message.clientId, writer.uint32(18).fork()).ldelim();
        }
        if (message.clientSecret !== undefined) {
            exports.ConfigurationVariable.encode(message.clientSecret, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseOpenIDConnectAuthProviderConfig,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.issuer = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.clientId = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.clientSecret = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseOpenIDConnectAuthProviderConfig,
        };
        if (object.issuer !== undefined && object.issuer !== null) {
            message.issuer = exports.ConfigurationVariable.fromJSON(object.issuer);
        }
        else {
            message.issuer = undefined;
        }
        if (object.clientId !== undefined && object.clientId !== null) {
            message.clientId = exports.ConfigurationVariable.fromJSON(object.clientId);
        }
        else {
            message.clientId = undefined;
        }
        if (object.clientSecret !== undefined && object.clientSecret !== null) {
            message.clientSecret = exports.ConfigurationVariable.fromJSON(object.clientSecret);
        }
        else {
            message.clientSecret = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.issuer !== undefined &&
            (obj.issuer = message.issuer
                ? exports.ConfigurationVariable.toJSON(message.issuer)
                : undefined);
        message.clientId !== undefined &&
            (obj.clientId = message.clientId
                ? exports.ConfigurationVariable.toJSON(message.clientId)
                : undefined);
        message.clientSecret !== undefined &&
            (obj.clientSecret = message.clientSecret
                ? exports.ConfigurationVariable.toJSON(message.clientSecret)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseOpenIDConnectAuthProviderConfig,
        };
        if (object.issuer !== undefined && object.issuer !== null) {
            message.issuer = exports.ConfigurationVariable.fromPartial(object.issuer);
        }
        else {
            message.issuer = undefined;
        }
        if (object.clientId !== undefined && object.clientId !== null) {
            message.clientId = exports.ConfigurationVariable.fromPartial(object.clientId);
        }
        else {
            message.clientId = undefined;
        }
        if (object.clientSecret !== undefined && object.clientSecret !== null) {
            message.clientSecret = exports.ConfigurationVariable.fromPartial(object.clientSecret);
        }
        else {
            message.clientSecret = undefined;
        }
        return message;
    },
};
const baseApiCacheConfig = { kind: 0 };
exports.ApiCacheConfig = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.kind !== 0) {
            writer.uint32(8).int32(message.kind);
        }
        if (message.inMemoryConfig !== undefined) {
            exports.InMemoryCacheConfig.encode(message.inMemoryConfig, writer.uint32(18).fork()).ldelim();
        }
        if (message.redisConfig !== undefined) {
            exports.RedisCacheConfig.encode(message.redisConfig, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseApiCacheConfig };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.int32();
                    break;
                case 2:
                    message.inMemoryConfig = exports.InMemoryCacheConfig.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.redisConfig = exports.RedisCacheConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseApiCacheConfig };
        if (object.kind !== undefined && object.kind !== null) {
            message.kind = apiCacheKindFromJSON(object.kind);
        }
        else {
            message.kind = 0;
        }
        if (object.inMemoryConfig !== undefined && object.inMemoryConfig !== null) {
            message.inMemoryConfig = exports.InMemoryCacheConfig.fromJSON(object.inMemoryConfig);
        }
        else {
            message.inMemoryConfig = undefined;
        }
        if (object.redisConfig !== undefined && object.redisConfig !== null) {
            message.redisConfig = exports.RedisCacheConfig.fromJSON(object.redisConfig);
        }
        else {
            message.redisConfig = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined && (obj.kind = apiCacheKindToJSON(message.kind));
        message.inMemoryConfig !== undefined &&
            (obj.inMemoryConfig = message.inMemoryConfig
                ? exports.InMemoryCacheConfig.toJSON(message.inMemoryConfig)
                : undefined);
        message.redisConfig !== undefined &&
            (obj.redisConfig = message.redisConfig
                ? exports.RedisCacheConfig.toJSON(message.redisConfig)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseApiCacheConfig };
        if (object.kind !== undefined && object.kind !== null) {
            message.kind = object.kind;
        }
        else {
            message.kind = 0;
        }
        if (object.inMemoryConfig !== undefined && object.inMemoryConfig !== null) {
            message.inMemoryConfig = exports.InMemoryCacheConfig.fromPartial(object.inMemoryConfig);
        }
        else {
            message.inMemoryConfig = undefined;
        }
        if (object.redisConfig !== undefined && object.redisConfig !== null) {
            message.redisConfig = exports.RedisCacheConfig.fromPartial(object.redisConfig);
        }
        else {
            message.redisConfig = undefined;
        }
        return message;
    },
};
const baseInMemoryCacheConfig = { maxSize: 0 };
exports.InMemoryCacheConfig = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.maxSize !== 0) {
            writer.uint32(8).int64(message.maxSize);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseInMemoryCacheConfig };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.maxSize = longToNumber(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseInMemoryCacheConfig };
        if (object.maxSize !== undefined && object.maxSize !== null) {
            message.maxSize = Number(object.maxSize);
        }
        else {
            message.maxSize = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.maxSize !== undefined && (obj.maxSize = message.maxSize);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseInMemoryCacheConfig };
        if (object.maxSize !== undefined && object.maxSize !== null) {
            message.maxSize = object.maxSize;
        }
        else {
            message.maxSize = 0;
        }
        return message;
    },
};
const baseRedisCacheConfig = { redisUrlEnvVar: "" };
exports.RedisCacheConfig = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.redisUrlEnvVar !== "") {
            writer.uint32(10).string(message.redisUrlEnvVar);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseRedisCacheConfig };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.redisUrlEnvVar = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseRedisCacheConfig };
        if (object.redisUrlEnvVar !== undefined && object.redisUrlEnvVar !== null) {
            message.redisUrlEnvVar = String(object.redisUrlEnvVar);
        }
        else {
            message.redisUrlEnvVar = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.redisUrlEnvVar !== undefined &&
            (obj.redisUrlEnvVar = message.redisUrlEnvVar);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseRedisCacheConfig };
        if (object.redisUrlEnvVar !== undefined && object.redisUrlEnvVar !== null) {
            message.redisUrlEnvVar = object.redisUrlEnvVar;
        }
        else {
            message.redisUrlEnvVar = "";
        }
        return message;
    },
};
const baseOperation = {
    name: "",
    content: "",
    operationType: 0,
    variablesSchema: "",
    responseSchema: "",
    internal: false,
};
exports.Operation = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.content !== "") {
            writer.uint32(18).string(message.content);
        }
        if (message.operationType !== 0) {
            writer.uint32(24).int32(message.operationType);
        }
        if (message.variablesSchema !== "") {
            writer.uint32(34).string(message.variablesSchema);
        }
        if (message.responseSchema !== "") {
            writer.uint32(42).string(message.responseSchema);
        }
        if (message.cacheConfig !== undefined) {
            exports.OperationCacheConfig.encode(message.cacheConfig, writer.uint32(58).fork()).ldelim();
        }
        if (message.authenticationConfig !== undefined) {
            exports.OperationAuthenticationConfig.encode(message.authenticationConfig, writer.uint32(66).fork()).ldelim();
        }
        if (message.liveQueryConfig !== undefined) {
            exports.OperationLiveQueryConfig.encode(message.liveQueryConfig, writer.uint32(74).fork()).ldelim();
        }
        if (message.authorizationConfig !== undefined) {
            exports.OperationAuthorizationConfig.encode(message.authorizationConfig, writer.uint32(82).fork()).ldelim();
        }
        if (message.hooksConfiguration !== undefined) {
            exports.OperationHooksConfiguration.encode(message.hooksConfiguration, writer.uint32(90).fork()).ldelim();
        }
        if (message.variablesConfiguration !== undefined) {
            exports.OperationVariablesConfiguration.encode(message.variablesConfiguration, writer.uint32(98).fork()).ldelim();
        }
        if (message.internal === true) {
            writer.uint32(104).bool(message.internal);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseOperation };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.content = reader.string();
                    break;
                case 3:
                    message.operationType = reader.int32();
                    break;
                case 4:
                    message.variablesSchema = reader.string();
                    break;
                case 5:
                    message.responseSchema = reader.string();
                    break;
                case 7:
                    message.cacheConfig = exports.OperationCacheConfig.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.authenticationConfig = exports.OperationAuthenticationConfig.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.liveQueryConfig = exports.OperationLiveQueryConfig.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.authorizationConfig = exports.OperationAuthorizationConfig.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.hooksConfiguration = exports.OperationHooksConfiguration.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.variablesConfiguration =
                        exports.OperationVariablesConfiguration.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.internal = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseOperation };
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        }
        else {
            message.name = "";
        }
        if (object.content !== undefined && object.content !== null) {
            message.content = String(object.content);
        }
        else {
            message.content = "";
        }
        if (object.operationType !== undefined && object.operationType !== null) {
            message.operationType = operationTypeFromJSON(object.operationType);
        }
        else {
            message.operationType = 0;
        }
        if (object.variablesSchema !== undefined &&
            object.variablesSchema !== null) {
            message.variablesSchema = String(object.variablesSchema);
        }
        else {
            message.variablesSchema = "";
        }
        if (object.responseSchema !== undefined && object.responseSchema !== null) {
            message.responseSchema = String(object.responseSchema);
        }
        else {
            message.responseSchema = "";
        }
        if (object.cacheConfig !== undefined && object.cacheConfig !== null) {
            message.cacheConfig = exports.OperationCacheConfig.fromJSON(object.cacheConfig);
        }
        else {
            message.cacheConfig = undefined;
        }
        if (object.authenticationConfig !== undefined &&
            object.authenticationConfig !== null) {
            message.authenticationConfig = exports.OperationAuthenticationConfig.fromJSON(object.authenticationConfig);
        }
        else {
            message.authenticationConfig = undefined;
        }
        if (object.liveQueryConfig !== undefined &&
            object.liveQueryConfig !== null) {
            message.liveQueryConfig = exports.OperationLiveQueryConfig.fromJSON(object.liveQueryConfig);
        }
        else {
            message.liveQueryConfig = undefined;
        }
        if (object.authorizationConfig !== undefined &&
            object.authorizationConfig !== null) {
            message.authorizationConfig = exports.OperationAuthorizationConfig.fromJSON(object.authorizationConfig);
        }
        else {
            message.authorizationConfig = undefined;
        }
        if (object.hooksConfiguration !== undefined &&
            object.hooksConfiguration !== null) {
            message.hooksConfiguration = exports.OperationHooksConfiguration.fromJSON(object.hooksConfiguration);
        }
        else {
            message.hooksConfiguration = undefined;
        }
        if (object.variablesConfiguration !== undefined &&
            object.variablesConfiguration !== null) {
            message.variablesConfiguration = exports.OperationVariablesConfiguration.fromJSON(object.variablesConfiguration);
        }
        else {
            message.variablesConfiguration = undefined;
        }
        if (object.internal !== undefined && object.internal !== null) {
            message.internal = Boolean(object.internal);
        }
        else {
            message.internal = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.content !== undefined && (obj.content = message.content);
        message.operationType !== undefined &&
            (obj.operationType = operationTypeToJSON(message.operationType));
        message.variablesSchema !== undefined &&
            (obj.variablesSchema = message.variablesSchema);
        message.responseSchema !== undefined &&
            (obj.responseSchema = message.responseSchema);
        message.cacheConfig !== undefined &&
            (obj.cacheConfig = message.cacheConfig
                ? exports.OperationCacheConfig.toJSON(message.cacheConfig)
                : undefined);
        message.authenticationConfig !== undefined &&
            (obj.authenticationConfig = message.authenticationConfig
                ? exports.OperationAuthenticationConfig.toJSON(message.authenticationConfig)
                : undefined);
        message.liveQueryConfig !== undefined &&
            (obj.liveQueryConfig = message.liveQueryConfig
                ? exports.OperationLiveQueryConfig.toJSON(message.liveQueryConfig)
                : undefined);
        message.authorizationConfig !== undefined &&
            (obj.authorizationConfig = message.authorizationConfig
                ? exports.OperationAuthorizationConfig.toJSON(message.authorizationConfig)
                : undefined);
        message.hooksConfiguration !== undefined &&
            (obj.hooksConfiguration = message.hooksConfiguration
                ? exports.OperationHooksConfiguration.toJSON(message.hooksConfiguration)
                : undefined);
        message.variablesConfiguration !== undefined &&
            (obj.variablesConfiguration = message.variablesConfiguration
                ? exports.OperationVariablesConfiguration.toJSON(message.variablesConfiguration)
                : undefined);
        message.internal !== undefined && (obj.internal = message.internal);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseOperation };
        if (object.name !== undefined && object.name !== null) {
            message.name = object.name;
        }
        else {
            message.name = "";
        }
        if (object.content !== undefined && object.content !== null) {
            message.content = object.content;
        }
        else {
            message.content = "";
        }
        if (object.operationType !== undefined && object.operationType !== null) {
            message.operationType = object.operationType;
        }
        else {
            message.operationType = 0;
        }
        if (object.variablesSchema !== undefined &&
            object.variablesSchema !== null) {
            message.variablesSchema = object.variablesSchema;
        }
        else {
            message.variablesSchema = "";
        }
        if (object.responseSchema !== undefined && object.responseSchema !== null) {
            message.responseSchema = object.responseSchema;
        }
        else {
            message.responseSchema = "";
        }
        if (object.cacheConfig !== undefined && object.cacheConfig !== null) {
            message.cacheConfig = exports.OperationCacheConfig.fromPartial(object.cacheConfig);
        }
        else {
            message.cacheConfig = undefined;
        }
        if (object.authenticationConfig !== undefined &&
            object.authenticationConfig !== null) {
            message.authenticationConfig = exports.OperationAuthenticationConfig.fromPartial(object.authenticationConfig);
        }
        else {
            message.authenticationConfig = undefined;
        }
        if (object.liveQueryConfig !== undefined &&
            object.liveQueryConfig !== null) {
            message.liveQueryConfig = exports.OperationLiveQueryConfig.fromPartial(object.liveQueryConfig);
        }
        else {
            message.liveQueryConfig = undefined;
        }
        if (object.authorizationConfig !== undefined &&
            object.authorizationConfig !== null) {
            message.authorizationConfig = exports.OperationAuthorizationConfig.fromPartial(object.authorizationConfig);
        }
        else {
            message.authorizationConfig = undefined;
        }
        if (object.hooksConfiguration !== undefined &&
            object.hooksConfiguration !== null) {
            message.hooksConfiguration = exports.OperationHooksConfiguration.fromPartial(object.hooksConfiguration);
        }
        else {
            message.hooksConfiguration = undefined;
        }
        if (object.variablesConfiguration !== undefined &&
            object.variablesConfiguration !== null) {
            message.variablesConfiguration =
                exports.OperationVariablesConfiguration.fromPartial(object.variablesConfiguration);
        }
        else {
            message.variablesConfiguration = undefined;
        }
        if (object.internal !== undefined && object.internal !== null) {
            message.internal = object.internal;
        }
        else {
            message.internal = false;
        }
        return message;
    },
};
const baseOperationVariablesConfiguration = {};
exports.OperationVariablesConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        for (const v of message.injectVariables) {
            exports.VariableInjectionConfiguration.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseOperationVariablesConfiguration,
        };
        message.injectVariables = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.injectVariables.push(exports.VariableInjectionConfiguration.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseOperationVariablesConfiguration,
        };
        message.injectVariables = [];
        if (object.injectVariables !== undefined &&
            object.injectVariables !== null) {
            for (const e of object.injectVariables) {
                message.injectVariables.push(exports.VariableInjectionConfiguration.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.injectVariables) {
            obj.injectVariables = message.injectVariables.map((e) => e ? exports.VariableInjectionConfiguration.toJSON(e) : undefined);
        }
        else {
            obj.injectVariables = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseOperationVariablesConfiguration,
        };
        message.injectVariables = [];
        if (object.injectVariables !== undefined &&
            object.injectVariables !== null) {
            for (const e of object.injectVariables) {
                message.injectVariables.push(exports.VariableInjectionConfiguration.fromPartial(e));
            }
        }
        return message;
    },
};
const baseVariableInjectionConfiguration = {
    variableName: "",
    variableKind: 0,
    dateFormat: "",
    environmentVariableName: "",
};
exports.VariableInjectionConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.variableName !== "") {
            writer.uint32(10).string(message.variableName);
        }
        if (message.variableKind !== 0) {
            writer.uint32(16).int32(message.variableKind);
        }
        if (message.dateFormat !== "") {
            writer.uint32(26).string(message.dateFormat);
        }
        if (message.environmentVariableName !== "") {
            writer.uint32(34).string(message.environmentVariableName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseVariableInjectionConfiguration,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.variableName = reader.string();
                    break;
                case 2:
                    message.variableKind = reader.int32();
                    break;
                case 3:
                    message.dateFormat = reader.string();
                    break;
                case 4:
                    message.environmentVariableName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseVariableInjectionConfiguration,
        };
        if (object.variableName !== undefined && object.variableName !== null) {
            message.variableName = String(object.variableName);
        }
        else {
            message.variableName = "";
        }
        if (object.variableKind !== undefined && object.variableKind !== null) {
            message.variableKind = injectVariableKindFromJSON(object.variableKind);
        }
        else {
            message.variableKind = 0;
        }
        if (object.dateFormat !== undefined && object.dateFormat !== null) {
            message.dateFormat = String(object.dateFormat);
        }
        else {
            message.dateFormat = "";
        }
        if (object.environmentVariableName !== undefined &&
            object.environmentVariableName !== null) {
            message.environmentVariableName = String(object.environmentVariableName);
        }
        else {
            message.environmentVariableName = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.variableName !== undefined &&
            (obj.variableName = message.variableName);
        message.variableKind !== undefined &&
            (obj.variableKind = injectVariableKindToJSON(message.variableKind));
        message.dateFormat !== undefined && (obj.dateFormat = message.dateFormat);
        message.environmentVariableName !== undefined &&
            (obj.environmentVariableName = message.environmentVariableName);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseVariableInjectionConfiguration,
        };
        if (object.variableName !== undefined && object.variableName !== null) {
            message.variableName = object.variableName;
        }
        else {
            message.variableName = "";
        }
        if (object.variableKind !== undefined && object.variableKind !== null) {
            message.variableKind = object.variableKind;
        }
        else {
            message.variableKind = 0;
        }
        if (object.dateFormat !== undefined && object.dateFormat !== null) {
            message.dateFormat = object.dateFormat;
        }
        else {
            message.dateFormat = "";
        }
        if (object.environmentVariableName !== undefined &&
            object.environmentVariableName !== null) {
            message.environmentVariableName = object.environmentVariableName;
        }
        else {
            message.environmentVariableName = "";
        }
        return message;
    },
};
const baseOperationHooksConfiguration = {
    preResolve: false,
    postResolve: false,
    mutatingPreResolve: false,
    mutatingPostResolve: false,
};
exports.OperationHooksConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.preResolve === true) {
            writer.uint32(8).bool(message.preResolve);
        }
        if (message.postResolve === true) {
            writer.uint32(16).bool(message.postResolve);
        }
        if (message.mutatingPreResolve === true) {
            writer.uint32(24).bool(message.mutatingPreResolve);
        }
        if (message.mutatingPostResolve === true) {
            writer.uint32(32).bool(message.mutatingPostResolve);
        }
        if (message.mockResolve !== undefined) {
            exports.MockResolveHookConfiguration.encode(message.mockResolve, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseOperationHooksConfiguration,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.preResolve = reader.bool();
                    break;
                case 2:
                    message.postResolve = reader.bool();
                    break;
                case 3:
                    message.mutatingPreResolve = reader.bool();
                    break;
                case 4:
                    message.mutatingPostResolve = reader.bool();
                    break;
                case 5:
                    message.mockResolve = exports.MockResolveHookConfiguration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseOperationHooksConfiguration,
        };
        if (object.preResolve !== undefined && object.preResolve !== null) {
            message.preResolve = Boolean(object.preResolve);
        }
        else {
            message.preResolve = false;
        }
        if (object.postResolve !== undefined && object.postResolve !== null) {
            message.postResolve = Boolean(object.postResolve);
        }
        else {
            message.postResolve = false;
        }
        if (object.mutatingPreResolve !== undefined &&
            object.mutatingPreResolve !== null) {
            message.mutatingPreResolve = Boolean(object.mutatingPreResolve);
        }
        else {
            message.mutatingPreResolve = false;
        }
        if (object.mutatingPostResolve !== undefined &&
            object.mutatingPostResolve !== null) {
            message.mutatingPostResolve = Boolean(object.mutatingPostResolve);
        }
        else {
            message.mutatingPostResolve = false;
        }
        if (object.mockResolve !== undefined && object.mockResolve !== null) {
            message.mockResolve = exports.MockResolveHookConfiguration.fromJSON(object.mockResolve);
        }
        else {
            message.mockResolve = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.preResolve !== undefined && (obj.preResolve = message.preResolve);
        message.postResolve !== undefined &&
            (obj.postResolve = message.postResolve);
        message.mutatingPreResolve !== undefined &&
            (obj.mutatingPreResolve = message.mutatingPreResolve);
        message.mutatingPostResolve !== undefined &&
            (obj.mutatingPostResolve = message.mutatingPostResolve);
        message.mockResolve !== undefined &&
            (obj.mockResolve = message.mockResolve
                ? exports.MockResolveHookConfiguration.toJSON(message.mockResolve)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseOperationHooksConfiguration,
        };
        if (object.preResolve !== undefined && object.preResolve !== null) {
            message.preResolve = object.preResolve;
        }
        else {
            message.preResolve = false;
        }
        if (object.postResolve !== undefined && object.postResolve !== null) {
            message.postResolve = object.postResolve;
        }
        else {
            message.postResolve = false;
        }
        if (object.mutatingPreResolve !== undefined &&
            object.mutatingPreResolve !== null) {
            message.mutatingPreResolve = object.mutatingPreResolve;
        }
        else {
            message.mutatingPreResolve = false;
        }
        if (object.mutatingPostResolve !== undefined &&
            object.mutatingPostResolve !== null) {
            message.mutatingPostResolve = object.mutatingPostResolve;
        }
        else {
            message.mutatingPostResolve = false;
        }
        if (object.mockResolve !== undefined && object.mockResolve !== null) {
            message.mockResolve = exports.MockResolveHookConfiguration.fromPartial(object.mockResolve);
        }
        else {
            message.mockResolve = undefined;
        }
        return message;
    },
};
const baseMockResolveHookConfiguration = {
    enable: false,
    subscriptionPollingIntervalMillis: 0,
};
exports.MockResolveHookConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.enable === true) {
            writer.uint32(8).bool(message.enable);
        }
        if (message.subscriptionPollingIntervalMillis !== 0) {
            writer.uint32(16).int64(message.subscriptionPollingIntervalMillis);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseMockResolveHookConfiguration,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.enable = reader.bool();
                    break;
                case 2:
                    message.subscriptionPollingIntervalMillis = longToNumber(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseMockResolveHookConfiguration,
        };
        if (object.enable !== undefined && object.enable !== null) {
            message.enable = Boolean(object.enable);
        }
        else {
            message.enable = false;
        }
        if (object.subscriptionPollingIntervalMillis !== undefined &&
            object.subscriptionPollingIntervalMillis !== null) {
            message.subscriptionPollingIntervalMillis = Number(object.subscriptionPollingIntervalMillis);
        }
        else {
            message.subscriptionPollingIntervalMillis = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.enable !== undefined && (obj.enable = message.enable);
        message.subscriptionPollingIntervalMillis !== undefined &&
            (obj.subscriptionPollingIntervalMillis =
                message.subscriptionPollingIntervalMillis);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseMockResolveHookConfiguration,
        };
        if (object.enable !== undefined && object.enable !== null) {
            message.enable = object.enable;
        }
        else {
            message.enable = false;
        }
        if (object.subscriptionPollingIntervalMillis !== undefined &&
            object.subscriptionPollingIntervalMillis !== null) {
            message.subscriptionPollingIntervalMillis =
                object.subscriptionPollingIntervalMillis;
        }
        else {
            message.subscriptionPollingIntervalMillis = 0;
        }
        return message;
    },
};
const baseOperationAuthorizationConfig = {};
exports.OperationAuthorizationConfig = {
    encode(message, writer = minimal_1.Writer.create()) {
        for (const v of message.claims) {
            exports.ClaimConfig.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.roleConfig !== undefined) {
            exports.OperationRoleConfig.encode(message.roleConfig, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseOperationAuthorizationConfig,
        };
        message.claims = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.claims.push(exports.ClaimConfig.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.roleConfig = exports.OperationRoleConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseOperationAuthorizationConfig,
        };
        message.claims = [];
        if (object.claims !== undefined && object.claims !== null) {
            for (const e of object.claims) {
                message.claims.push(exports.ClaimConfig.fromJSON(e));
            }
        }
        if (object.roleConfig !== undefined && object.roleConfig !== null) {
            message.roleConfig = exports.OperationRoleConfig.fromJSON(object.roleConfig);
        }
        else {
            message.roleConfig = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.claims) {
            obj.claims = message.claims.map((e) => e ? exports.ClaimConfig.toJSON(e) : undefined);
        }
        else {
            obj.claims = [];
        }
        message.roleConfig !== undefined &&
            (obj.roleConfig = message.roleConfig
                ? exports.OperationRoleConfig.toJSON(message.roleConfig)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseOperationAuthorizationConfig,
        };
        message.claims = [];
        if (object.claims !== undefined && object.claims !== null) {
            for (const e of object.claims) {
                message.claims.push(exports.ClaimConfig.fromPartial(e));
            }
        }
        if (object.roleConfig !== undefined && object.roleConfig !== null) {
            message.roleConfig = exports.OperationRoleConfig.fromPartial(object.roleConfig);
        }
        else {
            message.roleConfig = undefined;
        }
        return message;
    },
};
const baseOperationRoleConfig = {
    requireMatchAll: "",
    requireMatchAny: "",
    denyMatchAll: "",
    denyMatchAny: "",
};
exports.OperationRoleConfig = {
    encode(message, writer = minimal_1.Writer.create()) {
        for (const v of message.requireMatchAll) {
            writer.uint32(10).string(v);
        }
        for (const v of message.requireMatchAny) {
            writer.uint32(18).string(v);
        }
        for (const v of message.denyMatchAll) {
            writer.uint32(26).string(v);
        }
        for (const v of message.denyMatchAny) {
            writer.uint32(34).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseOperationRoleConfig };
        message.requireMatchAll = [];
        message.requireMatchAny = [];
        message.denyMatchAll = [];
        message.denyMatchAny = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requireMatchAll.push(reader.string());
                    break;
                case 2:
                    message.requireMatchAny.push(reader.string());
                    break;
                case 3:
                    message.denyMatchAll.push(reader.string());
                    break;
                case 4:
                    message.denyMatchAny.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseOperationRoleConfig };
        message.requireMatchAll = [];
        message.requireMatchAny = [];
        message.denyMatchAll = [];
        message.denyMatchAny = [];
        if (object.requireMatchAll !== undefined &&
            object.requireMatchAll !== null) {
            for (const e of object.requireMatchAll) {
                message.requireMatchAll.push(String(e));
            }
        }
        if (object.requireMatchAny !== undefined &&
            object.requireMatchAny !== null) {
            for (const e of object.requireMatchAny) {
                message.requireMatchAny.push(String(e));
            }
        }
        if (object.denyMatchAll !== undefined && object.denyMatchAll !== null) {
            for (const e of object.denyMatchAll) {
                message.denyMatchAll.push(String(e));
            }
        }
        if (object.denyMatchAny !== undefined && object.denyMatchAny !== null) {
            for (const e of object.denyMatchAny) {
                message.denyMatchAny.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.requireMatchAll) {
            obj.requireMatchAll = message.requireMatchAll.map((e) => e);
        }
        else {
            obj.requireMatchAll = [];
        }
        if (message.requireMatchAny) {
            obj.requireMatchAny = message.requireMatchAny.map((e) => e);
        }
        else {
            obj.requireMatchAny = [];
        }
        if (message.denyMatchAll) {
            obj.denyMatchAll = message.denyMatchAll.map((e) => e);
        }
        else {
            obj.denyMatchAll = [];
        }
        if (message.denyMatchAny) {
            obj.denyMatchAny = message.denyMatchAny.map((e) => e);
        }
        else {
            obj.denyMatchAny = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseOperationRoleConfig };
        message.requireMatchAll = [];
        message.requireMatchAny = [];
        message.denyMatchAll = [];
        message.denyMatchAny = [];
        if (object.requireMatchAll !== undefined &&
            object.requireMatchAll !== null) {
            for (const e of object.requireMatchAll) {
                message.requireMatchAll.push(e);
            }
        }
        if (object.requireMatchAny !== undefined &&
            object.requireMatchAny !== null) {
            for (const e of object.requireMatchAny) {
                message.requireMatchAny.push(e);
            }
        }
        if (object.denyMatchAll !== undefined && object.denyMatchAll !== null) {
            for (const e of object.denyMatchAll) {
                message.denyMatchAll.push(e);
            }
        }
        if (object.denyMatchAny !== undefined && object.denyMatchAny !== null) {
            for (const e of object.denyMatchAny) {
                message.denyMatchAny.push(e);
            }
        }
        return message;
    },
};
const baseClaimConfig = { variableName: "", claim: 0 };
exports.ClaimConfig = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.variableName !== "") {
            writer.uint32(10).string(message.variableName);
        }
        if (message.claim !== 0) {
            writer.uint32(16).int32(message.claim);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseClaimConfig };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.variableName = reader.string();
                    break;
                case 2:
                    message.claim = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseClaimConfig };
        if (object.variableName !== undefined && object.variableName !== null) {
            message.variableName = String(object.variableName);
        }
        else {
            message.variableName = "";
        }
        if (object.claim !== undefined && object.claim !== null) {
            message.claim = claimFromJSON(object.claim);
        }
        else {
            message.claim = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.variableName !== undefined &&
            (obj.variableName = message.variableName);
        message.claim !== undefined && (obj.claim = claimToJSON(message.claim));
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseClaimConfig };
        if (object.variableName !== undefined && object.variableName !== null) {
            message.variableName = object.variableName;
        }
        else {
            message.variableName = "";
        }
        if (object.claim !== undefined && object.claim !== null) {
            message.claim = object.claim;
        }
        else {
            message.claim = 0;
        }
        return message;
    },
};
const baseOperationLiveQueryConfig = {
    enable: false,
    pollingIntervalSeconds: 0,
};
exports.OperationLiveQueryConfig = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.enable === true) {
            writer.uint32(8).bool(message.enable);
        }
        if (message.pollingIntervalSeconds !== 0) {
            writer.uint32(16).int64(message.pollingIntervalSeconds);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseOperationLiveQueryConfig,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.enable = reader.bool();
                    break;
                case 2:
                    message.pollingIntervalSeconds = longToNumber(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseOperationLiveQueryConfig,
        };
        if (object.enable !== undefined && object.enable !== null) {
            message.enable = Boolean(object.enable);
        }
        else {
            message.enable = false;
        }
        if (object.pollingIntervalSeconds !== undefined &&
            object.pollingIntervalSeconds !== null) {
            message.pollingIntervalSeconds = Number(object.pollingIntervalSeconds);
        }
        else {
            message.pollingIntervalSeconds = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.enable !== undefined && (obj.enable = message.enable);
        message.pollingIntervalSeconds !== undefined &&
            (obj.pollingIntervalSeconds = message.pollingIntervalSeconds);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseOperationLiveQueryConfig,
        };
        if (object.enable !== undefined && object.enable !== null) {
            message.enable = object.enable;
        }
        else {
            message.enable = false;
        }
        if (object.pollingIntervalSeconds !== undefined &&
            object.pollingIntervalSeconds !== null) {
            message.pollingIntervalSeconds = object.pollingIntervalSeconds;
        }
        else {
            message.pollingIntervalSeconds = 0;
        }
        return message;
    },
};
const baseOperationAuthenticationConfig = { authRequired: false };
exports.OperationAuthenticationConfig = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.authRequired === true) {
            writer.uint32(8).bool(message.authRequired);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseOperationAuthenticationConfig,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.authRequired = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseOperationAuthenticationConfig,
        };
        if (object.authRequired !== undefined && object.authRequired !== null) {
            message.authRequired = Boolean(object.authRequired);
        }
        else {
            message.authRequired = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.authRequired !== undefined &&
            (obj.authRequired = message.authRequired);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseOperationAuthenticationConfig,
        };
        if (object.authRequired !== undefined && object.authRequired !== null) {
            message.authRequired = object.authRequired;
        }
        else {
            message.authRequired = false;
        }
        return message;
    },
};
const baseOperationCacheConfig = {
    enable: false,
    maxAge: 0,
    public: false,
    staleWhileRevalidate: 0,
};
exports.OperationCacheConfig = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.enable === true) {
            writer.uint32(8).bool(message.enable);
        }
        if (message.maxAge !== 0) {
            writer.uint32(16).int64(message.maxAge);
        }
        if (message.public === true) {
            writer.uint32(24).bool(message.public);
        }
        if (message.staleWhileRevalidate !== 0) {
            writer.uint32(32).int64(message.staleWhileRevalidate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseOperationCacheConfig };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.enable = reader.bool();
                    break;
                case 2:
                    message.maxAge = longToNumber(reader.int64());
                    break;
                case 3:
                    message.public = reader.bool();
                    break;
                case 4:
                    message.staleWhileRevalidate = longToNumber(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseOperationCacheConfig };
        if (object.enable !== undefined && object.enable !== null) {
            message.enable = Boolean(object.enable);
        }
        else {
            message.enable = false;
        }
        if (object.maxAge !== undefined && object.maxAge !== null) {
            message.maxAge = Number(object.maxAge);
        }
        else {
            message.maxAge = 0;
        }
        if (object.public !== undefined && object.public !== null) {
            message.public = Boolean(object.public);
        }
        else {
            message.public = false;
        }
        if (object.staleWhileRevalidate !== undefined &&
            object.staleWhileRevalidate !== null) {
            message.staleWhileRevalidate = Number(object.staleWhileRevalidate);
        }
        else {
            message.staleWhileRevalidate = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.enable !== undefined && (obj.enable = message.enable);
        message.maxAge !== undefined && (obj.maxAge = message.maxAge);
        message.public !== undefined && (obj.public = message.public);
        message.staleWhileRevalidate !== undefined &&
            (obj.staleWhileRevalidate = message.staleWhileRevalidate);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseOperationCacheConfig };
        if (object.enable !== undefined && object.enable !== null) {
            message.enable = object.enable;
        }
        else {
            message.enable = false;
        }
        if (object.maxAge !== undefined && object.maxAge !== null) {
            message.maxAge = object.maxAge;
        }
        else {
            message.maxAge = 0;
        }
        if (object.public !== undefined && object.public !== null) {
            message.public = object.public;
        }
        else {
            message.public = false;
        }
        if (object.staleWhileRevalidate !== undefined &&
            object.staleWhileRevalidate !== null) {
            message.staleWhileRevalidate = object.staleWhileRevalidate;
        }
        else {
            message.staleWhileRevalidate = 0;
        }
        return message;
    },
};
const baseEngineConfiguration = {
    defaultFlushInterval: 0,
    graphqlSchema: "",
};
exports.EngineConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.defaultFlushInterval !== 0) {
            writer.uint32(8).int64(message.defaultFlushInterval);
        }
        for (const v of message.datasourceConfigurations) {
            exports.DataSourceConfiguration.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.fieldConfigurations) {
            exports.FieldConfiguration.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.graphqlSchema !== "") {
            writer.uint32(34).string(message.graphqlSchema);
        }
        for (const v of message.typeConfigurations) {
            exports.TypeConfiguration.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseEngineConfiguration };
        message.datasourceConfigurations = [];
        message.fieldConfigurations = [];
        message.typeConfigurations = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.defaultFlushInterval = longToNumber(reader.int64());
                    break;
                case 2:
                    message.datasourceConfigurations.push(exports.DataSourceConfiguration.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.fieldConfigurations.push(exports.FieldConfiguration.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.graphqlSchema = reader.string();
                    break;
                case 5:
                    message.typeConfigurations.push(exports.TypeConfiguration.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseEngineConfiguration };
        message.datasourceConfigurations = [];
        message.fieldConfigurations = [];
        message.typeConfigurations = [];
        if (object.defaultFlushInterval !== undefined &&
            object.defaultFlushInterval !== null) {
            message.defaultFlushInterval = Number(object.defaultFlushInterval);
        }
        else {
            message.defaultFlushInterval = 0;
        }
        if (object.datasourceConfigurations !== undefined &&
            object.datasourceConfigurations !== null) {
            for (const e of object.datasourceConfigurations) {
                message.datasourceConfigurations.push(exports.DataSourceConfiguration.fromJSON(e));
            }
        }
        if (object.fieldConfigurations !== undefined &&
            object.fieldConfigurations !== null) {
            for (const e of object.fieldConfigurations) {
                message.fieldConfigurations.push(exports.FieldConfiguration.fromJSON(e));
            }
        }
        if (object.graphqlSchema !== undefined && object.graphqlSchema !== null) {
            message.graphqlSchema = String(object.graphqlSchema);
        }
        else {
            message.graphqlSchema = "";
        }
        if (object.typeConfigurations !== undefined &&
            object.typeConfigurations !== null) {
            for (const e of object.typeConfigurations) {
                message.typeConfigurations.push(exports.TypeConfiguration.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.defaultFlushInterval !== undefined &&
            (obj.defaultFlushInterval = message.defaultFlushInterval);
        if (message.datasourceConfigurations) {
            obj.datasourceConfigurations = message.datasourceConfigurations.map((e) => e ? exports.DataSourceConfiguration.toJSON(e) : undefined);
        }
        else {
            obj.datasourceConfigurations = [];
        }
        if (message.fieldConfigurations) {
            obj.fieldConfigurations = message.fieldConfigurations.map((e) => e ? exports.FieldConfiguration.toJSON(e) : undefined);
        }
        else {
            obj.fieldConfigurations = [];
        }
        message.graphqlSchema !== undefined &&
            (obj.graphqlSchema = message.graphqlSchema);
        if (message.typeConfigurations) {
            obj.typeConfigurations = message.typeConfigurations.map((e) => e ? exports.TypeConfiguration.toJSON(e) : undefined);
        }
        else {
            obj.typeConfigurations = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseEngineConfiguration };
        message.datasourceConfigurations = [];
        message.fieldConfigurations = [];
        message.typeConfigurations = [];
        if (object.defaultFlushInterval !== undefined &&
            object.defaultFlushInterval !== null) {
            message.defaultFlushInterval = object.defaultFlushInterval;
        }
        else {
            message.defaultFlushInterval = 0;
        }
        if (object.datasourceConfigurations !== undefined &&
            object.datasourceConfigurations !== null) {
            for (const e of object.datasourceConfigurations) {
                message.datasourceConfigurations.push(exports.DataSourceConfiguration.fromPartial(e));
            }
        }
        if (object.fieldConfigurations !== undefined &&
            object.fieldConfigurations !== null) {
            for (const e of object.fieldConfigurations) {
                message.fieldConfigurations.push(exports.FieldConfiguration.fromPartial(e));
            }
        }
        if (object.graphqlSchema !== undefined && object.graphqlSchema !== null) {
            message.graphqlSchema = object.graphqlSchema;
        }
        else {
            message.graphqlSchema = "";
        }
        if (object.typeConfigurations !== undefined &&
            object.typeConfigurations !== null) {
            for (const e of object.typeConfigurations) {
                message.typeConfigurations.push(exports.TypeConfiguration.fromPartial(e));
            }
        }
        return message;
    },
};
const baseDataSourceConfiguration = {
    kind: 0,
    overrideFieldPathFromAlias: false,
};
exports.DataSourceConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.kind !== 0) {
            writer.uint32(8).int32(message.kind);
        }
        for (const v of message.rootNodes) {
            exports.TypeField.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.childNodes) {
            exports.TypeField.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.overrideFieldPathFromAlias === true) {
            writer.uint32(32).bool(message.overrideFieldPathFromAlias);
        }
        if (message.customRest !== undefined) {
            exports.DatasourcecustomRest.encode(message.customRest, writer.uint32(42).fork()).ldelim();
        }
        if (message.customGraphql !== undefined) {
            exports.DatasourcecustomGraphql.encode(message.customGraphql, writer.uint32(50).fork()).ldelim();
        }
        if (message.customStatic !== undefined) {
            exports.DatasourcecustomStatic.encode(message.customStatic, writer.uint32(58).fork()).ldelim();
        }
        if (message.customDatabase !== undefined) {
            exports.DatasourcecustomDatabase.encode(message.customDatabase, writer.uint32(66).fork()).ldelim();
        }
        for (const v of message.directives) {
            exports.DirectiveConfiguration.encode(v, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseDataSourceConfiguration,
        };
        message.rootNodes = [];
        message.childNodes = [];
        message.directives = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.int32();
                    break;
                case 2:
                    message.rootNodes.push(exports.TypeField.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.childNodes.push(exports.TypeField.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.overrideFieldPathFromAlias = reader.bool();
                    break;
                case 5:
                    message.customRest = exports.DatasourcecustomRest.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.customGraphql = exports.DatasourcecustomGraphql.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.customStatic = exports.DatasourcecustomStatic.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.customDatabase = exports.DatasourcecustomDatabase.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.directives.push(exports.DirectiveConfiguration.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseDataSourceConfiguration,
        };
        message.rootNodes = [];
        message.childNodes = [];
        message.directives = [];
        if (object.kind !== undefined && object.kind !== null) {
            message.kind = dataSourceKindFromJSON(object.kind);
        }
        else {
            message.kind = 0;
        }
        if (object.rootNodes !== undefined && object.rootNodes !== null) {
            for (const e of object.rootNodes) {
                message.rootNodes.push(exports.TypeField.fromJSON(e));
            }
        }
        if (object.childNodes !== undefined && object.childNodes !== null) {
            for (const e of object.childNodes) {
                message.childNodes.push(exports.TypeField.fromJSON(e));
            }
        }
        if (object.overrideFieldPathFromAlias !== undefined &&
            object.overrideFieldPathFromAlias !== null) {
            message.overrideFieldPathFromAlias = Boolean(object.overrideFieldPathFromAlias);
        }
        else {
            message.overrideFieldPathFromAlias = false;
        }
        if (object.customRest !== undefined && object.customRest !== null) {
            message.customRest = exports.DatasourcecustomRest.fromJSON(object.customRest);
        }
        else {
            message.customRest = undefined;
        }
        if (object.customGraphql !== undefined && object.customGraphql !== null) {
            message.customGraphql = exports.DatasourcecustomGraphql.fromJSON(object.customGraphql);
        }
        else {
            message.customGraphql = undefined;
        }
        if (object.customStatic !== undefined && object.customStatic !== null) {
            message.customStatic = exports.DatasourcecustomStatic.fromJSON(object.customStatic);
        }
        else {
            message.customStatic = undefined;
        }
        if (object.customDatabase !== undefined && object.customDatabase !== null) {
            message.customDatabase = exports.DatasourcecustomDatabase.fromJSON(object.customDatabase);
        }
        else {
            message.customDatabase = undefined;
        }
        if (object.directives !== undefined && object.directives !== null) {
            for (const e of object.directives) {
                message.directives.push(exports.DirectiveConfiguration.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined &&
            (obj.kind = dataSourceKindToJSON(message.kind));
        if (message.rootNodes) {
            obj.rootNodes = message.rootNodes.map((e) => e ? exports.TypeField.toJSON(e) : undefined);
        }
        else {
            obj.rootNodes = [];
        }
        if (message.childNodes) {
            obj.childNodes = message.childNodes.map((e) => e ? exports.TypeField.toJSON(e) : undefined);
        }
        else {
            obj.childNodes = [];
        }
        message.overrideFieldPathFromAlias !== undefined &&
            (obj.overrideFieldPathFromAlias = message.overrideFieldPathFromAlias);
        message.customRest !== undefined &&
            (obj.customRest = message.customRest
                ? exports.DatasourcecustomRest.toJSON(message.customRest)
                : undefined);
        message.customGraphql !== undefined &&
            (obj.customGraphql = message.customGraphql
                ? exports.DatasourcecustomGraphql.toJSON(message.customGraphql)
                : undefined);
        message.customStatic !== undefined &&
            (obj.customStatic = message.customStatic
                ? exports.DatasourcecustomStatic.toJSON(message.customStatic)
                : undefined);
        message.customDatabase !== undefined &&
            (obj.customDatabase = message.customDatabase
                ? exports.DatasourcecustomDatabase.toJSON(message.customDatabase)
                : undefined);
        if (message.directives) {
            obj.directives = message.directives.map((e) => e ? exports.DirectiveConfiguration.toJSON(e) : undefined);
        }
        else {
            obj.directives = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseDataSourceConfiguration,
        };
        message.rootNodes = [];
        message.childNodes = [];
        message.directives = [];
        if (object.kind !== undefined && object.kind !== null) {
            message.kind = object.kind;
        }
        else {
            message.kind = 0;
        }
        if (object.rootNodes !== undefined && object.rootNodes !== null) {
            for (const e of object.rootNodes) {
                message.rootNodes.push(exports.TypeField.fromPartial(e));
            }
        }
        if (object.childNodes !== undefined && object.childNodes !== null) {
            for (const e of object.childNodes) {
                message.childNodes.push(exports.TypeField.fromPartial(e));
            }
        }
        if (object.overrideFieldPathFromAlias !== undefined &&
            object.overrideFieldPathFromAlias !== null) {
            message.overrideFieldPathFromAlias = object.overrideFieldPathFromAlias;
        }
        else {
            message.overrideFieldPathFromAlias = false;
        }
        if (object.customRest !== undefined && object.customRest !== null) {
            message.customRest = exports.DatasourcecustomRest.fromPartial(object.customRest);
        }
        else {
            message.customRest = undefined;
        }
        if (object.customGraphql !== undefined && object.customGraphql !== null) {
            message.customGraphql = exports.DatasourcecustomGraphql.fromPartial(object.customGraphql);
        }
        else {
            message.customGraphql = undefined;
        }
        if (object.customStatic !== undefined && object.customStatic !== null) {
            message.customStatic = exports.DatasourcecustomStatic.fromPartial(object.customStatic);
        }
        else {
            message.customStatic = undefined;
        }
        if (object.customDatabase !== undefined && object.customDatabase !== null) {
            message.customDatabase = exports.DatasourcecustomDatabase.fromPartial(object.customDatabase);
        }
        else {
            message.customDatabase = undefined;
        }
        if (object.directives !== undefined && object.directives !== null) {
            for (const e of object.directives) {
                message.directives.push(exports.DirectiveConfiguration.fromPartial(e));
            }
        }
        return message;
    },
};
const baseDirectiveConfiguration = { directiveName: "", renameTo: "" };
exports.DirectiveConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.directiveName !== "") {
            writer.uint32(10).string(message.directiveName);
        }
        if (message.renameTo !== "") {
            writer.uint32(18).string(message.renameTo);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseDirectiveConfiguration };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.directiveName = reader.string();
                    break;
                case 2:
                    message.renameTo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseDirectiveConfiguration };
        if (object.directiveName !== undefined && object.directiveName !== null) {
            message.directiveName = String(object.directiveName);
        }
        else {
            message.directiveName = "";
        }
        if (object.renameTo !== undefined && object.renameTo !== null) {
            message.renameTo = String(object.renameTo);
        }
        else {
            message.renameTo = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.directiveName !== undefined &&
            (obj.directiveName = message.directiveName);
        message.renameTo !== undefined && (obj.renameTo = message.renameTo);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseDirectiveConfiguration };
        if (object.directiveName !== undefined && object.directiveName !== null) {
            message.directiveName = object.directiveName;
        }
        else {
            message.directiveName = "";
        }
        if (object.renameTo !== undefined && object.renameTo !== null) {
            message.renameTo = object.renameTo;
        }
        else {
            message.renameTo = "";
        }
        return message;
    },
};
const baseDatasourcecustomRest = { defaultTypeName: "" };
exports.DatasourcecustomRest = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.fetch !== undefined) {
            exports.FetchConfiguration.encode(message.fetch, writer.uint32(10).fork()).ldelim();
        }
        if (message.subscription !== undefined) {
            exports.RESTSubscriptionConfiguration.encode(message.subscription, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.statusCodeTypeMappings) {
            exports.StatusCodeTypeMapping.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.defaultTypeName !== "") {
            writer.uint32(34).string(message.defaultTypeName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseDatasourcecustomRest };
        message.statusCodeTypeMappings = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.fetch = exports.FetchConfiguration.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.subscription = exports.RESTSubscriptionConfiguration.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.statusCodeTypeMappings.push(exports.StatusCodeTypeMapping.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.defaultTypeName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseDatasourcecustomRest };
        message.statusCodeTypeMappings = [];
        if (object.fetch !== undefined && object.fetch !== null) {
            message.fetch = exports.FetchConfiguration.fromJSON(object.fetch);
        }
        else {
            message.fetch = undefined;
        }
        if (object.subscription !== undefined && object.subscription !== null) {
            message.subscription = exports.RESTSubscriptionConfiguration.fromJSON(object.subscription);
        }
        else {
            message.subscription = undefined;
        }
        if (object.statusCodeTypeMappings !== undefined &&
            object.statusCodeTypeMappings !== null) {
            for (const e of object.statusCodeTypeMappings) {
                message.statusCodeTypeMappings.push(exports.StatusCodeTypeMapping.fromJSON(e));
            }
        }
        if (object.defaultTypeName !== undefined &&
            object.defaultTypeName !== null) {
            message.defaultTypeName = String(object.defaultTypeName);
        }
        else {
            message.defaultTypeName = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.fetch !== undefined &&
            (obj.fetch = message.fetch
                ? exports.FetchConfiguration.toJSON(message.fetch)
                : undefined);
        message.subscription !== undefined &&
            (obj.subscription = message.subscription
                ? exports.RESTSubscriptionConfiguration.toJSON(message.subscription)
                : undefined);
        if (message.statusCodeTypeMappings) {
            obj.statusCodeTypeMappings = message.statusCodeTypeMappings.map((e) => e ? exports.StatusCodeTypeMapping.toJSON(e) : undefined);
        }
        else {
            obj.statusCodeTypeMappings = [];
        }
        message.defaultTypeName !== undefined &&
            (obj.defaultTypeName = message.defaultTypeName);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseDatasourcecustomRest };
        message.statusCodeTypeMappings = [];
        if (object.fetch !== undefined && object.fetch !== null) {
            message.fetch = exports.FetchConfiguration.fromPartial(object.fetch);
        }
        else {
            message.fetch = undefined;
        }
        if (object.subscription !== undefined && object.subscription !== null) {
            message.subscription = exports.RESTSubscriptionConfiguration.fromPartial(object.subscription);
        }
        else {
            message.subscription = undefined;
        }
        if (object.statusCodeTypeMappings !== undefined &&
            object.statusCodeTypeMappings !== null) {
            for (const e of object.statusCodeTypeMappings) {
                message.statusCodeTypeMappings.push(exports.StatusCodeTypeMapping.fromPartial(e));
            }
        }
        if (object.defaultTypeName !== undefined &&
            object.defaultTypeName !== null) {
            message.defaultTypeName = object.defaultTypeName;
        }
        else {
            message.defaultTypeName = "";
        }
        return message;
    },
};
const baseStatusCodeTypeMapping = {
    statusCode: 0,
    typeName: "",
    injectStatusCodeIntoBody: false,
};
exports.StatusCodeTypeMapping = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.statusCode !== 0) {
            writer.uint32(8).int64(message.statusCode);
        }
        if (message.typeName !== "") {
            writer.uint32(18).string(message.typeName);
        }
        if (message.injectStatusCodeIntoBody === true) {
            writer.uint32(24).bool(message.injectStatusCodeIntoBody);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseStatusCodeTypeMapping };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.statusCode = longToNumber(reader.int64());
                    break;
                case 2:
                    message.typeName = reader.string();
                    break;
                case 3:
                    message.injectStatusCodeIntoBody = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseStatusCodeTypeMapping };
        if (object.statusCode !== undefined && object.statusCode !== null) {
            message.statusCode = Number(object.statusCode);
        }
        else {
            message.statusCode = 0;
        }
        if (object.typeName !== undefined && object.typeName !== null) {
            message.typeName = String(object.typeName);
        }
        else {
            message.typeName = "";
        }
        if (object.injectStatusCodeIntoBody !== undefined &&
            object.injectStatusCodeIntoBody !== null) {
            message.injectStatusCodeIntoBody = Boolean(object.injectStatusCodeIntoBody);
        }
        else {
            message.injectStatusCodeIntoBody = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.statusCode !== undefined && (obj.statusCode = message.statusCode);
        message.typeName !== undefined && (obj.typeName = message.typeName);
        message.injectStatusCodeIntoBody !== undefined &&
            (obj.injectStatusCodeIntoBody = message.injectStatusCodeIntoBody);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseStatusCodeTypeMapping };
        if (object.statusCode !== undefined && object.statusCode !== null) {
            message.statusCode = object.statusCode;
        }
        else {
            message.statusCode = 0;
        }
        if (object.typeName !== undefined && object.typeName !== null) {
            message.typeName = object.typeName;
        }
        else {
            message.typeName = "";
        }
        if (object.injectStatusCodeIntoBody !== undefined &&
            object.injectStatusCodeIntoBody !== null) {
            message.injectStatusCodeIntoBody = object.injectStatusCodeIntoBody;
        }
        else {
            message.injectStatusCodeIntoBody = false;
        }
        return message;
    },
};
const baseDatasourcecustomGraphql = { upstreamSchema: "" };
exports.DatasourcecustomGraphql = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.fetch !== undefined) {
            exports.FetchConfiguration.encode(message.fetch, writer.uint32(10).fork()).ldelim();
        }
        if (message.subscription !== undefined) {
            exports.GraphQLSubscriptionConfiguration.encode(message.subscription, writer.uint32(18).fork()).ldelim();
        }
        if (message.federation !== undefined) {
            exports.GraphQLFederationConfiguration.encode(message.federation, writer.uint32(26).fork()).ldelim();
        }
        if (message.upstreamSchema !== "") {
            writer.uint32(34).string(message.upstreamSchema);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseDatasourcecustomGraphql,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.fetch = exports.FetchConfiguration.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.subscription = exports.GraphQLSubscriptionConfiguration.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.federation = exports.GraphQLFederationConfiguration.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.upstreamSchema = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseDatasourcecustomGraphql,
        };
        if (object.fetch !== undefined && object.fetch !== null) {
            message.fetch = exports.FetchConfiguration.fromJSON(object.fetch);
        }
        else {
            message.fetch = undefined;
        }
        if (object.subscription !== undefined && object.subscription !== null) {
            message.subscription = exports.GraphQLSubscriptionConfiguration.fromJSON(object.subscription);
        }
        else {
            message.subscription = undefined;
        }
        if (object.federation !== undefined && object.federation !== null) {
            message.federation = exports.GraphQLFederationConfiguration.fromJSON(object.federation);
        }
        else {
            message.federation = undefined;
        }
        if (object.upstreamSchema !== undefined && object.upstreamSchema !== null) {
            message.upstreamSchema = String(object.upstreamSchema);
        }
        else {
            message.upstreamSchema = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.fetch !== undefined &&
            (obj.fetch = message.fetch
                ? exports.FetchConfiguration.toJSON(message.fetch)
                : undefined);
        message.subscription !== undefined &&
            (obj.subscription = message.subscription
                ? exports.GraphQLSubscriptionConfiguration.toJSON(message.subscription)
                : undefined);
        message.federation !== undefined &&
            (obj.federation = message.federation
                ? exports.GraphQLFederationConfiguration.toJSON(message.federation)
                : undefined);
        message.upstreamSchema !== undefined &&
            (obj.upstreamSchema = message.upstreamSchema);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseDatasourcecustomGraphql,
        };
        if (object.fetch !== undefined && object.fetch !== null) {
            message.fetch = exports.FetchConfiguration.fromPartial(object.fetch);
        }
        else {
            message.fetch = undefined;
        }
        if (object.subscription !== undefined && object.subscription !== null) {
            message.subscription = exports.GraphQLSubscriptionConfiguration.fromPartial(object.subscription);
        }
        else {
            message.subscription = undefined;
        }
        if (object.federation !== undefined && object.federation !== null) {
            message.federation = exports.GraphQLFederationConfiguration.fromPartial(object.federation);
        }
        else {
            message.federation = undefined;
        }
        if (object.upstreamSchema !== undefined && object.upstreamSchema !== null) {
            message.upstreamSchema = object.upstreamSchema;
        }
        else {
            message.upstreamSchema = "";
        }
        return message;
    },
};
const baseDatasourcecustomDatabase = {
    prismaSchema: "",
    graphqlSchema: "",
    closeTimeoutSeconds: 0,
};
exports.DatasourcecustomDatabase = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.databaseURL !== undefined) {
            exports.ConfigurationVariable.encode(message.databaseURL, writer.uint32(10).fork()).ldelim();
        }
        if (message.prismaSchema !== "") {
            writer.uint32(18).string(message.prismaSchema);
        }
        if (message.graphqlSchema !== "") {
            writer.uint32(26).string(message.graphqlSchema);
        }
        if (message.closeTimeoutSeconds !== 0) {
            writer.uint32(32).int64(message.closeTimeoutSeconds);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseDatasourcecustomDatabase,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.databaseURL = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.prismaSchema = reader.string();
                    break;
                case 3:
                    message.graphqlSchema = reader.string();
                    break;
                case 4:
                    message.closeTimeoutSeconds = longToNumber(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseDatasourcecustomDatabase,
        };
        if (object.databaseURL !== undefined && object.databaseURL !== null) {
            message.databaseURL = exports.ConfigurationVariable.fromJSON(object.databaseURL);
        }
        else {
            message.databaseURL = undefined;
        }
        if (object.prismaSchema !== undefined && object.prismaSchema !== null) {
            message.prismaSchema = String(object.prismaSchema);
        }
        else {
            message.prismaSchema = "";
        }
        if (object.graphqlSchema !== undefined && object.graphqlSchema !== null) {
            message.graphqlSchema = String(object.graphqlSchema);
        }
        else {
            message.graphqlSchema = "";
        }
        if (object.closeTimeoutSeconds !== undefined &&
            object.closeTimeoutSeconds !== null) {
            message.closeTimeoutSeconds = Number(object.closeTimeoutSeconds);
        }
        else {
            message.closeTimeoutSeconds = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.databaseURL !== undefined &&
            (obj.databaseURL = message.databaseURL
                ? exports.ConfigurationVariable.toJSON(message.databaseURL)
                : undefined);
        message.prismaSchema !== undefined &&
            (obj.prismaSchema = message.prismaSchema);
        message.graphqlSchema !== undefined &&
            (obj.graphqlSchema = message.graphqlSchema);
        message.closeTimeoutSeconds !== undefined &&
            (obj.closeTimeoutSeconds = message.closeTimeoutSeconds);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseDatasourcecustomDatabase,
        };
        if (object.databaseURL !== undefined && object.databaseURL !== null) {
            message.databaseURL = exports.ConfigurationVariable.fromPartial(object.databaseURL);
        }
        else {
            message.databaseURL = undefined;
        }
        if (object.prismaSchema !== undefined && object.prismaSchema !== null) {
            message.prismaSchema = object.prismaSchema;
        }
        else {
            message.prismaSchema = "";
        }
        if (object.graphqlSchema !== undefined && object.graphqlSchema !== null) {
            message.graphqlSchema = object.graphqlSchema;
        }
        else {
            message.graphqlSchema = "";
        }
        if (object.closeTimeoutSeconds !== undefined &&
            object.closeTimeoutSeconds !== null) {
            message.closeTimeoutSeconds = object.closeTimeoutSeconds;
        }
        else {
            message.closeTimeoutSeconds = 0;
        }
        return message;
    },
};
const baseGraphQLFederationConfiguration = {
    enabled: false,
    serviceSdl: "",
};
exports.GraphQLFederationConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.enabled === true) {
            writer.uint32(8).bool(message.enabled);
        }
        if (message.serviceSdl !== "") {
            writer.uint32(18).string(message.serviceSdl);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseGraphQLFederationConfiguration,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.enabled = reader.bool();
                    break;
                case 2:
                    message.serviceSdl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseGraphQLFederationConfiguration,
        };
        if (object.enabled !== undefined && object.enabled !== null) {
            message.enabled = Boolean(object.enabled);
        }
        else {
            message.enabled = false;
        }
        if (object.serviceSdl !== undefined && object.serviceSdl !== null) {
            message.serviceSdl = String(object.serviceSdl);
        }
        else {
            message.serviceSdl = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.enabled !== undefined && (obj.enabled = message.enabled);
        message.serviceSdl !== undefined && (obj.serviceSdl = message.serviceSdl);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseGraphQLFederationConfiguration,
        };
        if (object.enabled !== undefined && object.enabled !== null) {
            message.enabled = object.enabled;
        }
        else {
            message.enabled = false;
        }
        if (object.serviceSdl !== undefined && object.serviceSdl !== null) {
            message.serviceSdl = object.serviceSdl;
        }
        else {
            message.serviceSdl = "";
        }
        return message;
    },
};
const baseDatasourcecustomStatic = {};
exports.DatasourcecustomStatic = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.data !== undefined) {
            exports.ConfigurationVariable.encode(message.data, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseDatasourcecustomStatic };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseDatasourcecustomStatic };
        if (object.data !== undefined && object.data !== null) {
            message.data = exports.ConfigurationVariable.fromJSON(object.data);
        }
        else {
            message.data = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.data !== undefined &&
            (obj.data = message.data
                ? exports.ConfigurationVariable.toJSON(message.data)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseDatasourcecustomStatic };
        if (object.data !== undefined && object.data !== null) {
            message.data = exports.ConfigurationVariable.fromPartial(object.data);
        }
        else {
            message.data = undefined;
        }
        return message;
    },
};
const baseGraphQLSubscriptionConfiguration = { enabled: false };
exports.GraphQLSubscriptionConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.enabled === true) {
            writer.uint32(8).bool(message.enabled);
        }
        if (message.url !== undefined) {
            exports.ConfigurationVariable.encode(message.url, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseGraphQLSubscriptionConfiguration,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.enabled = reader.bool();
                    break;
                case 2:
                    message.url = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseGraphQLSubscriptionConfiguration,
        };
        if (object.enabled !== undefined && object.enabled !== null) {
            message.enabled = Boolean(object.enabled);
        }
        else {
            message.enabled = false;
        }
        if (object.url !== undefined && object.url !== null) {
            message.url = exports.ConfigurationVariable.fromJSON(object.url);
        }
        else {
            message.url = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.enabled !== undefined && (obj.enabled = message.enabled);
        message.url !== undefined &&
            (obj.url = message.url
                ? exports.ConfigurationVariable.toJSON(message.url)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseGraphQLSubscriptionConfiguration,
        };
        if (object.enabled !== undefined && object.enabled !== null) {
            message.enabled = object.enabled;
        }
        else {
            message.enabled = false;
        }
        if (object.url !== undefined && object.url !== null) {
            message.url = exports.ConfigurationVariable.fromPartial(object.url);
        }
        else {
            message.url = undefined;
        }
        return message;
    },
};
const baseFetchConfiguration = { method: 0 };
exports.FetchConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.url !== undefined) {
            exports.ConfigurationVariable.encode(message.url, writer.uint32(10).fork()).ldelim();
        }
        if (message.method !== 0) {
            writer.uint32(16).int32(message.method);
        }
        Object.entries(message.header).forEach(([key, value]) => {
            exports.FetchConfiguration_HeaderEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        if (message.body !== undefined) {
            exports.ConfigurationVariable.encode(message.body, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.query) {
            exports.URLQueryConfiguration.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (message.upstreamAuthentication !== undefined) {
            exports.UpstreamAuthentication.encode(message.upstreamAuthentication, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseFetchConfiguration };
        message.header = {};
        message.query = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.url = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.method = reader.int32();
                    break;
                case 3:
                    const entry3 = exports.FetchConfiguration_HeaderEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.header[entry3.key] = entry3.value;
                    }
                    break;
                case 4:
                    message.body = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.query.push(exports.URLQueryConfiguration.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.upstreamAuthentication = exports.UpstreamAuthentication.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseFetchConfiguration };
        message.header = {};
        message.query = [];
        if (object.url !== undefined && object.url !== null) {
            message.url = exports.ConfigurationVariable.fromJSON(object.url);
        }
        else {
            message.url = undefined;
        }
        if (object.method !== undefined && object.method !== null) {
            message.method = hTTPMethodFromJSON(object.method);
        }
        else {
            message.method = 0;
        }
        if (object.header !== undefined && object.header !== null) {
            Object.entries(object.header).forEach(([key, value]) => {
                message.header[key] = exports.HTTPHeader.fromJSON(value);
            });
        }
        if (object.body !== undefined && object.body !== null) {
            message.body = exports.ConfigurationVariable.fromJSON(object.body);
        }
        else {
            message.body = undefined;
        }
        if (object.query !== undefined && object.query !== null) {
            for (const e of object.query) {
                message.query.push(exports.URLQueryConfiguration.fromJSON(e));
            }
        }
        if (object.upstreamAuthentication !== undefined &&
            object.upstreamAuthentication !== null) {
            message.upstreamAuthentication = exports.UpstreamAuthentication.fromJSON(object.upstreamAuthentication);
        }
        else {
            message.upstreamAuthentication = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.url !== undefined &&
            (obj.url = message.url
                ? exports.ConfigurationVariable.toJSON(message.url)
                : undefined);
        message.method !== undefined &&
            (obj.method = hTTPMethodToJSON(message.method));
        obj.header = {};
        if (message.header) {
            Object.entries(message.header).forEach(([k, v]) => {
                obj.header[k] = exports.HTTPHeader.toJSON(v);
            });
        }
        message.body !== undefined &&
            (obj.body = message.body
                ? exports.ConfigurationVariable.toJSON(message.body)
                : undefined);
        if (message.query) {
            obj.query = message.query.map((e) => e ? exports.URLQueryConfiguration.toJSON(e) : undefined);
        }
        else {
            obj.query = [];
        }
        message.upstreamAuthentication !== undefined &&
            (obj.upstreamAuthentication = message.upstreamAuthentication
                ? exports.UpstreamAuthentication.toJSON(message.upstreamAuthentication)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseFetchConfiguration };
        message.header = {};
        message.query = [];
        if (object.url !== undefined && object.url !== null) {
            message.url = exports.ConfigurationVariable.fromPartial(object.url);
        }
        else {
            message.url = undefined;
        }
        if (object.method !== undefined && object.method !== null) {
            message.method = object.method;
        }
        else {
            message.method = 0;
        }
        if (object.header !== undefined && object.header !== null) {
            Object.entries(object.header).forEach(([key, value]) => {
                if (value !== undefined) {
                    message.header[key] = exports.HTTPHeader.fromPartial(value);
                }
            });
        }
        if (object.body !== undefined && object.body !== null) {
            message.body = exports.ConfigurationVariable.fromPartial(object.body);
        }
        else {
            message.body = undefined;
        }
        if (object.query !== undefined && object.query !== null) {
            for (const e of object.query) {
                message.query.push(exports.URLQueryConfiguration.fromPartial(e));
            }
        }
        if (object.upstreamAuthentication !== undefined &&
            object.upstreamAuthentication !== null) {
            message.upstreamAuthentication = exports.UpstreamAuthentication.fromPartial(object.upstreamAuthentication);
        }
        else {
            message.upstreamAuthentication = undefined;
        }
        return message;
    },
};
const baseFetchConfiguration_HeaderEntry = { key: "" };
exports.FetchConfiguration_HeaderEntry = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.HTTPHeader.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseFetchConfiguration_HeaderEntry,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.HTTPHeader.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseFetchConfiguration_HeaderEntry,
        };
        if (object.key !== undefined && object.key !== null) {
            message.key = String(object.key);
        }
        else {
            message.key = "";
        }
        if (object.value !== undefined && object.value !== null) {
            message.value = exports.HTTPHeader.fromJSON(object.value);
        }
        else {
            message.value = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined &&
            (obj.value = message.value
                ? exports.HTTPHeader.toJSON(message.value)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseFetchConfiguration_HeaderEntry,
        };
        if (object.key !== undefined && object.key !== null) {
            message.key = object.key;
        }
        else {
            message.key = "";
        }
        if (object.value !== undefined && object.value !== null) {
            message.value = exports.HTTPHeader.fromPartial(object.value);
        }
        else {
            message.value = undefined;
        }
        return message;
    },
};
const baseUpstreamAuthentication = { kind: 0 };
exports.UpstreamAuthentication = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.kind !== 0) {
            writer.uint32(8).int32(message.kind);
        }
        if (message.jwtConfig !== undefined) {
            exports.JwtUpstreamAuthenticationConfig.encode(message.jwtConfig, writer.uint32(18).fork()).ldelim();
        }
        if (message.jwtWithAccessTokenExchangeConfig !== undefined) {
            exports.JwtUpstreamAuthenticationWithAccessTokenExchange.encode(message.jwtWithAccessTokenExchangeConfig, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseUpstreamAuthentication };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.int32();
                    break;
                case 2:
                    message.jwtConfig = exports.JwtUpstreamAuthenticationConfig.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.jwtWithAccessTokenExchangeConfig =
                        exports.JwtUpstreamAuthenticationWithAccessTokenExchange.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseUpstreamAuthentication };
        if (object.kind !== undefined && object.kind !== null) {
            message.kind = upstreamAuthenticationKindFromJSON(object.kind);
        }
        else {
            message.kind = 0;
        }
        if (object.jwtConfig !== undefined && object.jwtConfig !== null) {
            message.jwtConfig = exports.JwtUpstreamAuthenticationConfig.fromJSON(object.jwtConfig);
        }
        else {
            message.jwtConfig = undefined;
        }
        if (object.jwtWithAccessTokenExchangeConfig !== undefined &&
            object.jwtWithAccessTokenExchangeConfig !== null) {
            message.jwtWithAccessTokenExchangeConfig =
                exports.JwtUpstreamAuthenticationWithAccessTokenExchange.fromJSON(object.jwtWithAccessTokenExchangeConfig);
        }
        else {
            message.jwtWithAccessTokenExchangeConfig = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined &&
            (obj.kind = upstreamAuthenticationKindToJSON(message.kind));
        message.jwtConfig !== undefined &&
            (obj.jwtConfig = message.jwtConfig
                ? exports.JwtUpstreamAuthenticationConfig.toJSON(message.jwtConfig)
                : undefined);
        message.jwtWithAccessTokenExchangeConfig !== undefined &&
            (obj.jwtWithAccessTokenExchangeConfig =
                message.jwtWithAccessTokenExchangeConfig
                    ? exports.JwtUpstreamAuthenticationWithAccessTokenExchange.toJSON(message.jwtWithAccessTokenExchangeConfig)
                    : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseUpstreamAuthentication };
        if (object.kind !== undefined && object.kind !== null) {
            message.kind = object.kind;
        }
        else {
            message.kind = 0;
        }
        if (object.jwtConfig !== undefined && object.jwtConfig !== null) {
            message.jwtConfig = exports.JwtUpstreamAuthenticationConfig.fromPartial(object.jwtConfig);
        }
        else {
            message.jwtConfig = undefined;
        }
        if (object.jwtWithAccessTokenExchangeConfig !== undefined &&
            object.jwtWithAccessTokenExchangeConfig !== null) {
            message.jwtWithAccessTokenExchangeConfig =
                exports.JwtUpstreamAuthenticationWithAccessTokenExchange.fromPartial(object.jwtWithAccessTokenExchangeConfig);
        }
        else {
            message.jwtWithAccessTokenExchangeConfig = undefined;
        }
        return message;
    },
};
const baseJwtUpstreamAuthenticationConfig = { signingMethod: 0 };
exports.JwtUpstreamAuthenticationConfig = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.secret !== undefined) {
            exports.ConfigurationVariable.encode(message.secret, writer.uint32(10).fork()).ldelim();
        }
        if (message.signingMethod !== 0) {
            writer.uint32(16).int32(message.signingMethod);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseJwtUpstreamAuthenticationConfig,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.secret = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.signingMethod = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseJwtUpstreamAuthenticationConfig,
        };
        if (object.secret !== undefined && object.secret !== null) {
            message.secret = exports.ConfigurationVariable.fromJSON(object.secret);
        }
        else {
            message.secret = undefined;
        }
        if (object.signingMethod !== undefined && object.signingMethod !== null) {
            message.signingMethod = signingMethodFromJSON(object.signingMethod);
        }
        else {
            message.signingMethod = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.secret !== undefined &&
            (obj.secret = message.secret
                ? exports.ConfigurationVariable.toJSON(message.secret)
                : undefined);
        message.signingMethod !== undefined &&
            (obj.signingMethod = signingMethodToJSON(message.signingMethod));
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseJwtUpstreamAuthenticationConfig,
        };
        if (object.secret !== undefined && object.secret !== null) {
            message.secret = exports.ConfigurationVariable.fromPartial(object.secret);
        }
        else {
            message.secret = undefined;
        }
        if (object.signingMethod !== undefined && object.signingMethod !== null) {
            message.signingMethod = object.signingMethod;
        }
        else {
            message.signingMethod = 0;
        }
        return message;
    },
};
const baseJwtUpstreamAuthenticationWithAccessTokenExchange = {
    signingMethod: 0,
};
exports.JwtUpstreamAuthenticationWithAccessTokenExchange = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.secret !== undefined) {
            exports.ConfigurationVariable.encode(message.secret, writer.uint32(10).fork()).ldelim();
        }
        if (message.signingMethod !== 0) {
            writer.uint32(16).int32(message.signingMethod);
        }
        if (message.accessTokenExchangeEndpoint !== undefined) {
            exports.ConfigurationVariable.encode(message.accessTokenExchangeEndpoint, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseJwtUpstreamAuthenticationWithAccessTokenExchange,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.secret = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.signingMethod = reader.int32();
                    break;
                case 3:
                    message.accessTokenExchangeEndpoint = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseJwtUpstreamAuthenticationWithAccessTokenExchange,
        };
        if (object.secret !== undefined && object.secret !== null) {
            message.secret = exports.ConfigurationVariable.fromJSON(object.secret);
        }
        else {
            message.secret = undefined;
        }
        if (object.signingMethod !== undefined && object.signingMethod !== null) {
            message.signingMethod = signingMethodFromJSON(object.signingMethod);
        }
        else {
            message.signingMethod = 0;
        }
        if (object.accessTokenExchangeEndpoint !== undefined &&
            object.accessTokenExchangeEndpoint !== null) {
            message.accessTokenExchangeEndpoint = exports.ConfigurationVariable.fromJSON(object.accessTokenExchangeEndpoint);
        }
        else {
            message.accessTokenExchangeEndpoint = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.secret !== undefined &&
            (obj.secret = message.secret
                ? exports.ConfigurationVariable.toJSON(message.secret)
                : undefined);
        message.signingMethod !== undefined &&
            (obj.signingMethod = signingMethodToJSON(message.signingMethod));
        message.accessTokenExchangeEndpoint !== undefined &&
            (obj.accessTokenExchangeEndpoint = message.accessTokenExchangeEndpoint
                ? exports.ConfigurationVariable.toJSON(message.accessTokenExchangeEndpoint)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseJwtUpstreamAuthenticationWithAccessTokenExchange,
        };
        if (object.secret !== undefined && object.secret !== null) {
            message.secret = exports.ConfigurationVariable.fromPartial(object.secret);
        }
        else {
            message.secret = undefined;
        }
        if (object.signingMethod !== undefined && object.signingMethod !== null) {
            message.signingMethod = object.signingMethod;
        }
        else {
            message.signingMethod = 0;
        }
        if (object.accessTokenExchangeEndpoint !== undefined &&
            object.accessTokenExchangeEndpoint !== null) {
            message.accessTokenExchangeEndpoint = exports.ConfigurationVariable.fromPartial(object.accessTokenExchangeEndpoint);
        }
        else {
            message.accessTokenExchangeEndpoint = undefined;
        }
        return message;
    },
};
const baseRESTSubscriptionConfiguration = {
    enabled: false,
    pollingIntervalMillis: 0,
    skipPublishSameResponse: false,
};
exports.RESTSubscriptionConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.enabled === true) {
            writer.uint32(8).bool(message.enabled);
        }
        if (message.pollingIntervalMillis !== 0) {
            writer.uint32(16).int64(message.pollingIntervalMillis);
        }
        if (message.skipPublishSameResponse === true) {
            writer.uint32(24).bool(message.skipPublishSameResponse);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseRESTSubscriptionConfiguration,
        };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.enabled = reader.bool();
                    break;
                case 2:
                    message.pollingIntervalMillis = longToNumber(reader.int64());
                    break;
                case 3:
                    message.skipPublishSameResponse = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseRESTSubscriptionConfiguration,
        };
        if (object.enabled !== undefined && object.enabled !== null) {
            message.enabled = Boolean(object.enabled);
        }
        else {
            message.enabled = false;
        }
        if (object.pollingIntervalMillis !== undefined &&
            object.pollingIntervalMillis !== null) {
            message.pollingIntervalMillis = Number(object.pollingIntervalMillis);
        }
        else {
            message.pollingIntervalMillis = 0;
        }
        if (object.skipPublishSameResponse !== undefined &&
            object.skipPublishSameResponse !== null) {
            message.skipPublishSameResponse = Boolean(object.skipPublishSameResponse);
        }
        else {
            message.skipPublishSameResponse = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.enabled !== undefined && (obj.enabled = message.enabled);
        message.pollingIntervalMillis !== undefined &&
            (obj.pollingIntervalMillis = message.pollingIntervalMillis);
        message.skipPublishSameResponse !== undefined &&
            (obj.skipPublishSameResponse = message.skipPublishSameResponse);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseRESTSubscriptionConfiguration,
        };
        if (object.enabled !== undefined && object.enabled !== null) {
            message.enabled = object.enabled;
        }
        else {
            message.enabled = false;
        }
        if (object.pollingIntervalMillis !== undefined &&
            object.pollingIntervalMillis !== null) {
            message.pollingIntervalMillis = object.pollingIntervalMillis;
        }
        else {
            message.pollingIntervalMillis = 0;
        }
        if (object.skipPublishSameResponse !== undefined &&
            object.skipPublishSameResponse !== null) {
            message.skipPublishSameResponse = object.skipPublishSameResponse;
        }
        else {
            message.skipPublishSameResponse = false;
        }
        return message;
    },
};
const baseURLQueryConfiguration = { name: "", value: "" };
exports.URLQueryConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseURLQueryConfiguration };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseURLQueryConfiguration };
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        }
        else {
            message.name = "";
        }
        if (object.value !== undefined && object.value !== null) {
            message.value = String(object.value);
        }
        else {
            message.value = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseURLQueryConfiguration };
        if (object.name !== undefined && object.name !== null) {
            message.name = object.name;
        }
        else {
            message.name = "";
        }
        if (object.value !== undefined && object.value !== null) {
            message.value = object.value;
        }
        else {
            message.value = "";
        }
        return message;
    },
};
const baseHTTPHeader = {};
exports.HTTPHeader = {
    encode(message, writer = minimal_1.Writer.create()) {
        for (const v of message.values) {
            exports.ConfigurationVariable.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseHTTPHeader };
        message.values = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.values.push(exports.ConfigurationVariable.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseHTTPHeader };
        message.values = [];
        if (object.values !== undefined && object.values !== null) {
            for (const e of object.values) {
                message.values.push(exports.ConfigurationVariable.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.values) {
            obj.values = message.values.map((e) => e ? exports.ConfigurationVariable.toJSON(e) : undefined);
        }
        else {
            obj.values = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseHTTPHeader };
        message.values = [];
        if (object.values !== undefined && object.values !== null) {
            for (const e of object.values) {
                message.values.push(exports.ConfigurationVariable.fromPartial(e));
            }
        }
        return message;
    },
};
const baseTypeConfiguration = { typeName: "", renameTo: "" };
exports.TypeConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.typeName !== "") {
            writer.uint32(10).string(message.typeName);
        }
        if (message.renameTo !== "") {
            writer.uint32(18).string(message.renameTo);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseTypeConfiguration };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.typeName = reader.string();
                    break;
                case 2:
                    message.renameTo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseTypeConfiguration };
        if (object.typeName !== undefined && object.typeName !== null) {
            message.typeName = String(object.typeName);
        }
        else {
            message.typeName = "";
        }
        if (object.renameTo !== undefined && object.renameTo !== null) {
            message.renameTo = String(object.renameTo);
        }
        else {
            message.renameTo = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.typeName !== undefined && (obj.typeName = message.typeName);
        message.renameTo !== undefined && (obj.renameTo = message.renameTo);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseTypeConfiguration };
        if (object.typeName !== undefined && object.typeName !== null) {
            message.typeName = object.typeName;
        }
        else {
            message.typeName = "";
        }
        if (object.renameTo !== undefined && object.renameTo !== null) {
            message.renameTo = object.renameTo;
        }
        else {
            message.renameTo = "";
        }
        return message;
    },
};
const baseFieldConfiguration = {
    typeName: "",
    fieldName: "",
    disableDefaultFieldMapping: false,
    path: "",
    requiresFields: "",
};
exports.FieldConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.typeName !== "") {
            writer.uint32(10).string(message.typeName);
        }
        if (message.fieldName !== "") {
            writer.uint32(18).string(message.fieldName);
        }
        if (message.disableDefaultFieldMapping === true) {
            writer.uint32(24).bool(message.disableDefaultFieldMapping);
        }
        for (const v of message.path) {
            writer.uint32(34).string(v);
        }
        for (const v of message.argumentsConfiguration) {
            exports.ArgumentConfiguration.encode(v, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.requiresFields) {
            writer.uint32(58).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseFieldConfiguration };
        message.path = [];
        message.argumentsConfiguration = [];
        message.requiresFields = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.typeName = reader.string();
                    break;
                case 2:
                    message.fieldName = reader.string();
                    break;
                case 3:
                    message.disableDefaultFieldMapping = reader.bool();
                    break;
                case 4:
                    message.path.push(reader.string());
                    break;
                case 6:
                    message.argumentsConfiguration.push(exports.ArgumentConfiguration.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.requiresFields.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseFieldConfiguration };
        message.path = [];
        message.argumentsConfiguration = [];
        message.requiresFields = [];
        if (object.typeName !== undefined && object.typeName !== null) {
            message.typeName = String(object.typeName);
        }
        else {
            message.typeName = "";
        }
        if (object.fieldName !== undefined && object.fieldName !== null) {
            message.fieldName = String(object.fieldName);
        }
        else {
            message.fieldName = "";
        }
        if (object.disableDefaultFieldMapping !== undefined &&
            object.disableDefaultFieldMapping !== null) {
            message.disableDefaultFieldMapping = Boolean(object.disableDefaultFieldMapping);
        }
        else {
            message.disableDefaultFieldMapping = false;
        }
        if (object.path !== undefined && object.path !== null) {
            for (const e of object.path) {
                message.path.push(String(e));
            }
        }
        if (object.argumentsConfiguration !== undefined &&
            object.argumentsConfiguration !== null) {
            for (const e of object.argumentsConfiguration) {
                message.argumentsConfiguration.push(exports.ArgumentConfiguration.fromJSON(e));
            }
        }
        if (object.requiresFields !== undefined && object.requiresFields !== null) {
            for (const e of object.requiresFields) {
                message.requiresFields.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.typeName !== undefined && (obj.typeName = message.typeName);
        message.fieldName !== undefined && (obj.fieldName = message.fieldName);
        message.disableDefaultFieldMapping !== undefined &&
            (obj.disableDefaultFieldMapping = message.disableDefaultFieldMapping);
        if (message.path) {
            obj.path = message.path.map((e) => e);
        }
        else {
            obj.path = [];
        }
        if (message.argumentsConfiguration) {
            obj.argumentsConfiguration = message.argumentsConfiguration.map((e) => e ? exports.ArgumentConfiguration.toJSON(e) : undefined);
        }
        else {
            obj.argumentsConfiguration = [];
        }
        if (message.requiresFields) {
            obj.requiresFields = message.requiresFields.map((e) => e);
        }
        else {
            obj.requiresFields = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseFieldConfiguration };
        message.path = [];
        message.argumentsConfiguration = [];
        message.requiresFields = [];
        if (object.typeName !== undefined && object.typeName !== null) {
            message.typeName = object.typeName;
        }
        else {
            message.typeName = "";
        }
        if (object.fieldName !== undefined && object.fieldName !== null) {
            message.fieldName = object.fieldName;
        }
        else {
            message.fieldName = "";
        }
        if (object.disableDefaultFieldMapping !== undefined &&
            object.disableDefaultFieldMapping !== null) {
            message.disableDefaultFieldMapping = object.disableDefaultFieldMapping;
        }
        else {
            message.disableDefaultFieldMapping = false;
        }
        if (object.path !== undefined && object.path !== null) {
            for (const e of object.path) {
                message.path.push(e);
            }
        }
        if (object.argumentsConfiguration !== undefined &&
            object.argumentsConfiguration !== null) {
            for (const e of object.argumentsConfiguration) {
                message.argumentsConfiguration.push(exports.ArgumentConfiguration.fromPartial(e));
            }
        }
        if (object.requiresFields !== undefined && object.requiresFields !== null) {
            for (const e of object.requiresFields) {
                message.requiresFields.push(e);
            }
        }
        return message;
    },
};
const baseTypeField = { typeName: "", fieldNames: "" };
exports.TypeField = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.typeName !== "") {
            writer.uint32(10).string(message.typeName);
        }
        for (const v of message.fieldNames) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseTypeField };
        message.fieldNames = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.typeName = reader.string();
                    break;
                case 2:
                    message.fieldNames.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseTypeField };
        message.fieldNames = [];
        if (object.typeName !== undefined && object.typeName !== null) {
            message.typeName = String(object.typeName);
        }
        else {
            message.typeName = "";
        }
        if (object.fieldNames !== undefined && object.fieldNames !== null) {
            for (const e of object.fieldNames) {
                message.fieldNames.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.typeName !== undefined && (obj.typeName = message.typeName);
        if (message.fieldNames) {
            obj.fieldNames = message.fieldNames.map((e) => e);
        }
        else {
            obj.fieldNames = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseTypeField };
        message.fieldNames = [];
        if (object.typeName !== undefined && object.typeName !== null) {
            message.typeName = object.typeName;
        }
        else {
            message.typeName = "";
        }
        if (object.fieldNames !== undefined && object.fieldNames !== null) {
            for (const e of object.fieldNames) {
                message.fieldNames.push(e);
            }
        }
        return message;
    },
};
const baseArgumentConfiguration = {
    name: "",
    sourceType: 0,
    sourcePath: "",
    renderConfiguration: 0,
};
exports.ArgumentConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.sourceType !== 0) {
            writer.uint32(16).int32(message.sourceType);
        }
        for (const v of message.sourcePath) {
            writer.uint32(26).string(v);
        }
        if (message.renderConfiguration !== 0) {
            writer.uint32(32).int32(message.renderConfiguration);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseArgumentConfiguration };
        message.sourcePath = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.sourceType = reader.int32();
                    break;
                case 3:
                    message.sourcePath.push(reader.string());
                    break;
                case 4:
                    message.renderConfiguration = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseArgumentConfiguration };
        message.sourcePath = [];
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        }
        else {
            message.name = "";
        }
        if (object.sourceType !== undefined && object.sourceType !== null) {
            message.sourceType = argumentSourceFromJSON(object.sourceType);
        }
        else {
            message.sourceType = 0;
        }
        if (object.sourcePath !== undefined && object.sourcePath !== null) {
            for (const e of object.sourcePath) {
                message.sourcePath.push(String(e));
            }
        }
        if (object.renderConfiguration !== undefined &&
            object.renderConfiguration !== null) {
            message.renderConfiguration = argumentRenderConfigurationFromJSON(object.renderConfiguration);
        }
        else {
            message.renderConfiguration = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.sourceType !== undefined &&
            (obj.sourceType = argumentSourceToJSON(message.sourceType));
        if (message.sourcePath) {
            obj.sourcePath = message.sourcePath.map((e) => e);
        }
        else {
            obj.sourcePath = [];
        }
        message.renderConfiguration !== undefined &&
            (obj.renderConfiguration = argumentRenderConfigurationToJSON(message.renderConfiguration));
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseArgumentConfiguration };
        message.sourcePath = [];
        if (object.name !== undefined && object.name !== null) {
            message.name = object.name;
        }
        else {
            message.name = "";
        }
        if (object.sourceType !== undefined && object.sourceType !== null) {
            message.sourceType = object.sourceType;
        }
        else {
            message.sourceType = 0;
        }
        if (object.sourcePath !== undefined && object.sourcePath !== null) {
            for (const e of object.sourcePath) {
                message.sourcePath.push(e);
            }
        }
        if (object.renderConfiguration !== undefined &&
            object.renderConfiguration !== null) {
            message.renderConfiguration = object.renderConfiguration;
        }
        else {
            message.renderConfiguration = 0;
        }
        return message;
    },
};
const baseRequestAnalyticsRecord = {
    requestId: "",
    deploymentId: "",
    method: 0,
    path: "",
    host: "",
    statusCode: 0,
    bodySizeBytes: 0,
    remoteIp: "",
    nodePhysicalLocation: "",
    nodeId: "",
    nodeInstanceId: "",
    sdkVersion: "",
    operationType: 0,
    cacheHit: false,
    sub: "",
};
exports.RequestAnalyticsRecord = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.requestId !== "") {
            writer.uint32(10).string(message.requestId);
        }
        if (message.deploymentId !== "") {
            writer.uint32(18).string(message.deploymentId);
        }
        if (message.method !== 0) {
            writer.uint32(24).int32(message.method);
        }
        if (message.path !== "") {
            writer.uint32(34).string(message.path);
        }
        if (message.host !== "") {
            writer.uint32(42).string(message.host);
        }
        if (message.startTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.startTime), writer.uint32(50).fork()).ldelim();
        }
        if (message.duration !== undefined) {
            duration_1.Duration.encode(message.duration, writer.uint32(58).fork()).ldelim();
        }
        if (message.statusCode !== 0) {
            writer.uint32(64).int64(message.statusCode);
        }
        if (message.bodySizeBytes !== 0) {
            writer.uint32(72).int64(message.bodySizeBytes);
        }
        if (message.remoteIp !== "") {
            writer.uint32(82).string(message.remoteIp);
        }
        if (message.nodePhysicalLocation !== "") {
            writer.uint32(90).string(message.nodePhysicalLocation);
        }
        if (message.nodeId !== "") {
            writer.uint32(98).string(message.nodeId);
        }
        if (message.nodeInstanceId !== "") {
            writer.uint32(106).string(message.nodeInstanceId);
        }
        if (message.sdkVersion !== "") {
            writer.uint32(114).string(message.sdkVersion);
        }
        if (message.operationType !== 0) {
            writer.uint32(120).int32(message.operationType);
        }
        if (message.cacheHit === true) {
            writer.uint32(128).bool(message.cacheHit);
        }
        if (message.sub !== "") {
            writer.uint32(146).string(message.sub);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseRequestAnalyticsRecord };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.deploymentId = reader.string();
                    break;
                case 3:
                    message.method = reader.int32();
                    break;
                case 4:
                    message.path = reader.string();
                    break;
                case 5:
                    message.host = reader.string();
                    break;
                case 6:
                    message.startTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.duration = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.statusCode = longToNumber(reader.int64());
                    break;
                case 9:
                    message.bodySizeBytes = longToNumber(reader.int64());
                    break;
                case 10:
                    message.remoteIp = reader.string();
                    break;
                case 11:
                    message.nodePhysicalLocation = reader.string();
                    break;
                case 12:
                    message.nodeId = reader.string();
                    break;
                case 13:
                    message.nodeInstanceId = reader.string();
                    break;
                case 14:
                    message.sdkVersion = reader.string();
                    break;
                case 15:
                    message.operationType = reader.int32();
                    break;
                case 16:
                    message.cacheHit = reader.bool();
                    break;
                case 18:
                    message.sub = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseRequestAnalyticsRecord };
        if (object.requestId !== undefined && object.requestId !== null) {
            message.requestId = String(object.requestId);
        }
        else {
            message.requestId = "";
        }
        if (object.deploymentId !== undefined && object.deploymentId !== null) {
            message.deploymentId = String(object.deploymentId);
        }
        else {
            message.deploymentId = "";
        }
        if (object.method !== undefined && object.method !== null) {
            message.method = hTTPMethodFromJSON(object.method);
        }
        else {
            message.method = 0;
        }
        if (object.path !== undefined && object.path !== null) {
            message.path = String(object.path);
        }
        else {
            message.path = "";
        }
        if (object.host !== undefined && object.host !== null) {
            message.host = String(object.host);
        }
        else {
            message.host = "";
        }
        if (object.startTime !== undefined && object.startTime !== null) {
            message.startTime = fromJsonTimestamp(object.startTime);
        }
        else {
            message.startTime = undefined;
        }
        if (object.duration !== undefined && object.duration !== null) {
            message.duration = duration_1.Duration.fromJSON(object.duration);
        }
        else {
            message.duration = undefined;
        }
        if (object.statusCode !== undefined && object.statusCode !== null) {
            message.statusCode = Number(object.statusCode);
        }
        else {
            message.statusCode = 0;
        }
        if (object.bodySizeBytes !== undefined && object.bodySizeBytes !== null) {
            message.bodySizeBytes = Number(object.bodySizeBytes);
        }
        else {
            message.bodySizeBytes = 0;
        }
        if (object.remoteIp !== undefined && object.remoteIp !== null) {
            message.remoteIp = String(object.remoteIp);
        }
        else {
            message.remoteIp = "";
        }
        if (object.nodePhysicalLocation !== undefined &&
            object.nodePhysicalLocation !== null) {
            message.nodePhysicalLocation = String(object.nodePhysicalLocation);
        }
        else {
            message.nodePhysicalLocation = "";
        }
        if (object.nodeId !== undefined && object.nodeId !== null) {
            message.nodeId = String(object.nodeId);
        }
        else {
            message.nodeId = "";
        }
        if (object.nodeInstanceId !== undefined && object.nodeInstanceId !== null) {
            message.nodeInstanceId = String(object.nodeInstanceId);
        }
        else {
            message.nodeInstanceId = "";
        }
        if (object.sdkVersion !== undefined && object.sdkVersion !== null) {
            message.sdkVersion = String(object.sdkVersion);
        }
        else {
            message.sdkVersion = "";
        }
        if (object.operationType !== undefined && object.operationType !== null) {
            message.operationType = analyticsRequestTypeFromJSON(object.operationType);
        }
        else {
            message.operationType = 0;
        }
        if (object.cacheHit !== undefined && object.cacheHit !== null) {
            message.cacheHit = Boolean(object.cacheHit);
        }
        else {
            message.cacheHit = false;
        }
        if (object.sub !== undefined && object.sub !== null) {
            message.sub = String(object.sub);
        }
        else {
            message.sub = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.requestId !== undefined && (obj.requestId = message.requestId);
        message.deploymentId !== undefined &&
            (obj.deploymentId = message.deploymentId);
        message.method !== undefined &&
            (obj.method = hTTPMethodToJSON(message.method));
        message.path !== undefined && (obj.path = message.path);
        message.host !== undefined && (obj.host = message.host);
        message.startTime !== undefined &&
            (obj.startTime = message.startTime.toISOString());
        message.duration !== undefined &&
            (obj.duration = message.duration
                ? duration_1.Duration.toJSON(message.duration)
                : undefined);
        message.statusCode !== undefined && (obj.statusCode = message.statusCode);
        message.bodySizeBytes !== undefined &&
            (obj.bodySizeBytes = message.bodySizeBytes);
        message.remoteIp !== undefined && (obj.remoteIp = message.remoteIp);
        message.nodePhysicalLocation !== undefined &&
            (obj.nodePhysicalLocation = message.nodePhysicalLocation);
        message.nodeId !== undefined && (obj.nodeId = message.nodeId);
        message.nodeInstanceId !== undefined &&
            (obj.nodeInstanceId = message.nodeInstanceId);
        message.sdkVersion !== undefined && (obj.sdkVersion = message.sdkVersion);
        message.operationType !== undefined &&
            (obj.operationType = analyticsRequestTypeToJSON(message.operationType));
        message.cacheHit !== undefined && (obj.cacheHit = message.cacheHit);
        message.sub !== undefined && (obj.sub = message.sub);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseRequestAnalyticsRecord };
        if (object.requestId !== undefined && object.requestId !== null) {
            message.requestId = object.requestId;
        }
        else {
            message.requestId = "";
        }
        if (object.deploymentId !== undefined && object.deploymentId !== null) {
            message.deploymentId = object.deploymentId;
        }
        else {
            message.deploymentId = "";
        }
        if (object.method !== undefined && object.method !== null) {
            message.method = object.method;
        }
        else {
            message.method = 0;
        }
        if (object.path !== undefined && object.path !== null) {
            message.path = object.path;
        }
        else {
            message.path = "";
        }
        if (object.host !== undefined && object.host !== null) {
            message.host = object.host;
        }
        else {
            message.host = "";
        }
        if (object.startTime !== undefined && object.startTime !== null) {
            message.startTime = object.startTime;
        }
        else {
            message.startTime = undefined;
        }
        if (object.duration !== undefined && object.duration !== null) {
            message.duration = duration_1.Duration.fromPartial(object.duration);
        }
        else {
            message.duration = undefined;
        }
        if (object.statusCode !== undefined && object.statusCode !== null) {
            message.statusCode = object.statusCode;
        }
        else {
            message.statusCode = 0;
        }
        if (object.bodySizeBytes !== undefined && object.bodySizeBytes !== null) {
            message.bodySizeBytes = object.bodySizeBytes;
        }
        else {
            message.bodySizeBytes = 0;
        }
        if (object.remoteIp !== undefined && object.remoteIp !== null) {
            message.remoteIp = object.remoteIp;
        }
        else {
            message.remoteIp = "";
        }
        if (object.nodePhysicalLocation !== undefined &&
            object.nodePhysicalLocation !== null) {
            message.nodePhysicalLocation = object.nodePhysicalLocation;
        }
        else {
            message.nodePhysicalLocation = "";
        }
        if (object.nodeId !== undefined && object.nodeId !== null) {
            message.nodeId = object.nodeId;
        }
        else {
            message.nodeId = "";
        }
        if (object.nodeInstanceId !== undefined && object.nodeInstanceId !== null) {
            message.nodeInstanceId = object.nodeInstanceId;
        }
        else {
            message.nodeInstanceId = "";
        }
        if (object.sdkVersion !== undefined && object.sdkVersion !== null) {
            message.sdkVersion = object.sdkVersion;
        }
        else {
            message.sdkVersion = "";
        }
        if (object.operationType !== undefined && object.operationType !== null) {
            message.operationType = object.operationType;
        }
        else {
            message.operationType = 0;
        }
        if (object.cacheHit !== undefined && object.cacheHit !== null) {
            message.cacheHit = object.cacheHit;
        }
        else {
            message.cacheHit = false;
        }
        if (object.sub !== undefined && object.sub !== null) {
            message.sub = object.sub;
        }
        else {
            message.sub = "";
        }
        return message;
    },
};
const baseWunderNodeAnalyticsData = {};
exports.WunderNodeAnalyticsData = {
    encode(message, writer = minimal_1.Writer.create()) {
        for (const v of message.requests) {
            exports.RequestAnalyticsRecord.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseWunderNodeAnalyticsData,
        };
        message.requests = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.requests.push(exports.RequestAnalyticsRecord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseWunderNodeAnalyticsData,
        };
        message.requests = [];
        if (object.requests !== undefined && object.requests !== null) {
            for (const e of object.requests) {
                message.requests.push(exports.RequestAnalyticsRecord.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.requests) {
            obj.requests = message.requests.map((e) => e ? exports.RequestAnalyticsRecord.toJSON(e) : undefined);
        }
        else {
            obj.requests = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseWunderNodeAnalyticsData,
        };
        message.requests = [];
        if (object.requests !== undefined && object.requests !== null) {
            for (const e of object.requests) {
                message.requests.push(exports.RequestAnalyticsRecord.fromPartial(e));
            }
        }
        return message;
    },
};
const baseWunderGraphConfiguration = {
    apiId: "",
    deploymentName: "",
    environmentIds: "",
    apiName: "",
    dangerouslyEnableGraphQLEndpoint: false,
};
exports.WunderGraphConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.api !== undefined) {
            exports.UserDefinedApi.encode(message.api, writer.uint32(10).fork()).ldelim();
        }
        if (message.apiId !== "") {
            writer.uint32(18).string(message.apiId);
        }
        if (message.deploymentName !== "") {
            writer.uint32(26).string(message.deploymentName);
        }
        for (const v of message.environmentIds) {
            writer.uint32(34).string(v);
        }
        if (message.apiName !== "") {
            writer.uint32(42).string(message.apiName);
        }
        if (message.dangerouslyEnableGraphQLEndpoint === true) {
            writer.uint32(48).bool(message.dangerouslyEnableGraphQLEndpoint);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = {
            ...baseWunderGraphConfiguration,
        };
        message.environmentIds = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.api = exports.UserDefinedApi.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.apiId = reader.string();
                    break;
                case 3:
                    message.deploymentName = reader.string();
                    break;
                case 4:
                    message.environmentIds.push(reader.string());
                    break;
                case 5:
                    message.apiName = reader.string();
                    break;
                case 6:
                    message.dangerouslyEnableGraphQLEndpoint = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = {
            ...baseWunderGraphConfiguration,
        };
        message.environmentIds = [];
        if (object.api !== undefined && object.api !== null) {
            message.api = exports.UserDefinedApi.fromJSON(object.api);
        }
        else {
            message.api = undefined;
        }
        if (object.apiId !== undefined && object.apiId !== null) {
            message.apiId = String(object.apiId);
        }
        else {
            message.apiId = "";
        }
        if (object.deploymentName !== undefined && object.deploymentName !== null) {
            message.deploymentName = String(object.deploymentName);
        }
        else {
            message.deploymentName = "";
        }
        if (object.environmentIds !== undefined && object.environmentIds !== null) {
            for (const e of object.environmentIds) {
                message.environmentIds.push(String(e));
            }
        }
        if (object.apiName !== undefined && object.apiName !== null) {
            message.apiName = String(object.apiName);
        }
        else {
            message.apiName = "";
        }
        if (object.dangerouslyEnableGraphQLEndpoint !== undefined &&
            object.dangerouslyEnableGraphQLEndpoint !== null) {
            message.dangerouslyEnableGraphQLEndpoint = Boolean(object.dangerouslyEnableGraphQLEndpoint);
        }
        else {
            message.dangerouslyEnableGraphQLEndpoint = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.api !== undefined &&
            (obj.api = message.api ? exports.UserDefinedApi.toJSON(message.api) : undefined);
        message.apiId !== undefined && (obj.apiId = message.apiId);
        message.deploymentName !== undefined &&
            (obj.deploymentName = message.deploymentName);
        if (message.environmentIds) {
            obj.environmentIds = message.environmentIds.map((e) => e);
        }
        else {
            obj.environmentIds = [];
        }
        message.apiName !== undefined && (obj.apiName = message.apiName);
        message.dangerouslyEnableGraphQLEndpoint !== undefined &&
            (obj.dangerouslyEnableGraphQLEndpoint =
                message.dangerouslyEnableGraphQLEndpoint);
        return obj;
    },
    fromPartial(object) {
        const message = {
            ...baseWunderGraphConfiguration,
        };
        message.environmentIds = [];
        if (object.api !== undefined && object.api !== null) {
            message.api = exports.UserDefinedApi.fromPartial(object.api);
        }
        else {
            message.api = undefined;
        }
        if (object.apiId !== undefined && object.apiId !== null) {
            message.apiId = object.apiId;
        }
        else {
            message.apiId = "";
        }
        if (object.deploymentName !== undefined && object.deploymentName !== null) {
            message.deploymentName = object.deploymentName;
        }
        else {
            message.deploymentName = "";
        }
        if (object.environmentIds !== undefined && object.environmentIds !== null) {
            for (const e of object.environmentIds) {
                message.environmentIds.push(e);
            }
        }
        if (object.apiName !== undefined && object.apiName !== null) {
            message.apiName = object.apiName;
        }
        else {
            message.apiName = "";
        }
        if (object.dangerouslyEnableGraphQLEndpoint !== undefined &&
            object.dangerouslyEnableGraphQLEndpoint !== null) {
            message.dangerouslyEnableGraphQLEndpoint =
                object.dangerouslyEnableGraphQLEndpoint;
        }
        else {
            message.dangerouslyEnableGraphQLEndpoint = false;
        }
        return message;
    },
};
const baseS3UploadConfiguration = { name: "", useSSL: false };
exports.S3UploadConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.endpoint !== undefined) {
            exports.ConfigurationVariable.encode(message.endpoint, writer.uint32(18).fork()).ldelim();
        }
        if (message.accessKeyID !== undefined) {
            exports.ConfigurationVariable.encode(message.accessKeyID, writer.uint32(26).fork()).ldelim();
        }
        if (message.secretAccessKey !== undefined) {
            exports.ConfigurationVariable.encode(message.secretAccessKey, writer.uint32(34).fork()).ldelim();
        }
        if (message.bucketName !== undefined) {
            exports.ConfigurationVariable.encode(message.bucketName, writer.uint32(42).fork()).ldelim();
        }
        if (message.bucketLocation !== undefined) {
            exports.ConfigurationVariable.encode(message.bucketLocation, writer.uint32(50).fork()).ldelim();
        }
        if (message.useSSL === true) {
            writer.uint32(56).bool(message.useSSL);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseS3UploadConfiguration };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.endpoint = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.accessKeyID = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.secretAccessKey = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.bucketName = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.bucketLocation = exports.ConfigurationVariable.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.useSSL = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseS3UploadConfiguration };
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        }
        else {
            message.name = "";
        }
        if (object.endpoint !== undefined && object.endpoint !== null) {
            message.endpoint = exports.ConfigurationVariable.fromJSON(object.endpoint);
        }
        else {
            message.endpoint = undefined;
        }
        if (object.accessKeyID !== undefined && object.accessKeyID !== null) {
            message.accessKeyID = exports.ConfigurationVariable.fromJSON(object.accessKeyID);
        }
        else {
            message.accessKeyID = undefined;
        }
        if (object.secretAccessKey !== undefined &&
            object.secretAccessKey !== null) {
            message.secretAccessKey = exports.ConfigurationVariable.fromJSON(object.secretAccessKey);
        }
        else {
            message.secretAccessKey = undefined;
        }
        if (object.bucketName !== undefined && object.bucketName !== null) {
            message.bucketName = exports.ConfigurationVariable.fromJSON(object.bucketName);
        }
        else {
            message.bucketName = undefined;
        }
        if (object.bucketLocation !== undefined && object.bucketLocation !== null) {
            message.bucketLocation = exports.ConfigurationVariable.fromJSON(object.bucketLocation);
        }
        else {
            message.bucketLocation = undefined;
        }
        if (object.useSSL !== undefined && object.useSSL !== null) {
            message.useSSL = Boolean(object.useSSL);
        }
        else {
            message.useSSL = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.endpoint !== undefined &&
            (obj.endpoint = message.endpoint
                ? exports.ConfigurationVariable.toJSON(message.endpoint)
                : undefined);
        message.accessKeyID !== undefined &&
            (obj.accessKeyID = message.accessKeyID
                ? exports.ConfigurationVariable.toJSON(message.accessKeyID)
                : undefined);
        message.secretAccessKey !== undefined &&
            (obj.secretAccessKey = message.secretAccessKey
                ? exports.ConfigurationVariable.toJSON(message.secretAccessKey)
                : undefined);
        message.bucketName !== undefined &&
            (obj.bucketName = message.bucketName
                ? exports.ConfigurationVariable.toJSON(message.bucketName)
                : undefined);
        message.bucketLocation !== undefined &&
            (obj.bucketLocation = message.bucketLocation
                ? exports.ConfigurationVariable.toJSON(message.bucketLocation)
                : undefined);
        message.useSSL !== undefined && (obj.useSSL = message.useSSL);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseS3UploadConfiguration };
        if (object.name !== undefined && object.name !== null) {
            message.name = object.name;
        }
        else {
            message.name = "";
        }
        if (object.endpoint !== undefined && object.endpoint !== null) {
            message.endpoint = exports.ConfigurationVariable.fromPartial(object.endpoint);
        }
        else {
            message.endpoint = undefined;
        }
        if (object.accessKeyID !== undefined && object.accessKeyID !== null) {
            message.accessKeyID = exports.ConfigurationVariable.fromPartial(object.accessKeyID);
        }
        else {
            message.accessKeyID = undefined;
        }
        if (object.secretAccessKey !== undefined &&
            object.secretAccessKey !== null) {
            message.secretAccessKey = exports.ConfigurationVariable.fromPartial(object.secretAccessKey);
        }
        else {
            message.secretAccessKey = undefined;
        }
        if (object.bucketName !== undefined && object.bucketName !== null) {
            message.bucketName = exports.ConfigurationVariable.fromPartial(object.bucketName);
        }
        else {
            message.bucketName = undefined;
        }
        if (object.bucketLocation !== undefined && object.bucketLocation !== null) {
            message.bucketLocation = exports.ConfigurationVariable.fromPartial(object.bucketLocation);
        }
        else {
            message.bucketLocation = undefined;
        }
        if (object.useSSL !== undefined && object.useSSL !== null) {
            message.useSSL = object.useSSL;
        }
        else {
            message.useSSL = false;
        }
        return message;
    },
};
const baseUserDefinedApi = { enableGraphqlEndpoint: false };
exports.UserDefinedApi = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.engineConfiguration !== undefined) {
            exports.EngineConfiguration.encode(message.engineConfiguration, writer.uint32(26).fork()).ldelim();
        }
        if (message.enableGraphqlEndpoint === true) {
            writer.uint32(40).bool(message.enableGraphqlEndpoint);
        }
        for (const v of message.operations) {
            exports.Operation.encode(v, writer.uint32(50).fork()).ldelim();
        }
        if (message.corsConfiguration !== undefined) {
            exports.CorsConfiguration.encode(message.corsConfiguration, writer.uint32(58).fork()).ldelim();
        }
        if (message.authenticationConfig !== undefined) {
            exports.ApiAuthenticationConfig.encode(message.authenticationConfig, writer.uint32(66).fork()).ldelim();
        }
        for (const v of message.s3UploadConfiguration) {
            exports.S3UploadConfiguration.encode(v, writer.uint32(74).fork()).ldelim();
        }
        for (const v of message.additionalHostNames) {
            exports.ConfigurationVariable.encode(v, writer.uint32(82).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseUserDefinedApi };
        message.operations = [];
        message.s3UploadConfiguration = [];
        message.additionalHostNames = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 3:
                    message.engineConfiguration = exports.EngineConfiguration.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.enableGraphqlEndpoint = reader.bool();
                    break;
                case 6:
                    message.operations.push(exports.Operation.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.corsConfiguration = exports.CorsConfiguration.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.authenticationConfig = exports.ApiAuthenticationConfig.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.s3UploadConfiguration.push(exports.S3UploadConfiguration.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.additionalHostNames.push(exports.ConfigurationVariable.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseUserDefinedApi };
        message.operations = [];
        message.s3UploadConfiguration = [];
        message.additionalHostNames = [];
        if (object.engineConfiguration !== undefined &&
            object.engineConfiguration !== null) {
            message.engineConfiguration = exports.EngineConfiguration.fromJSON(object.engineConfiguration);
        }
        else {
            message.engineConfiguration = undefined;
        }
        if (object.enableGraphqlEndpoint !== undefined &&
            object.enableGraphqlEndpoint !== null) {
            message.enableGraphqlEndpoint = Boolean(object.enableGraphqlEndpoint);
        }
        else {
            message.enableGraphqlEndpoint = false;
        }
        if (object.operations !== undefined && object.operations !== null) {
            for (const e of object.operations) {
                message.operations.push(exports.Operation.fromJSON(e));
            }
        }
        if (object.corsConfiguration !== undefined &&
            object.corsConfiguration !== null) {
            message.corsConfiguration = exports.CorsConfiguration.fromJSON(object.corsConfiguration);
        }
        else {
            message.corsConfiguration = undefined;
        }
        if (object.authenticationConfig !== undefined &&
            object.authenticationConfig !== null) {
            message.authenticationConfig = exports.ApiAuthenticationConfig.fromJSON(object.authenticationConfig);
        }
        else {
            message.authenticationConfig = undefined;
        }
        if (object.s3UploadConfiguration !== undefined &&
            object.s3UploadConfiguration !== null) {
            for (const e of object.s3UploadConfiguration) {
                message.s3UploadConfiguration.push(exports.S3UploadConfiguration.fromJSON(e));
            }
        }
        if (object.additionalHostNames !== undefined &&
            object.additionalHostNames !== null) {
            for (const e of object.additionalHostNames) {
                message.additionalHostNames.push(exports.ConfigurationVariable.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.engineConfiguration !== undefined &&
            (obj.engineConfiguration = message.engineConfiguration
                ? exports.EngineConfiguration.toJSON(message.engineConfiguration)
                : undefined);
        message.enableGraphqlEndpoint !== undefined &&
            (obj.enableGraphqlEndpoint = message.enableGraphqlEndpoint);
        if (message.operations) {
            obj.operations = message.operations.map((e) => e ? exports.Operation.toJSON(e) : undefined);
        }
        else {
            obj.operations = [];
        }
        message.corsConfiguration !== undefined &&
            (obj.corsConfiguration = message.corsConfiguration
                ? exports.CorsConfiguration.toJSON(message.corsConfiguration)
                : undefined);
        message.authenticationConfig !== undefined &&
            (obj.authenticationConfig = message.authenticationConfig
                ? exports.ApiAuthenticationConfig.toJSON(message.authenticationConfig)
                : undefined);
        if (message.s3UploadConfiguration) {
            obj.s3UploadConfiguration = message.s3UploadConfiguration.map((e) => e ? exports.S3UploadConfiguration.toJSON(e) : undefined);
        }
        else {
            obj.s3UploadConfiguration = [];
        }
        if (message.additionalHostNames) {
            obj.additionalHostNames = message.additionalHostNames.map((e) => e ? exports.ConfigurationVariable.toJSON(e) : undefined);
        }
        else {
            obj.additionalHostNames = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseUserDefinedApi };
        message.operations = [];
        message.s3UploadConfiguration = [];
        message.additionalHostNames = [];
        if (object.engineConfiguration !== undefined &&
            object.engineConfiguration !== null) {
            message.engineConfiguration = exports.EngineConfiguration.fromPartial(object.engineConfiguration);
        }
        else {
            message.engineConfiguration = undefined;
        }
        if (object.enableGraphqlEndpoint !== undefined &&
            object.enableGraphqlEndpoint !== null) {
            message.enableGraphqlEndpoint = object.enableGraphqlEndpoint;
        }
        else {
            message.enableGraphqlEndpoint = false;
        }
        if (object.operations !== undefined && object.operations !== null) {
            for (const e of object.operations) {
                message.operations.push(exports.Operation.fromPartial(e));
            }
        }
        if (object.corsConfiguration !== undefined &&
            object.corsConfiguration !== null) {
            message.corsConfiguration = exports.CorsConfiguration.fromPartial(object.corsConfiguration);
        }
        else {
            message.corsConfiguration = undefined;
        }
        if (object.authenticationConfig !== undefined &&
            object.authenticationConfig !== null) {
            message.authenticationConfig = exports.ApiAuthenticationConfig.fromPartial(object.authenticationConfig);
        }
        else {
            message.authenticationConfig = undefined;
        }
        if (object.s3UploadConfiguration !== undefined &&
            object.s3UploadConfiguration !== null) {
            for (const e of object.s3UploadConfiguration) {
                message.s3UploadConfiguration.push(exports.S3UploadConfiguration.fromPartial(e));
            }
        }
        if (object.additionalHostNames !== undefined &&
            object.additionalHostNames !== null) {
            for (const e of object.additionalHostNames) {
                message.additionalHostNames.push(exports.ConfigurationVariable.fromPartial(e));
            }
        }
        return message;
    },
};
const baseCorsConfiguration = {
    allowedMethods: "",
    allowedHeaders: "",
    exposedHeaders: "",
    maxAge: 0,
    allowCredentials: false,
};
exports.CorsConfiguration = {
    encode(message, writer = minimal_1.Writer.create()) {
        for (const v of message.allowedOrigins) {
            exports.ConfigurationVariable.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.allowedMethods) {
            writer.uint32(18).string(v);
        }
        for (const v of message.allowedHeaders) {
            writer.uint32(26).string(v);
        }
        for (const v of message.exposedHeaders) {
            writer.uint32(34).string(v);
        }
        if (message.maxAge !== 0) {
            writer.uint32(40).int64(message.maxAge);
        }
        if (message.allowCredentials === true) {
            writer.uint32(48).bool(message.allowCredentials);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseCorsConfiguration };
        message.allowedOrigins = [];
        message.allowedMethods = [];
        message.allowedHeaders = [];
        message.exposedHeaders = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.allowedOrigins.push(exports.ConfigurationVariable.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.allowedMethods.push(reader.string());
                    break;
                case 3:
                    message.allowedHeaders.push(reader.string());
                    break;
                case 4:
                    message.exposedHeaders.push(reader.string());
                    break;
                case 5:
                    message.maxAge = longToNumber(reader.int64());
                    break;
                case 6:
                    message.allowCredentials = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseCorsConfiguration };
        message.allowedOrigins = [];
        message.allowedMethods = [];
        message.allowedHeaders = [];
        message.exposedHeaders = [];
        if (object.allowedOrigins !== undefined && object.allowedOrigins !== null) {
            for (const e of object.allowedOrigins) {
                message.allowedOrigins.push(exports.ConfigurationVariable.fromJSON(e));
            }
        }
        if (object.allowedMethods !== undefined && object.allowedMethods !== null) {
            for (const e of object.allowedMethods) {
                message.allowedMethods.push(String(e));
            }
        }
        if (object.allowedHeaders !== undefined && object.allowedHeaders !== null) {
            for (const e of object.allowedHeaders) {
                message.allowedHeaders.push(String(e));
            }
        }
        if (object.exposedHeaders !== undefined && object.exposedHeaders !== null) {
            for (const e of object.exposedHeaders) {
                message.exposedHeaders.push(String(e));
            }
        }
        if (object.maxAge !== undefined && object.maxAge !== null) {
            message.maxAge = Number(object.maxAge);
        }
        else {
            message.maxAge = 0;
        }
        if (object.allowCredentials !== undefined &&
            object.allowCredentials !== null) {
            message.allowCredentials = Boolean(object.allowCredentials);
        }
        else {
            message.allowCredentials = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.allowedOrigins) {
            obj.allowedOrigins = message.allowedOrigins.map((e) => e ? exports.ConfigurationVariable.toJSON(e) : undefined);
        }
        else {
            obj.allowedOrigins = [];
        }
        if (message.allowedMethods) {
            obj.allowedMethods = message.allowedMethods.map((e) => e);
        }
        else {
            obj.allowedMethods = [];
        }
        if (message.allowedHeaders) {
            obj.allowedHeaders = message.allowedHeaders.map((e) => e);
        }
        else {
            obj.allowedHeaders = [];
        }
        if (message.exposedHeaders) {
            obj.exposedHeaders = message.exposedHeaders.map((e) => e);
        }
        else {
            obj.exposedHeaders = [];
        }
        message.maxAge !== undefined && (obj.maxAge = message.maxAge);
        message.allowCredentials !== undefined &&
            (obj.allowCredentials = message.allowCredentials);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseCorsConfiguration };
        message.allowedOrigins = [];
        message.allowedMethods = [];
        message.allowedHeaders = [];
        message.exposedHeaders = [];
        if (object.allowedOrigins !== undefined && object.allowedOrigins !== null) {
            for (const e of object.allowedOrigins) {
                message.allowedOrigins.push(exports.ConfigurationVariable.fromPartial(e));
            }
        }
        if (object.allowedMethods !== undefined && object.allowedMethods !== null) {
            for (const e of object.allowedMethods) {
                message.allowedMethods.push(e);
            }
        }
        if (object.allowedHeaders !== undefined && object.allowedHeaders !== null) {
            for (const e of object.allowedHeaders) {
                message.allowedHeaders.push(e);
            }
        }
        if (object.exposedHeaders !== undefined && object.exposedHeaders !== null) {
            for (const e of object.exposedHeaders) {
                message.exposedHeaders.push(e);
            }
        }
        if (object.maxAge !== undefined && object.maxAge !== null) {
            message.maxAge = object.maxAge;
        }
        else {
            message.maxAge = 0;
        }
        if (object.allowCredentials !== undefined &&
            object.allowCredentials !== null) {
            message.allowCredentials = object.allowCredentials;
        }
        else {
            message.allowCredentials = false;
        }
        return message;
    },
};
const baseConfigurationVariable = {
    kind: 0,
    staticVariableContent: "",
    environmentVariableName: "",
    environmentVariableDefaultValue: "",
    placeholderVariableName: "",
};
exports.ConfigurationVariable = {
    encode(message, writer = minimal_1.Writer.create()) {
        if (message.kind !== 0) {
            writer.uint32(8).int32(message.kind);
        }
        if (message.staticVariableContent !== "") {
            writer.uint32(18).string(message.staticVariableContent);
        }
        if (message.environmentVariableName !== "") {
            writer.uint32(26).string(message.environmentVariableName);
        }
        if (message.environmentVariableDefaultValue !== "") {
            writer.uint32(34).string(message.environmentVariableDefaultValue);
        }
        if (message.placeholderVariableName !== "") {
            writer.uint32(42).string(message.placeholderVariableName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.Reader ? input : new minimal_1.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = { ...baseConfigurationVariable };
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.int32();
                    break;
                case 2:
                    message.staticVariableContent = reader.string();
                    break;
                case 3:
                    message.environmentVariableName = reader.string();
                    break;
                case 4:
                    message.environmentVariableDefaultValue = reader.string();
                    break;
                case 5:
                    message.placeholderVariableName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = { ...baseConfigurationVariable };
        if (object.kind !== undefined && object.kind !== null) {
            message.kind = configurationVariableKindFromJSON(object.kind);
        }
        else {
            message.kind = 0;
        }
        if (object.staticVariableContent !== undefined &&
            object.staticVariableContent !== null) {
            message.staticVariableContent = String(object.staticVariableContent);
        }
        else {
            message.staticVariableContent = "";
        }
        if (object.environmentVariableName !== undefined &&
            object.environmentVariableName !== null) {
            message.environmentVariableName = String(object.environmentVariableName);
        }
        else {
            message.environmentVariableName = "";
        }
        if (object.environmentVariableDefaultValue !== undefined &&
            object.environmentVariableDefaultValue !== null) {
            message.environmentVariableDefaultValue = String(object.environmentVariableDefaultValue);
        }
        else {
            message.environmentVariableDefaultValue = "";
        }
        if (object.placeholderVariableName !== undefined &&
            object.placeholderVariableName !== null) {
            message.placeholderVariableName = String(object.placeholderVariableName);
        }
        else {
            message.placeholderVariableName = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.kind !== undefined &&
            (obj.kind = configurationVariableKindToJSON(message.kind));
        message.staticVariableContent !== undefined &&
            (obj.staticVariableContent = message.staticVariableContent);
        message.environmentVariableName !== undefined &&
            (obj.environmentVariableName = message.environmentVariableName);
        message.environmentVariableDefaultValue !== undefined &&
            (obj.environmentVariableDefaultValue =
                message.environmentVariableDefaultValue);
        message.placeholderVariableName !== undefined &&
            (obj.placeholderVariableName = message.placeholderVariableName);
        return obj;
    },
    fromPartial(object) {
        const message = { ...baseConfigurationVariable };
        if (object.kind !== undefined && object.kind !== null) {
            message.kind = object.kind;
        }
        else {
            message.kind = 0;
        }
        if (object.staticVariableContent !== undefined &&
            object.staticVariableContent !== null) {
            message.staticVariableContent = object.staticVariableContent;
        }
        else {
            message.staticVariableContent = "";
        }
        if (object.environmentVariableName !== undefined &&
            object.environmentVariableName !== null) {
            message.environmentVariableName = object.environmentVariableName;
        }
        else {
            message.environmentVariableName = "";
        }
        if (object.environmentVariableDefaultValue !== undefined &&
            object.environmentVariableDefaultValue !== null) {
            message.environmentVariableDefaultValue =
                object.environmentVariableDefaultValue;
        }
        else {
            message.environmentVariableDefaultValue = "";
        }
        if (object.placeholderVariableName !== undefined &&
            object.placeholderVariableName !== null) {
            message.placeholderVariableName = object.placeholderVariableName;
        }
        else {
            message.placeholderVariableName = "";
        }
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
function toTimestamp(date) {
    const seconds = date.getTime() / 1000;
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = t.seconds * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
    }
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
// If you get a compile-error about 'Constructor<Long> and ... have no overlap',
// add '--ts_proto_opt=esModuleInterop=true' as a flag when calling 'protoc'.
if (minimal_1.util.Long !== Long) {
    minimal_1.util.Long = Long;
    minimal_1.configure();
}
