"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyNamespaceToApi = exports.applyNamespaceToDirectiveConfiguration = exports.generateTypeConfigurationsForNamespaceWithExisting = exports.generateTypeConfigurationsForNamespace = exports.applyNamespaceToExistingRootFieldConfigurationsWithPathRewrite = exports.applyNamespaceToExistingRootFieldConfigurations = exports.applyNameSpaceToFieldConfigurations = exports.applyNameSpaceToTypeFields = exports.applyNameSpaceToGraphQLSchema = void 0;
const graphql_1 = require("graphql");
const configuration_1 = require("../graphql/configuration");
const index_1 = require("./index");
const wellKnownTypeNames = [
    "Query",
    "Mutation",
    "Subscription",
    "String",
    "Int",
    "Boolean",
    "Float",
    "JSON",
    "ID",
    "_Any",
    "UnspecifiedHttpResponse"
];
const uniqueWellKnownTypes = (schema) => {
    var _a, _b, _c;
    const schemaDefinitionNode = schema.definitions.find(node => node.kind === "SchemaDefinition");
    const queryTypeName = ((_a = schemaDefinitionNode === null || schemaDefinitionNode === void 0 ? void 0 : schemaDefinitionNode.operationTypes.find(op => op.operation === "query")) === null || _a === void 0 ? void 0 : _a.type.name.value) || "Query";
    const mutationTypeName = ((_b = schemaDefinitionNode === null || schemaDefinitionNode === void 0 ? void 0 : schemaDefinitionNode.operationTypes.find(op => op.operation === "mutation")) === null || _b === void 0 ? void 0 : _b.type.name.value) || "Mutation";
    const subscriptionTypeName = ((_c = schemaDefinitionNode === null || schemaDefinitionNode === void 0 ? void 0 : schemaDefinitionNode.operationTypes.find(op => op.operation === "subscription")) === null || _c === void 0 ? void 0 : _c.type.name.value) || "Subscription";
    return [...new Set([...wellKnownTypeNames, queryTypeName, mutationTypeName, subscriptionTypeName])];
};
const wellKnownDirectives = [
    "include",
    "skip",
    "deprecated",
    "specifiedBy",
];
const applyNameSpaceToGraphQLSchema = (schema, namespace) => {
    var _a, _b, _c;
    if (namespace === undefined || namespace === "") {
        return (0, graphql_1.print)((0, graphql_1.parse)(schema));
    }
    const document = (0, graphql_1.parse)(schema);
    const schemaDefinitionNode = document.definitions.find(node => node.kind === "SchemaDefinition");
    const queryTypeName = ((_a = schemaDefinitionNode === null || schemaDefinitionNode === void 0 ? void 0 : schemaDefinitionNode.operationTypes.find(op => op.operation === "query")) === null || _a === void 0 ? void 0 : _a.type.name.value) || "Query";
    const mutationTypeName = ((_b = schemaDefinitionNode === null || schemaDefinitionNode === void 0 ? void 0 : schemaDefinitionNode.operationTypes.find(op => op.operation === "mutation")) === null || _b === void 0 ? void 0 : _b.type.name.value) || "Mutation";
    const subscriptionTypeName = ((_c = schemaDefinitionNode === null || schemaDefinitionNode === void 0 ? void 0 : schemaDefinitionNode.operationTypes.find(op => op.operation === "subscription")) === null || _c === void 0 ? void 0 : _c.type.name.value) || "Subscription";
    const keepTypes = uniqueWellKnownTypes(document);
    const updated = (0, graphql_1.visit)(document, {
        ObjectTypeDefinition: {
            enter: node => {
                var _a;
                const keepName = keepTypes.find(keep => keep === node.name.value) !== undefined;
                if (node.name.value === queryTypeName || node.name.value === mutationTypeName || node.name.value === subscriptionTypeName) {
                    const updated = {
                        ...node,
                        fields: (_a = node.fields) === null || _a === void 0 ? void 0 : _a.map(f => {
                            const field = {
                                ...f,
                                name: {
                                    kind: graphql_1.Kind.NAME,
                                    loc: f.name.loc,
                                    value: namespace + "_" + f.name.value,
                                }
                            };
                            return field;
                        }),
                        name: keepName ? node.name : {
                            kind: graphql_1.Kind.NAME,
                            loc: node.name.loc,
                            value: namespace + "_" + node.name.value,
                        }
                    };
                    return updated;
                }
                if (!keepName) {
                    const updated = {
                        ...node,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            loc: node.name.loc,
                            value: namespace + "_" + node.name.value,
                        }
                    };
                    return updated;
                }
            }
        },
        InterfaceTypeDefinition: {
            enter: node => {
                const updated = {
                    ...node,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        loc: node.name.loc,
                        value: namespace + "_" + node.name.value,
                    }
                };
                return updated;
            }
        },
        ScalarTypeDefinition: {
            enter: node => {
                const keep = keepTypes.find(keep => keep === node.name.value) !== undefined;
                if (keep) {
                    return;
                }
                const updated = {
                    ...node,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        loc: node.name.loc,
                        value: namespace + "_" + node.name.value,
                    }
                };
                return updated;
            }
        },
        EnumTypeDefinition: {
            enter: node => {
                const updated = {
                    ...node,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        loc: node.name.loc,
                        value: namespace + "_" + node.name.value,
                    }
                };
                return updated;
            }
        },
        InputObjectTypeDefinition: {
            enter: node => {
                const updated = {
                    ...node,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        loc: node.name.loc,
                        value: namespace + "_" + node.name.value,
                    }
                };
                return updated;
            }
        },
        UnionTypeDefinition: {
            enter: node => {
                const updated = {
                    ...node,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        loc: node.name.loc,
                        value: namespace + "_" + node.name.value,
                    }
                };
                return updated;
            }
        },
        DirectiveDefinition: {
            enter: node => {
                if (wellKnownDirectives.find(d => d === node.name.value) !== undefined) {
                    return; // skip well known
                }
                const updated = {
                    ...node,
                    name: {
                        ...node.name,
                        value: namespace + "_" + node.name.value,
                    }
                };
                return updated;
            }
        },
        NamedType: {
            enter: node => {
                const keep = keepTypes.find(keep => keep === node.name.value) !== undefined;
                if (!keep) {
                    const updated = {
                        ...node,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            loc: node.name.loc,
                            value: namespace + "_" + node.name.value,
                        }
                    };
                    return updated;
                }
            }
        }
    });
    return (0, graphql_1.print)(updated);
};
exports.applyNameSpaceToGraphQLSchema = applyNameSpaceToGraphQLSchema;
const applyNameSpaceToTypeFields = (fields, schema, namespace) => {
    if (namespace === undefined || namespace === "") {
        return fields;
    }
    return fields.map(typeField => {
        const isRoot = (0, configuration_1.isRootType)(typeField.typeName, schema);
        return {
            typeName: isRoot ? typeField.typeName : namespace + "_" + typeField.typeName,
            fieldNames: isRoot ? typeField.fieldNames.map(f => namespace + "_" + f) : typeField.fieldNames,
        };
    });
};
exports.applyNameSpaceToTypeFields = applyNameSpaceToTypeFields;
const applyNameSpaceToFieldConfigurations = (fields, schema, namespace) => {
    if (namespace === undefined || namespace === "") {
        return fields;
    }
    const mapped = fields.map(field => {
        const isRoot = (0, configuration_1.isRootType)(field.typeName, schema);
        return {
            ...field,
            typeName: isRoot ? field.typeName : namespace + "_" + field.typeName,
            fieldName: isRoot ? namespace + "_" + field.fieldName : field.fieldName,
            path: isRoot ? [field.fieldName] : field.path,
        };
    });
    const queryType = schema.getQueryType();
    if (queryType) {
        const fields = queryType.getFields();
        Object.keys(fields).forEach(key => {
            const field = fields[key];
            const namespacedFieldName = namespace + "_" + field.name;
            const exists = mapped.find(e => e.typeName === queryType.name && e.fieldName === namespacedFieldName);
            if (exists) {
                return;
            }
            mapped.push({
                typeName: queryType.name,
                fieldName: namespacedFieldName,
                disableDefaultFieldMapping: false,
                path: [field.name],
                argumentsConfiguration: [],
                requiresFields: [],
            });
        });
    }
    const mutationType = schema.getMutationType();
    if (mutationType) {
        const fields = mutationType.getFields();
        Object.keys(fields).forEach(key => {
            const field = fields[key];
            const namespacedFieldName = namespace + "_" + field.name;
            const exists = mapped.find(e => e.typeName === mutationType.name && e.fieldName === namespacedFieldName);
            if (exists) {
                return;
            }
            mapped.push({
                typeName: mutationType.name,
                fieldName: namespace + "_" + field.name,
                disableDefaultFieldMapping: false,
                path: [field.name],
                argumentsConfiguration: [],
                requiresFields: [],
            });
        });
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType) {
        const fields = subscriptionType.getFields();
        Object.keys(fields).forEach(key => {
            const field = fields[key];
            const namespacedFieldName = namespace + "_" + field.name;
            const exists = mapped.find(e => e.typeName === subscriptionType.name && e.fieldName === namespacedFieldName);
            if (exists) {
                return;
            }
            mapped.push({
                typeName: subscriptionType.name,
                fieldName: namespacedFieldName,
                disableDefaultFieldMapping: false,
                path: [field.name],
                argumentsConfiguration: [],
                requiresFields: [],
            });
        });
    }
    return mapped;
};
exports.applyNameSpaceToFieldConfigurations = applyNameSpaceToFieldConfigurations;
const applyNamespaceToExistingRootFieldConfigurations = (fields, schema, namespace) => {
    if (namespace === undefined || namespace === "") {
        return fields;
    }
    return fields.map(field => {
        const isRoot = (0, configuration_1.isRootType)(field.typeName, schema);
        return {
            ...field,
            typeName: isRoot ? field.typeName : namespace + "_" + field.typeName,
            fieldName: isRoot ? namespace + "_" + field.fieldName : field.fieldName,
        };
    });
};
exports.applyNamespaceToExistingRootFieldConfigurations = applyNamespaceToExistingRootFieldConfigurations;
const applyNamespaceToExistingRootFieldConfigurationsWithPathRewrite = (fields, schema, namespace) => {
    if (namespace === undefined || namespace === "") {
        return fields;
    }
    return fields.map(field => {
        const isRoot = (0, configuration_1.isRootType)(field.typeName, schema);
        const hasPath = field.path.length !== 0;
        const path = hasPath ? field.path : isRoot ? [field.fieldName] : field.path;
        return {
            ...field,
            path,
            typeName: isRoot ? field.typeName : namespace + "_" + field.typeName,
            fieldName: isRoot ? namespace + "_" + field.fieldName : field.fieldName,
        };
    });
};
exports.applyNamespaceToExistingRootFieldConfigurationsWithPathRewrite = applyNamespaceToExistingRootFieldConfigurationsWithPathRewrite;
const generateTypeConfigurationsForNamespace = (schema, namespace) => {
    if (namespace === undefined || namespace === "") {
        return [];
    }
    const out = [];
    const document = (0, graphql_1.parse)(schema);
    const keep = uniqueWellKnownTypes(document);
    (0, graphql_1.visit)(document, {
        InputObjectTypeDefinition: node => pushTypeConfiguration(out, keep, namespace, node),
        ObjectTypeDefinition: node => pushTypeConfiguration(out, keep, namespace, node),
        EnumTypeDefinition: node => pushTypeConfiguration(out, keep, namespace, node),
        UnionTypeDefinition: node => pushTypeConfiguration(out, keep, namespace, node),
        ScalarTypeDefinition: node => pushTypeConfiguration(out, keep, namespace, node),
        InterfaceTypeDefinition: node => pushTypeConfiguration(out, keep, namespace, node),
    });
    return out;
};
exports.generateTypeConfigurationsForNamespace = generateTypeConfigurationsForNamespace;
const generateTypeConfigurationsForNamespaceWithExisting = (schema, existing, namespace) => {
    if (namespace === undefined || namespace === "") {
        return [];
    }
    const out = existing;
    const document = (0, graphql_1.parse)(schema);
    const keep = uniqueWellKnownTypes(document);
    (0, graphql_1.visit)(document, {
        InputObjectTypeDefinition: node => pushTypeConfiguration(out, keep, namespace, node),
        ObjectTypeDefinition: node => pushTypeConfiguration(out, keep, namespace, node),
        EnumTypeDefinition: node => pushTypeConfiguration(out, keep, namespace, node),
        UnionTypeDefinition: node => pushTypeConfiguration(out, keep, namespace, node),
        ScalarTypeDefinition: node => pushTypeConfiguration(out, keep, namespace, node),
        InterfaceTypeDefinition: node => pushTypeConfiguration(out, keep, namespace, node),
    });
    return out;
};
exports.generateTypeConfigurationsForNamespaceWithExisting = generateTypeConfigurationsForNamespaceWithExisting;
const pushTypeConfiguration = (out, keep, namespace, node) => {
    const typeName = node.name.value;
    if (keep.find(k => k === typeName) !== undefined) {
        return;
    }
    const existing = out.find(t => t.typeName === typeName);
    if (existing !== undefined) {
        existing.typeName = namespace + "_" + typeName;
        return;
    }
    out.push({
        typeName: namespace + "_" + typeName,
        renameTo: typeName,
    });
};
const applyNamespaceToDirectiveConfiguration = (schema, namespace) => {
    if (namespace === undefined || namespace === "") {
        return [];
    }
    const out = [];
    schema.getDirectives().forEach(directive => {
        if (wellKnownDirectives.find(w => w === directive.name) !== undefined) {
            return;
        }
        out.push({
            directiveName: namespace + "_" + directive.name,
            renameTo: directive.name,
        });
    });
    return out;
};
exports.applyNamespaceToDirectiveConfiguration = applyNamespaceToDirectiveConfiguration;
const applyNamespaceToApi = (api, apiNamespace) => {
    const schema = (0, graphql_1.buildSchema)(api.Schema);
    const datasources = api.DataSources.map(ds => ({
        ...ds,
        RootNodes: (0, exports.applyNameSpaceToTypeFields)(ds.RootNodes, schema, apiNamespace),
        ChildNodes: (0, exports.applyNameSpaceToTypeFields)(ds.ChildNodes, schema, apiNamespace),
    }));
    const appliedSchema = (0, exports.applyNameSpaceToGraphQLSchema)(api.Schema, apiNamespace);
    const fields = (0, exports.applyNamespaceToExistingRootFieldConfigurationsWithPathRewrite)(api.Fields, schema, apiNamespace);
    const types = (0, exports.generateTypeConfigurationsForNamespaceWithExisting)(api.Schema, api.Types, apiNamespace);
    return new index_1.Api(appliedSchema, datasources, fields, types);
};
exports.applyNamespaceToApi = applyNamespaceToApi;
