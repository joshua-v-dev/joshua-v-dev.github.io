"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildUpstreamAuthentication = exports.introspect = exports.HeadersBuilder = exports.SQLServerApi = exports.SQLiteApi = exports.PlanetscaleApi = exports.MySQLApi = exports.PostgresqlApi = exports.RESTApi = exports.GraphQLApi = exports.createMockApi = exports.Api = exports.Application = void 0;
const federation_1 = require("../graphql/federation");
const configuration_1 = require("../graphql/configuration");
const graphql_1 = require("graphql");
const merge_1 = require("./merge");
const fs = __importStar(require("fs"));
const v2openapi_1 = require("../v2openapi");
const renametypes_1 = require("../graphql/renametypes");
const axios_1 = __importDefault(require("axios"));
const wundernode_config_1 = require("@wundergraph/protobuf/dist/wundernode_config");
const schema_1 = require("../graphql/schema");
const path_1 = __importDefault(require("path"));
const introspection_1 = require("../db/introspection");
const namespacing_1 = require("./namespacing");
const configure_1 = require("../configure");
const typescript_1 = require("../codegen/templates/typescript");
class Application {
    constructor(config) {
        this.name = config.name;
        this.apis = config.apis;
    }
}
exports.Application = Application;
class Api {
    constructor(schema, dataSources, fields, types) {
        this.DefaultFlushInterval = 500;
        this.Schema = schema;
        this.DataSources = dataSources;
        this.Fields = fields;
        this.Types = types;
    }
    renameTypes(rename) {
        this.Schema = (0, renametypes_1.renameTypes)(this.Schema, rename);
        this.DataSources = this.DataSources.map(d => {
            return {
                ...d,
                RootNodes: typeFieldsRenameType(d.RootNodes, rename),
                ChildNodes: typeFieldsRenameType(d.ChildNodes, rename),
            };
        });
        this.Fields = this.Fields.map(field => {
            const re = rename.find(r => r.from === field.typeName);
            return {
                ...field,
                typeName: re !== undefined ? re.to : field.typeName
            };
        });
    }
    renameTypeFields(rename) {
        this.Schema = (0, renametypes_1.renameTypeFields)(this.Schema, rename);
        this.DataSources = this.DataSources.map(d => {
            return {
                ...d,
                RootNodes: typeFieldsRenameTypeField(d.RootNodes, rename),
                ChildNodes: typeFieldsRenameTypeField(d.ChildNodes, rename),
            };
        });
        this.Fields = this.Fields.map(field => {
            const re = rename.find(re => re.typeName === field.typeName && re.fromFieldName === field.fieldName);
            if (re !== undefined) {
                return {
                    ...field,
                    fieldName: re.toFieldName,
                    path: field.path.map(item => item === field.fieldName ? re.toFieldName : item),
                };
            }
            const sameTypeRenameFields = rename.filter(re => re.typeName === field.typeName);
            return {
                ...field,
                requiresFields: field.requiresFields.map(f => {
                    const re = sameTypeRenameFields.find(sameTypeField => sameTypeField.fromFieldName === f);
                    if (re !== undefined) {
                        return re.toFieldName;
                    }
                    return f;
                }),
                argumentsConfiguration: field.argumentsConfiguration.map(arg => {
                    if (arg.sourceType === wundernode_config_1.ArgumentSource.OBJECT_FIELD) {
                        return {
                            ...arg,
                            sourcePath: arg.sourcePath.map(item => {
                                const re = sameTypeRenameFields.find(sameTypeField => sameTypeField.fromFieldName === item);
                                if (re !== undefined) {
                                    return re.toFieldName;
                                }
                                return item;
                            })
                        };
                    }
                    return arg;
                })
            };
        });
    }
}
exports.Api = Api;
const typeFieldsRenameType = (fields, rename) => {
    return fields.map(node => {
        const re = rename.find(r => r.from === node.typeName);
        return {
            ...node,
            typeName: re !== undefined ? re.to : node.typeName
        };
    });
};
const typeFieldsRenameTypeField = (fields, rename) => {
    return fields.map(node => {
        return {
            ...node,
            fieldNames: node.fieldNames.map(field => {
                const re = rename.find(re => re.typeName === node.typeName && re.fromFieldName === field);
                if (re !== undefined) {
                    return re.toFieldName;
                }
                return field;
            })
        };
    });
};
const createMockApi = async (sdl, apiNamespace) => {
    const schema = (0, graphql_1.print)((0, graphql_1.parse)(sdl));
    return new GraphQLApi((0, namespacing_1.applyNameSpaceToGraphQLSchema)(schema, apiNamespace), [], [], []);
};
exports.createMockApi = createMockApi;
class GraphQLApi extends Api {
}
exports.GraphQLApi = GraphQLApi;
class RESTApi extends Api {
}
exports.RESTApi = RESTApi;
class PostgresqlApi extends Api {
}
exports.PostgresqlApi = PostgresqlApi;
class MySQLApi extends Api {
}
exports.MySQLApi = MySQLApi;
class PlanetscaleApi extends Api {
}
exports.PlanetscaleApi = PlanetscaleApi;
class SQLiteApi extends Api {
}
exports.SQLiteApi = SQLiteApi;
class SQLServerApi extends Api {
}
exports.SQLServerApi = SQLServerApi;
class HeadersBuilder {
    constructor() {
        this.headers = [];
        this.addEnvironmentVariableHeader = (key, environmentVariableName) => {
            this.headers.push({
                key,
                value: environmentVariableName,
                valueSource: "env",
            });
            return this;
        };
        this.addStaticHeader = (key, value) => {
            if (typeof value === "string") {
                this.headers.push({
                    key,
                    value,
                    valueSource: "static",
                });
                return this;
            }
            if (value._identifier === "placeholder") {
                this.headers.push({
                    key,
                    value: value.name,
                    valueSource: "placeholder",
                });
                return this;
            }
            this.headers.push({
                key,
                value: value.name,
                valueSource: "env",
                defaultValue: value.defaultValue,
            });
            return this;
        };
        this.addClientRequestHeader = (key, requestHeaderName) => {
            this.headers.push({
                key,
                value: requestHeaderName,
                valueSource: "clientRequest",
            });
            return this;
        };
        this.build = () => {
            return this.headers;
        };
    }
}
exports.HeadersBuilder = HeadersBuilder;
const databaseSchemaToKind = (schema) => {
    switch (schema) {
        case "planetscale":
            return wundernode_config_1.DataSourceKind.MYSQL;
        case "mysql":
            return wundernode_config_1.DataSourceKind.MYSQL;
        case "postgresql":
            return wundernode_config_1.DataSourceKind.POSTGRESQL;
        case "sqlite":
            return wundernode_config_1.DataSourceKind.SQLITE;
        case "sqlserver":
            return wundernode_config_1.DataSourceKind.SQLSERVER;
        default:
            throw new Error(`databaseSchemaToKind not implemented for: ${schema}`);
    }
};
const introspectDatabase = (introspection, databaseSchema, maxRetries) => {
    const { success, message, graphql_schema, prisma_schema } = (0, introspection_1.introspectPrismaDatabaseWithRetries)(introspection.databaseURL, databaseSchema, maxRetries);
    if (!success) {
        return Promise.reject(message);
    }
    const schemaDocumentNode = (0, graphql_1.parse)(graphql_schema);
    const schema = (0, graphql_1.print)(schemaDocumentNode);
    const { RootNodes, ChildNodes, Fields } = (0, configuration_1.configuration)(schemaDocumentNode);
    const graphQLSchema = (0, graphql_1.buildSchema)(schema);
    return {
        schema: (0, namespacing_1.applyNameSpaceToGraphQLSchema)(schema, introspection.apiNamespace),
        dataSource: {
            Kind: databaseSchemaToKind(databaseSchema),
            RootNodes: (0, namespacing_1.applyNameSpaceToTypeFields)(RootNodes, graphQLSchema, introspection.apiNamespace),
            ChildNodes: (0, namespacing_1.applyNameSpaceToTypeFields)(ChildNodes, graphQLSchema, introspection.apiNamespace),
            Custom: {
                prisma_schema: prisma_schema,
                databaseURL: (0, configure_1.mapInputVariable)(introspection.databaseURL),
                graphql_schema: schema,
            },
            Directives: [],
        },
        fields: (0, namespacing_1.applyNameSpaceToFieldConfigurations)(Fields, graphQLSchema, introspection.apiNamespace),
        types: (0, namespacing_1.generateTypeConfigurationsForNamespace)(schema, introspection.apiNamespace),
    };
};
exports.introspect = {
    graphql: async (introspection) => {
        const headers = {};
        introspection.headers !== undefined && introspection.headers(new HeadersBuilder()).build().forEach(config => {
            const values = [];
            switch (config.valueSource) {
                case "placeholder":
                    values.push({
                        kind: wundernode_config_1.ConfigurationVariableKind.PLACEHOLDER_CONFIGURATION_VARIABLE,
                        staticVariableContent: "",
                        environmentVariableDefaultValue: "",
                        environmentVariableName: "",
                        placeholderVariableName: config.value,
                    });
                    break;
                case "clientRequest":
                    values.push({
                        kind: wundernode_config_1.ConfigurationVariableKind.STATIC_CONFIGURATION_VARIABLE,
                        staticVariableContent: `{{ .request.headers.${config.value} }}`,
                        environmentVariableName: "",
                        environmentVariableDefaultValue: "",
                        placeholderVariableName: "",
                    });
                    break;
                case "static":
                    values.push({
                        kind: wundernode_config_1.ConfigurationVariableKind.STATIC_CONFIGURATION_VARIABLE,
                        staticVariableContent: config.value,
                        environmentVariableDefaultValue: "",
                        environmentVariableName: "",
                        placeholderVariableName: "",
                    });
                    break;
                case "env":
                    values.push({
                        kind: wundernode_config_1.ConfigurationVariableKind.ENV_CONFIGURATION_VARIABLE,
                        staticVariableContent: "",
                        environmentVariableDefaultValue: config.defaultValue || "",
                        environmentVariableName: config.value,
                        placeholderVariableName: "",
                    });
                    break;
            }
            headers[config.key] = {
                values,
            };
        });
        const schema = introspection.loadSchemaFromString ? (0, graphql_1.buildSchema)((0, typescript_1.loadFile)(introspection.loadSchemaFromString)) : await introspectGraphQLAPI(introspection.url, headers);
        const federationEnabled = (0, federation_1.isFederationService)(schema);
        const schemaSDL = (0, schema_1.cleanupSchema)(schema, introspection.customFloatScalars || [], introspection.customIntScalars || []);
        const serviceSDL = !federationEnabled ? undefined : await (0, federation_1.federationServiceSDL)((0, configure_1.resolveVariable)(introspection.url));
        const serviceDocumentNode = serviceSDL !== undefined ? (0, graphql_1.parse)(serviceSDL) : undefined;
        const schemaDocumentNode = (0, graphql_1.parse)(schemaSDL);
        const graphQLSchema = (0, graphql_1.buildSchema)(schemaSDL);
        const { RootNodes, ChildNodes, Fields } = (0, configuration_1.configuration)(schemaDocumentNode, serviceDocumentNode);
        const subscriptionsEnabled = hasSubscriptions(schema);
        return new GraphQLApi((0, namespacing_1.applyNameSpaceToGraphQLSchema)(schemaSDL, introspection.apiNamespace), [
            {
                Kind: wundernode_config_1.DataSourceKind.GRAPHQL,
                RootNodes: (0, namespacing_1.applyNameSpaceToTypeFields)(RootNodes, graphQLSchema, introspection.apiNamespace),
                ChildNodes: (0, namespacing_1.applyNameSpaceToTypeFields)(ChildNodes, graphQLSchema, introspection.apiNamespace),
                Custom: {
                    Fetch: {
                        url: (0, configure_1.mapInputVariable)(introspection.url),
                        method: wundernode_config_1.HTTPMethod.POST,
                        body: (0, configure_1.mapInputVariable)(""),
                        header: headers,
                        query: [],
                        upstreamAuthentication: (0, exports.buildUpstreamAuthentication)(introspection)
                    },
                    Subscription: {
                        Enabled: subscriptionsEnabled,
                        URL: introspection.subscriptionsURL !== undefined ?
                            (0, configure_1.mapInputVariable)(introspection.subscriptionsURL) :
                            typeof introspection.url === "string" ?
                                (0, configure_1.mapInputVariable)(subscriptionsURL(introspection.url)) :
                                (0, configure_1.mapInputVariable)(""),
                    },
                    Federation: {
                        Enabled: federationEnabled,
                        ServiceSDL: serviceSDL || "",
                    },
                    UpstreamSchema: schemaSDL,
                },
                Directives: (0, namespacing_1.applyNamespaceToDirectiveConfiguration)(schema, introspection.apiNamespace),
            }
        ], (0, namespacing_1.applyNameSpaceToFieldConfigurations)(Fields, graphQLSchema, introspection.apiNamespace), (0, namespacing_1.generateTypeConfigurationsForNamespace)(schemaSDL, introspection.apiNamespace));
    },
    postgresql: async (introspection) => {
        const { schema, fields, types, dataSource } = await introspectDatabase(introspection, "postgresql", 5);
        return new PostgresqlApi(schema, [dataSource], fields, types);
    },
    mysql: async (introspection) => {
        const { schema, fields, types, dataSource } = await introspectDatabase(introspection, "mysql", 5);
        return new MySQLApi(schema, [dataSource], fields, types);
    },
    planetscale: async (introspection) => {
        const { schema, fields, types, dataSource } = await introspectDatabase(introspection, "planetscale", 5);
        return new PlanetscaleApi(schema, [dataSource], fields, types);
    },
    sqlite: async (introspection) => {
        const { schema, fields, types, dataSource } = await introspectDatabase(introspection, "sqlite", 5);
        return new SQLiteApi(schema, [dataSource], fields, types);
    },
    sqlserver: async (introspection) => {
        const { schema, fields, types, dataSource } = await introspectDatabase(introspection, "sqlserver", 5);
        return new SQLServerApi(schema, [dataSource], fields, types);
    },
    federation: async (introspection) => {
        const graphQLIntrospections = introspection.upstreams.map(upstream => ({
            url: upstream.url,
            headers: upstream.headers,
            apiNamespace: introspection.apiNamespace,
        }));
        const apis = await Promise.all(graphQLIntrospections.map(i => exports.introspect.graphql(i)));
        return (0, merge_1.mergeApis)([], ...apis);
    },
    openApi: async (introspection) => {
        const spec = loadOpenApi(introspection);
        return await (0, v2openapi_1.openApiSpecificationToRESTApiObject)(spec, introspection);
    }
};
const buildUpstreamAuthentication = (upstream) => {
    if (upstream.authentication === undefined) {
        return undefined;
    }
    return {
        kind: upstreamAuthenticationKind(upstream.authentication.kind),
        jwtConfig: upstream.authentication.kind === "jwt" ? {
            secret: (0, configure_1.mapInputVariable)(upstream.authentication.secret),
            signingMethod: upstreamAuthenticationSigningMethod(upstream.authentication.signingMethod),
        } : undefined,
        jwtWithAccessTokenExchangeConfig: upstream.authentication.kind === "jwt_with_access_token_exchange" ? {
            accessTokenExchangeEndpoint: (0, configure_1.mapInputVariable)(upstream.authentication.accessTokenExchangeEndpoint),
            secret: (0, configure_1.mapInputVariable)(upstream.authentication.secret),
            signingMethod: upstreamAuthenticationSigningMethod(upstream.authentication.signingMethod),
        } : undefined,
    };
};
exports.buildUpstreamAuthentication = buildUpstreamAuthentication;
const upstreamAuthenticationSigningMethod = (signingMethod) => {
    switch (signingMethod) {
        case "HS256":
            return wundernode_config_1.SigningMethod.SigningMethodHS256;
        default:
            throw new Error(`JWT signing method unsupported: ${signingMethod}`);
    }
};
const upstreamAuthenticationKind = (kind) => {
    switch (kind) {
        case "jwt":
            return wundernode_config_1.UpstreamAuthenticationKind.UpstreamAuthenticationJWT;
        case "jwt_with_access_token_exchange":
            return wundernode_config_1.UpstreamAuthenticationKind.UpstreamAuthenticationJWTWithAccessTokenExchange;
        default:
            throw new Error(`upstreamAuthenticationKind, unsupported kind: ${kind}`);
    }
};
const introspectGraphQLAPI = async (url, headers) => {
    const data = JSON.stringify({
        query: (0, graphql_1.getIntrospectionQuery)(),
        operationName: "IntrospectionQuery"
    });
    const baseHeaders = {
        "Content-Type": "application/json",
        "Accept": "application/json",
    };
    if (headers !== undefined) {
        Object.keys(headers).forEach(key => {
            if (headers[key].values.length === 1) {
                switch (headers[key].values[0].kind) {
                    case wundernode_config_1.ConfigurationVariableKind.STATIC_CONFIGURATION_VARIABLE:
                        baseHeaders[key] = headers[key].values[0].staticVariableContent;
                        break;
                    case wundernode_config_1.ConfigurationVariableKind.ENV_CONFIGURATION_VARIABLE:
                        if (process.env[headers[key].values[0].environmentVariableName] !== undefined) {
                            baseHeaders[key] = process.env[headers[key].values[0].environmentVariableName];
                        }
                        else if (headers[key].values[0].environmentVariableDefaultValue !== undefined) {
                            baseHeaders[key] = headers[key].values[0].environmentVariableDefaultValue;
                        }
                        break;
                }
            }
        });
    }
    const res = await axios_1.default.post((0, configure_1.resolveVariable)(url), data, {
        headers: baseHeaders,
    });
    if (res.status !== 200) {
        return Promise.reject(`introspection failed, response code: ${res.status}, message: ${res.statusText}`);
    }
    return (0, graphql_1.buildClientSchema)(res.data.data);
};
const loadOpenApi = (introspection) => {
    switch (introspection.source.kind) {
        case "file":
            const filePath = path_1.default.resolve(process.cwd(), introspection.source.filePath);
            return fs.readFileSync(filePath).toString();
        case "object":
            return JSON.stringify(introspection.source.openAPIObject);
        case "string":
            return introspection.source.openAPISpec;
        default:
            return "";
    }
};
const hasSubscriptions = (schema) => {
    const subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
        return false;
    }
    const fields = subscriptionType.getFields();
    return Object.keys(fields).length !== 0;
};
const subscriptionsURL = (url) => url
    .replace("https://", "wss://")
    .replace("http://", "ws://");
