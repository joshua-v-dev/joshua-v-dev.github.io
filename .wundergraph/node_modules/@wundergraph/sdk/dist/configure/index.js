"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveIntegration = exports.parsePublishResultWithVariables = exports.configurePublishWunderGraphAPI = exports.configureWunderGraphApplication = exports.mapInputVariable = exports.resolveVariable = exports.PlaceHolder = exports.EnvironmentVariable = void 0;
const fs_1 = __importDefault(require("fs"));
const merge_1 = require("../definition/merge");
const dotgraphqlconfig_1 = require("../dotgraphqlconfig");
const operations_1 = require("../graphql/operations");
const codegen_1 = require("../codegen");
const wundernode_config_1 = require("@wundergraph/protobuf/dist/wundernode_config");
const version_1 = require("../version");
const linkbuilder_1 = require("../linkbuilder");
const graphql_1 = require("graphql");
const builder_1 = require("../postman/builder");
const path_1 = __importDefault(require("path"));
const object_hash_1 = __importDefault(require("object-hash"));
const namespacing_1 = require("../definition/namespacing");
class EnvironmentVariable {
    constructor(name, defaultValue) {
        this.name = name;
        this.defaultValue = defaultValue;
    }
}
exports.EnvironmentVariable = EnvironmentVariable;
class PlaceHolder {
    constructor(name) {
        this._identifier = 'placeholder';
        this.name = name;
    }
}
exports.PlaceHolder = PlaceHolder;
const resolveVariable = (variable) => {
    if (typeof variable === "string") {
        return variable;
    }
    const environmentVariable = variable;
    const resolved = process.env[environmentVariable.name];
    if (resolved) {
        return resolved;
    }
    return environmentVariable.defaultValue || "";
};
exports.resolveVariable = resolveVariable;
const resolveConfig = async (config) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const api = {
        id: "",
        name: "api"
    };
    const environment = {
        id: "",
        name: "localhost:9991",
    };
    const name = "main";
    const deploymentConfiguration = {
        api,
        environment,
        name,
        path: api.name + "/" + name,
    };
    const cors = {
        maxAge: config.cors.maxAge || 60,
        allowedHeaders: config.cors.allowedHeaders || [],
        allowedMethods: config.cors.allowedMethods || [],
        exposedHeaders: config.cors.exposedHeaders || [],
        allowCredentials: config.cors.allowCredentials || false,
        allowedOrigins: config.cors.allowedOrigins
            .map(origin => typeof origin === "string" && origin.endsWith("/") ? origin.substring(0, origin.length - 1) : origin)
            .map(exports.mapInputVariable),
    };
    const roles = ((_a = config.authorization) === null || _a === void 0 ? void 0 : _a.roles) || ["admin", "user"];
    const resolved = (await resolveApplications(roles, [config.application], cors, config.s3UploadProvider || []))[0];
    const cookieBasedAuthProviders = config.authentication !== undefined &&
        config.authentication.cookieBased !== undefined &&
        config.authentication.cookieBased.providers.map(provider => provider.resolve()) || [];
    const resolvedConfig = {
        application: resolved,
        deployment: deploymentConfiguration,
        sdkVersion: version_1.SDK_VERSION,
        authentication: {
            roles,
            cookieBased: cookieBasedAuthProviders,
            tokenBased: ((_c = (_b = config.authentication) === null || _b === void 0 ? void 0 : _b.tokenBased) === null || _c === void 0 ? void 0 : _c.providers) || [],
            authorizedRedirectUris: ((_f = (_e = (_d = config.authentication) === null || _d === void 0 ? void 0 : _d.cookieBased) === null || _e === void 0 ? void 0 : _e.authorizedRedirectUris) === null || _f === void 0 ? void 0 : _f.map(stringOrEnvironmentVariable => {
                if (typeof stringOrEnvironmentVariable === "string") {
                    const configVariable = {
                        kind: wundernode_config_1.ConfigurationVariableKind.STATIC_CONFIGURATION_VARIABLE,
                        environmentVariableDefaultValue: "",
                        environmentVariableName: "",
                        placeholderVariableName: "",
                        staticVariableContent: stringOrEnvironmentVariable
                    };
                    return configVariable;
                }
                const environmentVariable = stringOrEnvironmentVariable;
                const variable = {
                    kind: wundernode_config_1.ConfigurationVariableKind.ENV_CONFIGURATION_VARIABLE,
                    staticVariableContent: "",
                    placeholderVariableName: "",
                    environmentVariableDefaultValue: environmentVariable.defaultValue || "",
                    environmentVariableName: environmentVariable.name,
                };
                return variable;
            })) || [],
            authorizedRedirectUriRegexes: ((_j = (_h = (_g = config.authentication) === null || _g === void 0 ? void 0 : _g.cookieBased) === null || _h === void 0 ? void 0 : _h.authorizedRedirectUriRegexes) === null || _j === void 0 ? void 0 : _j.map(exports.mapInputVariable)) || [],
            hooks: {
                postAuthentication: ((_l = (_k = config.hooks) === null || _k === void 0 ? void 0 : _k.authentication) === null || _l === void 0 ? void 0 : _l.postAuthentication) !== undefined,
                mutatingPostAuthentication: ((_o = (_m = config.hooks) === null || _m === void 0 ? void 0 : _m.authentication) === null || _o === void 0 ? void 0 : _o.mutatingPostAuthentication) !== undefined,
                revalidateAuthentication: ((_q = (_p = config.hooks) === null || _p === void 0 ? void 0 : _p.authentication) === null || _q === void 0 ? void 0 : _q.revalidate) !== undefined,
            }
        },
        enableGraphQLEndpoint: ((_r = config.security) === null || _r === void 0 ? void 0 : _r.enableGraphQLEndpoint) === true,
        security: {
            additionalHosts: ((_t = (_s = config.security) === null || _s === void 0 ? void 0 : _s.allowedHosts) === null || _t === void 0 ? void 0 : _t.map(exports.mapInputVariable)) || [],
        }
    };
    if (config.links) {
        return addLinks(resolvedConfig, config.links);
    }
    return resolvedConfig;
};
const mapInputVariable = (stringOrEnvironmentVariable) => {
    if (typeof stringOrEnvironmentVariable === "string") {
        const configVariable = {
            kind: wundernode_config_1.ConfigurationVariableKind.STATIC_CONFIGURATION_VARIABLE,
            environmentVariableDefaultValue: "",
            environmentVariableName: "",
            placeholderVariableName: "",
            staticVariableContent: stringOrEnvironmentVariable,
        };
        return configVariable;
    }
    if (stringOrEnvironmentVariable._identifier === "placeholder") {
        const variable = {
            kind: wundernode_config_1.ConfigurationVariableKind.PLACEHOLDER_CONFIGURATION_VARIABLE,
            staticVariableContent: "",
            placeholderVariableName: stringOrEnvironmentVariable.name,
            environmentVariableDefaultValue: "",
            environmentVariableName: "",
        };
        return variable;
    }
    const environmentVariable = stringOrEnvironmentVariable;
    const variable = {
        kind: wundernode_config_1.ConfigurationVariableKind.ENV_CONFIGURATION_VARIABLE,
        staticVariableContent: "",
        placeholderVariableName: "",
        environmentVariableDefaultValue: environmentVariable.defaultValue || "",
        environmentVariableName: environmentVariable.name,
    };
    return variable;
};
exports.mapInputVariable = mapInputVariable;
const addLinks = (config, links) => {
    const schema = (0, graphql_1.buildSchema)(config.application.EngineConfiguration.Schema);
    const queryTypeName = (schema.getQueryType() || { name: "" }).name;
    const fields = (0, linkbuilder_1.queryTypeFields)(schema);
    links.forEach(link => {
        config = addLink(config, link, fields, queryTypeName);
    });
    return config;
};
const addLink = (config, link, fields, queryTypeName) => {
    const schema = (0, graphql_1.parse)(config.application.EngineConfiguration.Schema);
    let fieldInfo;
    config.application.EngineConfiguration.Schema = (0, graphql_1.print)((0, graphql_1.visit)(schema, {
        ObjectTypeDefinition: node => {
            if (node.name.value !== link.targetType) {
                return;
            }
            if ((node.fields || []).find(field => field.name.value === link.targetFieldName)) {
                return;
            }
            fieldInfo = fields.find(field => field.typeName === queryTypeName && field.fieldName === link.sourceField);
            if (fieldInfo === undefined) {
                return;
            }
            fieldInfo.arguments.forEach(expected => {
                const exists = link.argumentSources.find(actual => actual.name === expected.name) !== undefined;
                if (!exists) {
                    console.log(`configuration missing for argument: ${expected.name} on targetField: ${link.targetFieldName} on targetType: ${link.targetType}`);
                    console.log("please add '.argument(\"towerIds\", ...)' to the linkBuilder or the resolver will not be configured properly");
                }
            });
            const args = link
                .argumentSources
                .filter(arg => arg.type === "fieldArgument")
                .map(arg => {
                const argumentDefinition = fieldInfo.arguments.find(definition => definition.name === arg.name);
                if (argumentDefinition === undefined) {
                    throw Error(`argument with name ${arg.name} doesn't exist on source field: ${fieldInfo.fieldName}@${fieldInfo.typeName}`);
                }
                return {
                    kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: arg.name,
                    },
                    type: (0, graphql_1.parseType)(argumentDefinition.type),
                };
            });
            const field = {
                kind: graphql_1.Kind.FIELD_DEFINITION,
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: link.targetFieldName
                },
                type: (0, graphql_1.parseType)(fieldInfo.fieldType),
                arguments: args.length !== 0 ? args : undefined,
            };
            return {
                ...node,
                fields: [
                    ...node.fields || [],
                    field,
                ]
            };
        }
    }));
    if (fieldInfo !== undefined) {
        const fieldConfiguration = config.application.EngineConfiguration.Fields.find(field => field.typeName === fieldInfo.typeName && field.fieldName === fieldInfo.fieldName);
        if (fieldConfiguration === undefined) {
            throw new Error(`fieldConfiguration not found for type: ${fieldInfo.typeName}, field: ${fieldInfo.fieldName}`);
        }
        const copy = Object.assign({}, fieldConfiguration, {
            fieldName: link.targetFieldName,
            typeName: link.targetType,
            argumentsConfiguration: []
        });
        link.argumentSources.forEach(arg => {
            copy.argumentsConfiguration.push({
                name: arg.name,
                sourceType: arg.type === "objectField" ? wundernode_config_1.ArgumentSource.OBJECT_FIELD : wundernode_config_1.ArgumentSource.FIELD_ARGUMENT,
                sourcePath: arg.path,
                renderConfiguration: wundernode_config_1.ArgumentRenderConfiguration.RENDER_ARGUMENT_AS_GRAPHQL_VALUE,
            });
        });
        config.application.EngineConfiguration.Fields.push(copy);
        const dataSource = config.application.EngineConfiguration.DataSources.find(ds => ds.RootNodes.find(node => node.typeName === queryTypeName && node.fieldNames.find(field => field === link.sourceField)) !== undefined);
        if (dataSource === undefined) {
            throw new Error(`dataSource not found for type: ${fieldInfo.typeName}, field: ${fieldInfo.fieldName}`);
        }
        const ds = Object.assign({}, dataSource);
        ds.RootNodes = ds.RootNodes.map(node => {
            if (node.typeName === queryTypeName) {
                return {
                    typeName: link.targetType,
                    fieldNames: [...node.fieldNames.filter(field => field !== link.sourceField), link.targetFieldName]
                };
            }
            else {
                return node;
            }
        });
        ds.ChildNodes = ds.ChildNodes.map(node => {
            if (node.typeName === queryTypeName) {
                return {
                    typeName: link.targetType,
                    fieldNames: [...node.fieldNames.filter(field => field !== link.sourceField), link.targetFieldName]
                };
            }
            else {
                return node;
            }
        });
        const withUpdatedArguments = updateArguments(ds, fieldInfo, link);
        config.application.EngineConfiguration.DataSources.push(withUpdatedArguments);
    }
    return config;
};
const updateArguments = (dataSource, fieldInfo, link) => {
    let json = JSON.stringify(dataSource);
    fieldInfo.arguments.forEach(arg => {
        const source = link.argumentSources.find(source => source.name === arg.name);
        if (source === undefined) {
            return;
        }
        const search = `.arguments.${arg.name}`;
        const path = source.path.join(".");
        const replace = source.type === "objectField" ? `.object.${path}` : `.arguments.${path}`;
        json = json.replace(search, replace);
    });
    return JSON.parse(json);
};
const resolveApplications = async (roles, applications, cors, s3) => {
    const out = [];
    for (let i = 0; i < applications.length; i++) {
        const resolvedApis = await Promise.all(applications[i].apis);
        const merged = (0, merge_1.mergeApis)(roles, ...resolvedApis);
        out.push({
            Name: applications[i].name,
            EngineConfiguration: merged,
            EnableSingleFlight: true,
            Operations: [],
            CorsConfiguration: cors,
            S3UploadProvider: s3
        });
    }
    return out;
};
// configureWunderGraphApplication generates the file "generated/wundergraph.config.json" and runs the configured code generators
// the wundergraph.config.json file will be picked up by "wunderctl up" to configure your development environment
const configureWunderGraphApplication = (config) => {
    resolveConfig(config).then(async (resolved) => {
        var _a, _b, _c, _d;
        const app = resolved.application;
        const schemaFileName = `wundergraph.${app.Name}.schema.graphql`;
        const schemaContent = "# Code generated by \"wunderctl\"; DO NOT EDIT.\n\n" + app.EngineConfiguration.Schema;
        fs_1.default.writeFileSync(path_1.default.join("generated", schemaFileName), schemaContent, { encoding: "utf8" });
        done();
        console.log(`${new Date().toLocaleTimeString()}: ${schemaFileName} updated`);
        const operationsContent = (0, operations_1.loadOperations)();
        const operations = (0, operations_1.parseOperations)(app.EngineConfiguration.Schema, operationsContent.toString());
        app.Operations = operations.operations;
        if (app.Operations && config.operations !== undefined) {
            app.Operations = app.Operations.map(op => {
                const cfg = config.operations;
                const base = Object.assign({}, cfg.defaultConfig);
                const customize = (cfg.custom !== undefined && cfg.custom[op.Name] !== undefined) ? cfg.custom[op.Name] : undefined;
                switch (op.OperationType) {
                    case wundernode_config_1.OperationType.MUTATION:
                        let mutationConfig = cfg.mutations(base);
                        if (customize) {
                            mutationConfig = customize(mutationConfig);
                        }
                        return {
                            ...op,
                            AuthenticationConfig: {
                                ...op.AuthenticationConfig,
                                required: op.AuthenticationConfig.required || mutationConfig.authentication.required,
                            },
                        };
                    case wundernode_config_1.OperationType.QUERY:
                        let queryConfig = cfg.queries(base);
                        if (customize) {
                            queryConfig = customize(queryConfig);
                        }
                        return {
                            ...op,
                            CacheConfig: {
                                enable: queryConfig.caching.enable,
                                maxAge: queryConfig.caching.maxAge,
                                public: queryConfig.caching.public,
                                staleWhileRevalidate: queryConfig.caching.staleWhileRevalidate,
                            },
                            AuthenticationConfig: {
                                ...op.AuthenticationConfig,
                                required: op.AuthenticationConfig.required || queryConfig.authentication.required
                            },
                            LiveQuery: {
                                enable: queryConfig.liveQuery.enable,
                                pollingIntervalSeconds: queryConfig.liveQuery.pollingIntervalSeconds,
                            },
                        };
                    case wundernode_config_1.OperationType.SUBSCRIPTION:
                        let subscriptionConfig = cfg.subscriptions(base);
                        if (customize) {
                            subscriptionConfig = customize(subscriptionConfig);
                        }
                        return {
                            ...op,
                            AuthenticationConfig: {
                                ...op.AuthenticationConfig,
                                required: op.AuthenticationConfig.required || subscriptionConfig.authentication.required,
                            },
                        };
                    default:
                        return op;
                }
            });
        }
        for (const operationName in (_a = config.hooks) === null || _a === void 0 ? void 0 : _a.queries) {
            const hooks = config.hooks.queries[operationName];
            const op = app.Operations.find(op => op.OperationType === wundernode_config_1.OperationType.QUERY && op.Name === operationName);
            if (op !== undefined && hooks !== undefined) {
                op.HooksConfiguration.preResolve = hooks.preResolve !== undefined;
                op.HooksConfiguration.mockResolve = {
                    enable: hooks.mockResolve !== undefined,
                    subscriptionPollingIntervalMillis: 0
                };
                op.HooksConfiguration.postResolve = hooks.postResolve !== undefined;
                op.HooksConfiguration.mutatingPreResolve = hooks.mutatingPreResolve !== undefined;
                op.HooksConfiguration.mutatingPostResolve = hooks.mutatingPostResolve !== undefined;
            }
        }
        for (const operationName in (_b = config.hooks) === null || _b === void 0 ? void 0 : _b.mutations) {
            const hooks = config.hooks.mutations[operationName];
            const op = app.Operations.find(op => op.OperationType === wundernode_config_1.OperationType.MUTATION && op.Name === operationName);
            if (op !== undefined && hooks !== undefined) {
                op.HooksConfiguration.preResolve = hooks.preResolve !== undefined;
                op.HooksConfiguration.mockResolve = {
                    enable: hooks.mockResolve !== undefined,
                    subscriptionPollingIntervalMillis: 0
                };
                op.HooksConfiguration.postResolve = hooks.postResolve !== undefined;
                op.HooksConfiguration.mutatingPreResolve = hooks.mutatingPreResolve !== undefined;
                op.HooksConfiguration.mutatingPostResolve = hooks.mutatingPostResolve !== undefined;
            }
        }
        if (config.codeGenerators) {
            for (let i = 0; i < config.codeGenerators.length; i++) {
                const gen = config.codeGenerators[i];
                await (0, codegen_1.GenerateCode)({
                    wunderGraphConfig: resolved,
                    templates: gen.templates,
                    basePath: gen.path || "generated",
                });
            }
            done();
            console.log(`${new Date().toLocaleTimeString()}: Code generation completed.`);
        }
        fs_1.default.writeFileSync(path_1.default.join("generated", "wundergraph.config.json"), ResolvedWunderGraphConfigToJSON(resolved), { encoding: "utf8" });
        done();
        console.log(`${new Date().toLocaleTimeString()}: wundergraph.config.json updated`);
        const dotGraphQLNested = ((_c = config.dotGraphQLConfig) === null || _c === void 0 ? void 0 : _c.hasDotWunderGraphDirectory) !== undefined ? ((_d = config.dotGraphQLConfig) === null || _d === void 0 ? void 0 : _d.hasDotWunderGraphDirectory) === true : true;
        const dotGraphQLConfig = (0, dotgraphqlconfig_1.generateDotGraphQLConfig)(config, {
            baseURL: "http://localhost:9991",
            nested: dotGraphQLNested
        });
        const dotGraphQLConfigPath = path_1.default.join(dotGraphQLNested ? ".." + path_1.default.sep : "", ".graphqlconfig");
        let shouldUpdateDotGraphQLConfig = true;
        const dotGraphQLContent = JSON.stringify(dotGraphQLConfig, null, "  ");
        if (fs_1.default.existsSync(dotGraphQLConfigPath)) {
            const existingDotGraphQLContent = fs_1.default.readFileSync(dotGraphQLConfigPath, { encoding: "utf8" });
            if (dotGraphQLContent === existingDotGraphQLContent) {
                shouldUpdateDotGraphQLConfig = false;
            }
        }
        if (shouldUpdateDotGraphQLConfig) {
            fs_1.default.writeFileSync(dotGraphQLConfigPath, dotGraphQLContent, { encoding: "utf8" });
            console.log(`${new Date().toLocaleTimeString()}: .graphqlconfig updated`);
        }
        done();
        let shouldUpdatePostman = true;
        const operationsHash = (0, object_hash_1.default)(app.Operations).substring(0, 8);
        const operationsHashFile = path_1.default.join("generated", "operations_hash.txt");
        if (fs_1.default.existsSync(operationsHashFile)) {
            const existingOperationsHash = fs_1.default.readFileSync(operationsHashFile, { encoding: "utf8" });
            if (existingOperationsHash === operationsHash) {
                shouldUpdatePostman = false;
            }
        }
        fs_1.default.writeFileSync(operationsHashFile, operationsHash, { encoding: "utf8" });
        if (shouldUpdatePostman) {
            const postman = (0, builder_1.PostmanBuilder)(app.Operations, {
                baseURL: "http://localhost:9991",
            });
            fs_1.default.writeFileSync(path_1.default.join("generated", "wundergraph.postman.json"), JSON.stringify(postman.toJSON(), null, "  "), { encoding: "utf8" });
            console.log(`${new Date().toLocaleTimeString()}: wundergraph.postman.json updated`);
        }
        else {
            console.log(`${new Date().toLocaleTimeString()}: wundergraph.postman.json skipped`);
        }
        done();
    });
};
exports.configureWunderGraphApplication = configureWunderGraphApplication;
const total = 5;
let doneCount = 0;
const done = () => {
    doneCount++;
    console.log(`${new Date().toLocaleTimeString()}: ${doneCount}/${total} done`);
    if (doneCount === 3) {
        setTimeout(() => {
            console.log(`${new Date().toLocaleTimeString()}: code generation completed`);
            process.exit(0);
        }, 10);
    }
};
const ResolvedWunderGraphConfigToJSON = (config) => {
    const operations = config.application.Operations.map(op => ({
        content: (0, operations_1.removeHookVariables)(op.Content),
        name: op.Name,
        responseSchema: JSON.stringify(op.ResponseSchema),
        variablesSchema: JSON.stringify(op.VariablesSchema),
        operationType: op.OperationType,
        cacheConfig: op.CacheConfig || {
            enable: false,
            maxAge: 0,
            public: false,
            staleWhileRevalidate: 0,
        },
        authenticationConfig: {
            authRequired: op.AuthenticationConfig.required,
        },
        authorizationConfig: op.AuthorizationConfig,
        liveQueryConfig: op.LiveQuery,
        hooksConfiguration: op.HooksConfiguration,
        variablesConfiguration: op.VariablesConfiguration,
        internal: op.Internal,
    }));
    const dataSources = config.application.EngineConfiguration.DataSources.map(mapDataSource);
    const fields = config.application.EngineConfiguration.Fields;
    const types = config.application.EngineConfiguration.Types;
    const out = {
        apiName: config.deployment.api.name,
        apiId: config.deployment.api.id,
        deploymentName: config.deployment.name,
        environmentIds: [config.deployment.environment.id],
        api: {
            enableGraphqlEndpoint: false,
            operations: operations,
            engineConfiguration: {
                defaultFlushInterval: config.application.EngineConfiguration.DefaultFlushInterval,
                graphqlSchema: config.application.EngineConfiguration.Schema,
                datasourceConfigurations: dataSources,
                fieldConfigurations: fields,
                typeConfigurations: types,
            },
            s3UploadConfiguration: config.application.S3UploadProvider.map(provider => {
                return {
                    name: provider.name,
                    accessKeyID: (0, exports.mapInputVariable)(provider.accessKeyID),
                    bucketLocation: (0, exports.mapInputVariable)(provider.bucketLocation),
                    bucketName: (0, exports.mapInputVariable)(provider.bucketName),
                    endpoint: (0, exports.mapInputVariable)(provider.endpoint),
                    secretAccessKey: (0, exports.mapInputVariable)(provider.secretAccessKey),
                    useSSL: provider.useSSL,
                };
            }),
            corsConfiguration: config.application.CorsConfiguration,
            authenticationConfig: {
                cookieBased: {
                    providers: config.authentication.cookieBased,
                    authorizedRedirectUris: config.authentication.authorizedRedirectUris,
                    authorizedRedirectUriRegexes: config.authentication.authorizedRedirectUriRegexes,
                    blockKey: undefined,
                    hashKey: undefined,
                },
                hooks: config.authentication.hooks,
                jwksBased: {
                    providers: config.authentication.tokenBased.map(provider => ({
                        jwksJson: (0, exports.mapInputVariable)(provider.jwksJSON || ""),
                        jwksUrl: (0, exports.mapInputVariable)(provider.jwksURL || ""),
                        userInfoEndpoint: (0, exports.mapInputVariable)(provider.userInfoEndpoint || ""),
                        userInfoCacheTtlSeconds: provider.userInfoCacheTtlSeconds || 60 * 60,
                    }))
                }
            },
            additionalHostNames: config.security.additionalHosts,
        },
        dangerouslyEnableGraphQLEndpoint: config.enableGraphQLEndpoint,
    };
    return JSON.stringify(out, null, "  ");
};
const mapDataSource = (source) => {
    const out = {
        kind: source.Kind,
        customGraphql: undefined,
        rootNodes: source.RootNodes,
        childNodes: source.ChildNodes,
        customRest: undefined,
        customStatic: undefined,
        overrideFieldPathFromAlias: source.Kind === wundernode_config_1.DataSourceKind.GRAPHQL,
        customDatabase: undefined,
        directives: source.Directives,
    };
    switch (source.Kind) {
        case wundernode_config_1.DataSourceKind.REST:
            const rest = source.Custom;
            out.customRest = {
                fetch: rest.Fetch,
                subscription: {
                    enabled: rest.Subscription.Enabled,
                    pollingIntervalMillis: rest.Subscription.PollingIntervalMillis || 500,
                    skipPublishSameResponse: rest.Subscription.SkipPublishSameResponse || false,
                },
                defaultTypeName: rest.DefaultTypeName,
                statusCodeTypeMappings: rest.StatusCodeTypeMappings,
            };
            break;
        case wundernode_config_1.DataSourceKind.STATIC:
            const customStatic = source.Custom;
            out.customStatic = {
                data: customStatic.data,
            };
            break;
        case wundernode_config_1.DataSourceKind.GRAPHQL:
            const graphql = source.Custom;
            out.customGraphql = {
                fetch: graphql.Fetch,
                federation: {
                    enabled: graphql.Federation.Enabled,
                    serviceSdl: graphql.Federation.ServiceSDL,
                },
                subscription: {
                    enabled: graphql.Subscription.Enabled,
                    url: graphql.Subscription.URL,
                },
                upstreamSchema: graphql.UpstreamSchema,
            };
            break;
        case wundernode_config_1.DataSourceKind.POSTGRESQL:
        case wundernode_config_1.DataSourceKind.MYSQL:
        case wundernode_config_1.DataSourceKind.MONGODB:
        case wundernode_config_1.DataSourceKind.SQLSERVER:
        case wundernode_config_1.DataSourceKind.SQLITE:
            const database = source.Custom;
            out.customDatabase = {
                databaseURL: database.databaseURL,
                prismaSchema: database.prisma_schema,
                graphqlSchema: database.graphql_schema,
                closeTimeoutSeconds: 30,
            };
    }
    return out;
};
const configurePublishWunderGraphAPI = (configuration) => {
    const outFile = path_1.default.join("generated", `${configuration.organization}.${configuration.apiName}.api.json`);
    _configurePublishWunderGraphAPI(configuration, outFile).then(() => {
        console.log(`Successfully created ${outFile}`);
    }).catch(err => {
        console.error(`Failed to create publish configuration for ${configuration.organization}/${configuration.apiName}`);
        console.error(err);
    });
};
exports.configurePublishWunderGraphAPI = configurePublishWunderGraphAPI;
const _configurePublishWunderGraphAPI = async (configuration, outFile) => {
    const resolvedApis = await Promise.all(configuration.apis);
    const merged = (0, merge_1.mergeApis)([], ...resolvedApis);
    const markdownDescription = configuration.markdownDescriptionFile ? fs_1.default.readFileSync(configuration.markdownDescriptionFile, "utf-8") : "";
    const out = {
        organization: configuration.organization,
        apiName: configuration.apiName,
        title: configuration.title,
        keywords: configuration.keywords,
        shortDescription: configuration.shortDescription || "",
        markdownDescription,
        public: configuration.public,
        api: merged,
        placeHolders: [],
    };
    merged.Schema = (0, merge_1.removeBaseSchema)(merged.Schema);
    merged.Schema = (0, graphql_1.stripIgnoredCharacters)(merged.Schema);
    merged.DataSources = merged.DataSources.filter(ds => !(ds.Kind === wundernode_config_1.DataSourceKind.STATIC && ds.RootNodes.length === 1 && ds.RootNodes[0].fieldNames.length === 1 && ds.RootNodes[0].fieldNames[0] === "_join"));
    merged.Fields = merged.Fields.filter(field => !(field.fieldName === "_join"));
    const printed = JSON.stringify(out, (key, value) => {
        if (value !== undefined && value.kind === wundernode_config_1.ConfigurationVariableKind.PLACEHOLDER_CONFIGURATION_VARIABLE &&
            value.placeholderVariableName !== undefined) {
            out.placeHolders.push({
                name: value.placeholderVariableName,
                optional: false,
            });
        }
        if (value !== undefined && value.kind === wundernode_config_1.ConfigurationVariableKind.ENV_CONFIGURATION_VARIABLE &&
            value.environmentVariableName !== undefined) {
            out.placeHolders.push({
                name: value.environmentVariableName,
                optional: true,
            });
        }
        return value;
    });
    fs_1.default.writeFileSync(outFile, printed);
};
const parsePublishResultWithVariables = (raw, variables) => {
    return JSON.parse(raw, (key, value) => {
        if (value !== undefined &&
            value.kind === wundernode_config_1.ConfigurationVariableKind.ENV_CONFIGURATION_VARIABLE &&
            value.environmentVariableName !== undefined) {
            if (variables[value.environmentVariableName] !== undefined) {
                return (0, exports.mapInputVariable)(variables[value.environmentVariableName]);
            }
        }
        if (value !== undefined &&
            value.kind === wundernode_config_1.ConfigurationVariableKind.PLACEHOLDER_CONFIGURATION_VARIABLE &&
            value.placeholderVariableName !== undefined) {
            if (variables[value.placeholderVariableName] !== undefined) {
                return (0, exports.mapInputVariable)(variables[value.placeholderVariableName]);
            }
        }
        return value;
    });
};
exports.parsePublishResultWithVariables = parsePublishResultWithVariables;
const resolveIntegration = (rawApi, variables, apiNamespace) => {
    let published = (0, exports.parsePublishResultWithVariables)(rawApi, variables);
    if (apiNamespace) {
        return Promise.resolve((0, namespacing_1.applyNamespaceToApi)(published.api, apiNamespace));
    }
    return Promise.resolve(published.api);
};
exports.resolveIntegration = resolveIntegration;
