"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeHookVariables = exports.loadOperations = exports.operationResponseToJSONSchema = exports.operationVariablesToJSONSchema = exports.parseOperations = void 0;
const wundernode_config_1 = require("@wundergraph/protobuf/dist/wundernode_config");
const graphql_1 = require("graphql");
const path_1 = __importDefault(require("path"));
const wunderctlexec_1 = require("../wunderctlexec");
const defaultParseOptions = {
    keepFromClaimVariables: false,
};
const defaultVariableInjectionConfiguration = {
    environmentVariableName: "",
    dateFormat: "",
};
const parseOperations = (graphQLSchema, operationsDocument, options = defaultParseOptions) => {
    var _a;
    const parsedGraphQLSchema = (0, graphql_1.buildSchema)(graphQLSchema);
    const parsed = {
        operations: []
    };
    const wgRoleEnum = (_a = parsedGraphQLSchema.getType("WG_ROLE")) === null || _a === void 0 ? void 0 : _a.astNode;
    try {
        const ast = (0, graphql_1.parse)(operationsDocument);
        (0, graphql_1.visit)(ast, {
            OperationDefinition: {
                enter: node => {
                    var _a, _b, _c, _d;
                    const operationName = (node.name || { value: "" }).value;
                    const content = (0, graphql_1.print)(node);
                    const parsedOperation = (0, graphql_1.parse)(content);
                    const errors = (0, graphql_1.validate)(parsedGraphQLSchema, parsedOperation);
                    if (errors.length > 0) {
                        console.log("\n\n");
                        console.log(`Error parsing operation ${operationName}: ${errors.join("\n")}`);
                        console.log("Skipping operation\n\n");
                        return;
                    }
                    const operation = {
                        Name: operationName,
                        Content: content,
                        OperationType: parseOperationTypeNode(node.operation),
                        VariablesSchema: (0, exports.operationVariablesToJSONSchema)(parsedGraphQLSchema, node, 2, options.keepFromClaimVariables),
                        InternalVariablesSchema: (0, exports.operationVariablesToJSONSchema)(parsedGraphQLSchema, node, 2, true),
                        InjectedVariablesSchema: (0, exports.operationVariablesToJSONSchema)(parsedGraphQLSchema, node, 2, true, true),
                        ResponseSchema: (0, exports.operationResponseToJSONSchema)(parsedGraphQLSchema, ast, node),
                        AuthenticationConfig: {
                            required: false,
                        },
                        AuthorizationConfig: {
                            claims: [],
                            roleConfig: {
                                requireMatchAll: [],
                                requireMatchAny: [],
                                denyMatchAll: [],
                                denyMatchAny: [],
                            }
                        },
                        HooksConfiguration: {
                            preResolve: false,
                            postResolve: false,
                            mutatingPreResolve: false,
                            mutatingPostResolve: false,
                            mockResolve: {
                                enable: false,
                                subscriptionPollingIntervalMillis: 0,
                            }
                        },
                        VariablesConfiguration: {
                            injectVariables: [],
                        },
                        Internal: false,
                    };
                    (_a = node.variableDefinitions) === null || _a === void 0 ? void 0 : _a.forEach(variable => {
                        handleFromClaimDirective(variable, operation);
                        handleJsonSchemaDirective(variable, operation);
                        handleUuidDirective(variable, operation);
                        handleDateTimeDirective(variable, operation);
                        handleInjectEnvironmentVariableDirective(variable, operation);
                    });
                    operation.Internal = ((_b = node.directives) === null || _b === void 0 ? void 0 : _b.find(d => d.name.value === "internalOperation")) !== undefined;
                    if (wgRoleEnum && wgRoleEnum.kind === "EnumTypeDefinition") {
                        const rbac = (_c = node.directives) === null || _c === void 0 ? void 0 : _c.find(d => d.name.value === "rbac");
                        (_d = rbac === null || rbac === void 0 ? void 0 : rbac.arguments) === null || _d === void 0 ? void 0 : _d.forEach(arg => {
                            if (arg.value.kind !== "ListValue") {
                                return;
                            }
                            const values = arg.value.values.map(v => {
                                if (v.kind !== "EnumValue") {
                                    return "";
                                }
                                return v.value;
                            }).filter(v => { var _a; return ((_a = wgRoleEnum.values) === null || _a === void 0 ? void 0 : _a.find(n => n.name.value === v)) !== undefined; });
                            switch (arg.name.value) {
                                case "requireMatchAll":
                                    operation.AuthorizationConfig.roleConfig.requireMatchAll = [...new Set([...operation.AuthorizationConfig.roleConfig.requireMatchAll, ...values])];
                                    return;
                                case "requireMatchAny":
                                    operation.AuthorizationConfig.roleConfig.requireMatchAny = [...new Set([...operation.AuthorizationConfig.roleConfig.requireMatchAny, ...values])];
                                    return;
                                case "denyMatchAll":
                                    operation.AuthorizationConfig.roleConfig.denyMatchAll = [...new Set([...operation.AuthorizationConfig.roleConfig.denyMatchAll, ...values])];
                                    return;
                                case "denyMatchAny":
                                    operation.AuthorizationConfig.roleConfig.denyMatchAny = [...new Set([...operation.AuthorizationConfig.roleConfig.denyMatchAny, ...values])];
                                    return;
                            }
                        });
                    }
                    if (operation.AuthorizationConfig.roleConfig.denyMatchAny.length +
                        operation.AuthorizationConfig.roleConfig.denyMatchAll.length +
                        operation.AuthorizationConfig.roleConfig.requireMatchAll.length +
                        operation.AuthorizationConfig.roleConfig.requireMatchAny.length !== 0) {
                        operation.AuthenticationConfig.required = true;
                    }
                    if (operation.AuthorizationConfig.claims.length !== 0) {
                        operation.AuthenticationConfig.required = true;
                    }
                    parsed.operations.push(operation);
                }
            }
        });
    }
    catch (e) {
        console.log("");
        console.log("--->");
        console.log("No Operations found! Please create at least one Operation in the directory ./operations");
        console.log("Operation files must have the file extension '.graphql', otherwise they are ignored.");
        console.log("Operations don't need to be named, the file name is responsible for the operation name.");
        console.log("<---");
        console.log("");
    }
    return parsed;
};
exports.parseOperations = parseOperations;
const handleJsonSchemaDirective = (variable, operation) => {
    var _a;
    const variableName = variable.variable.name.value;
    const directive = (_a = variable.directives) === null || _a === void 0 ? void 0 : _a.find(directive => directive.name.value === "jsonSchema");
    if (directive === undefined || directive.arguments === undefined) {
        return;
    }
    const schema = operation.VariablesSchema.properties && operation.VariablesSchema.properties[variableName];
    if (schema === undefined || typeof schema === "boolean") {
        return;
    }
    directive.arguments.forEach(arg => {
        switch (arg.name.value) {
            case "title":
                if (arg.value.kind === "StringValue") {
                    schema.title = arg.value.value;
                }
                return;
            case "description":
                if (arg.value.kind === "StringValue") {
                    schema.description = arg.value.value;
                }
                return;
            case "multipleOf":
                if (arg.value.kind === "IntValue") {
                    schema.multipleOf = parseInt(arg.value.value, 10);
                }
                return;
            case "maximum":
                if (arg.value.kind === "IntValue")
                    schema.maximum = parseInt(arg.value.value, 10);
                return;
            case "exclusiveMaximum":
                if (arg.value.kind === "IntValue") {
                    schema.exclusiveMaximum = parseInt(arg.value.value, 10);
                }
                return;
            case "minimum":
                if (arg.value.kind === "IntValue") {
                    schema.minimum = parseInt(arg.value.value, 10);
                }
                return;
            case "exclusiveMinimum":
                if (arg.value.kind === "IntValue") {
                    schema.exclusiveMinimum = parseInt(arg.value.value, 10);
                }
                return;
            case "maxLength":
                if (arg.value.kind === "IntValue") {
                    schema.maxLength = parseInt(arg.value.value, 10);
                }
                return;
            case "minLength":
                if (arg.value.kind === "IntValue") {
                    schema.minLength = parseInt(arg.value.value, 10);
                }
                return;
            case "pattern":
                if (arg.value.kind === "StringValue") {
                    schema.pattern = arg.value.value;
                }
                return;
            case "maxItems":
                if (arg.value.kind === "IntValue") {
                    schema.maxItems = parseInt(arg.value.value, 10);
                }
                return;
            case "minItems":
                if (arg.value.kind === "IntValue") {
                    schema.minItems = parseInt(arg.value.value, 10);
                }
                return;
            case "uniqueItems":
                if (arg.value.kind === "BooleanValue") {
                    schema.uniqueItems = arg.value.value;
                }
                return;
            case "commonPattern":
                if (arg.value.kind === "EnumValue") {
                    switch (arg.value.value) {
                        case "EMAIL":
                            schema.pattern = "(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\\\[\x01-\x09\x0b\x0c\x0e-\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\\])";
                            return;
                        case "DOMAIN":
                            schema.pattern = "^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$";
                            return;
                        case "URL":
                            schema.pattern = "/(((http|ftp|https):\\/{2})+(([0-9a-z_-]+\\.)+(aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mn|mn|mo|mp|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|nom|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ra|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw|arpa)(:[0-9]+)?((\\/([~0-9a-zA-Z\\#\\+\\%@\\.\\/_-]+))?(\\?[0-9a-zA-Z\\+\\%@\\/&\\[\\];=_-]+)?)?))\\b/imuS\n";
                            return;
                    }
                }
                return;
        }
    });
};
const handleFromClaimDirective = (variable, operation) => {
    var _a;
    const variableName = variable.variable.name.value;
    const fromClaimDirective = (_a = variable.directives) === null || _a === void 0 ? void 0 : _a.find(directive => directive.name.value === "fromClaim");
    if (fromClaimDirective === undefined || fromClaimDirective.arguments === undefined) {
        return;
    }
    const nameArg = fromClaimDirective.arguments.find(arg => arg.name.value === "name");
    if (nameArg === undefined) {
        return;
    }
    if (nameArg.value.kind !== "EnumValue") {
        return;
    }
    const name = nameArg.value.value;
    switch (name) {
        case "EMAIL":
            operation.AuthenticationConfig.required = true;
            operation.AuthorizationConfig.claims.push({
                variableName,
                claim: wundernode_config_1.Claim.EMAIL
            });
            break;
        case "EMAIL_VERIFIED":
            operation.AuthenticationConfig.required = true;
            operation.AuthorizationConfig.claims.push({
                variableName,
                claim: wundernode_config_1.Claim.EMAIL_VERIFIED
            });
            break;
        case "NAME":
            operation.AuthenticationConfig.required = true;
            operation.AuthorizationConfig.claims.push({
                variableName,
                claim: wundernode_config_1.Claim.NAME
            });
            break;
        case "NICKNAME":
            operation.AuthenticationConfig.required = true;
            operation.AuthorizationConfig.claims.push({
                variableName,
                claim: wundernode_config_1.Claim.NICKNAME
            });
            break;
        case "LOCATION":
            operation.AuthenticationConfig.required = true;
            operation.AuthorizationConfig.claims.push({
                variableName,
                claim: wundernode_config_1.Claim.LOCATION
            });
            break;
        case "PROVIDER":
            operation.AuthenticationConfig.required = true;
            operation.AuthorizationConfig.claims.push({
                variableName,
                claim: wundernode_config_1.Claim.PROVIDER
            });
            break;
    }
};
const handleInjectEnvironmentVariableDirective = (variable, operation) => {
    var _a, _b;
    const variableName = variable.variable.name.value;
    const directive = (_a = variable.directives) === null || _a === void 0 ? void 0 : _a.find(directive => directive.name.value === "injectEnvironmentVariable");
    if (directive === undefined) {
        return;
    }
    const arg = (_b = directive.arguments) === null || _b === void 0 ? void 0 : _b.find(arg => arg.name.value === "name");
    if (arg === undefined || arg.value.kind !== graphql_1.Kind.STRING) {
        return;
    }
    operation.VariablesConfiguration.injectVariables.push({
        ...defaultVariableInjectionConfiguration,
        variableName,
        variableKind: wundernode_config_1.InjectVariableKind.ENVIRONMENT_VARIABLE,
        environmentVariableName: arg.value.value,
    });
};
const handleUuidDirective = (variable, operation) => {
    var _a;
    const variableName = variable.variable.name.value;
    const directive = (_a = variable.directives) === null || _a === void 0 ? void 0 : _a.find(directive => directive.name.value === "injectGeneratedUUID");
    if (directive === undefined) {
        return;
    }
    operation.VariablesConfiguration.injectVariables.push({
        ...defaultVariableInjectionConfiguration,
        variableName,
        variableKind: wundernode_config_1.InjectVariableKind.UUID,
    });
};
const handleDateTimeDirective = (variable, operation) => {
    var _a, _b, _c;
    const variableName = variable.variable.name.value;
    const directive = (_a = variable.directives) === null || _a === void 0 ? void 0 : _a.find(directive => directive.name.value === "injectCurrentDateTime");
    if (directive === undefined) {
        return;
    }
    const formatArg = (_b = directive.arguments) === null || _b === void 0 ? void 0 : _b.find(arg => arg.name.value === "format");
    if (formatArg !== undefined && formatArg.value.kind === "EnumValue") {
        const format = formatArg.value.value;
        switch (format) {
            case "ISO8601":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "2006-01-02T15:04:05Z07:00",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME,
                });
                return;
            case "ANSIC":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "Mon Jan _2 15:04:05 2006",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
            case "UnixDate":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "Mon Jan _2 15:04:05 MST 2006",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
            case "RubyDate":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "Mon Jan 02 15:04:05 -0700 2006",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
            case "RFC822":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "02 Jan 06 15:04 MST",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
            case "RFC822Z":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "02 Jan 06 15:04 -0700",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
            case "RFC850":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "Monday, 02-Jan-06 15:04:05 MST",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
            case "RFC1123":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "Mon, 02 Jan 2006 15:04:05 MST",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
            case "RFC1123Z":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "Mon, 02 Jan 2006 15:04:05 -0700",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
            case "RFC3339":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "2006-01-02T15:04:05Z07:00",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
            case "RFC3339Nano":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "2006-01-02T15:04:05.999999999Z07:00",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
            case "Kitchen":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "3:04PM",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
            case "Stamp":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "Jan _2 15:04:05",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
            case "StampMilli":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "Jan _2 15:04:05.000",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
            case "StampMicro":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "Jan _2 15:04:05.000000",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
            case "StampNano":
                operation.VariablesConfiguration.injectVariables.push({
                    ...defaultVariableInjectionConfiguration,
                    variableName,
                    dateFormat: "Jan _2 15:04:05.000000000",
                    variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
                });
                return;
        }
    }
    const customFormatArg = (_c = directive.arguments) === null || _c === void 0 ? void 0 : _c.find(arg => arg.name.value === "customFormat");
    if (customFormatArg !== undefined && customFormatArg.value.kind === "StringValue") {
        operation.VariablesConfiguration.injectVariables.push({
            ...defaultVariableInjectionConfiguration,
            variableName,
            dateFormat: customFormatArg.value.value,
            variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
        });
        return;
    }
    operation.VariablesConfiguration.injectVariables.push({
        ...defaultVariableInjectionConfiguration,
        variableName,
        dateFormat: "2006-01-02T15:04:05Z07:00",
        variableKind: wundernode_config_1.InjectVariableKind.DATE_TIME
    });
};
const parseOperationTypeNode = (node) => {
    switch (node) {
        case "subscription":
            return wundernode_config_1.OperationType.SUBSCRIPTION;
        case "mutation":
            return wundernode_config_1.OperationType.MUTATION;
        case "query":
            return wundernode_config_1.OperationType.QUERY;
        default:
            return -1;
    }
};
const operationVariablesToJSONSchema = (graphQLSchema, operation, maxDepth = 2, keepInternalVariables = false, keepInjectedVariables = false) => {
    const schema = {
        type: "object",
        properties: {},
        additionalProperties: false,
    };
    if (!operation.variableDefinitions) {
        return schema;
    }
    operation.variableDefinitions.forEach(variable => {
        if (!keepInternalVariables && hasInternalVariable(variable)) {
            return;
        }
        if (!keepInjectedVariables && hasInjectedVariable(variable)) {
            return;
        }
        let type = variable.type;
        if (type.kind === "NonNullType" && variable.defaultValue !== undefined) {
            type = type.type;
        }
        const name = variable.variable.name.value;
        schema.properties[name] = typeSchema(schema, graphQLSchema, maxDepth, 0, type, name);
    });
    return schema;
};
exports.operationVariablesToJSONSchema = operationVariablesToJSONSchema;
const internalVariables = [
    "fromClaim",
    "internal",
    "injectGeneratedUUID",
    "injectCurrentDateTime",
    "injectEnvironmentVariable",
];
const injectedVariables = [
    "injectGeneratedUUID",
    "injectCurrentDateTime",
    "injectEnvironmentVariable",
];
const hasInternalVariable = (variable) => {
    var _a;
    return ((_a = variable.directives) === null || _a === void 0 ? void 0 : _a.find(directive => internalVariables.find(i => i === directive.name.value) !== undefined)) !== undefined;
};
const hasInjectedVariable = (variable) => {
    var _a;
    return ((_a = variable.directives) === null || _a === void 0 ? void 0 : _a.find(directive => injectedVariables.find(i => i === directive.name.value) !== undefined)) !== undefined;
};
const typeSchema = (parent, graphQLSchema, maxDepth, depth, type, name) => {
    switch (type.kind) {
        case "NonNullType":
            switch (parent.type) {
                case "object":
                    parent.required = [...parent.required || [], name];
                    break;
                case "array":
                    parent.minItems = 1;
                    break;
            }
            return typeSchema(parent, graphQLSchema, maxDepth, depth, type.type, name);
        case "ListType":
            const schema = {
                type: "array",
            };
            schema.items = typeSchema(schema, graphQLSchema, maxDepth, depth, type.type, name);
            return schema;
        case "NamedType":
            switch (type.name.value) {
                case 'Int':
                    return {
                        type: "integer"
                    };
                case 'Boolean':
                    return {
                        type: "boolean"
                    };
                case 'ID':
                    return {
                        type: "string"
                    };
                case 'Float':
                    return {
                        type: "number"
                    };
                case 'String':
                    return {
                        type: "string"
                    };
                default:
                    let schema = {};
                    const namedType = graphQLSchema.getType(type.name.value);
                    if (namedType === null || namedType === undefined || !namedType.astNode) {
                        return {};
                    }
                    if (depth > maxDepth) {
                        return {};
                    }
                    switch (namedType.astNode.kind) {
                        case "ScalarTypeDefinition":
                            return {
                                type: "string",
                            };
                        case "EnumTypeDefinition":
                            schema.type = "string";
                            schema.enum = (namedType.astNode.values || []).map(e => {
                                return e.name.value;
                            });
                            break;
                        case "InputObjectTypeDefinition":
                            schema.additionalProperties = false;
                            schema.type = "object";
                            schema.properties = {};
                            (namedType.astNode.fields || []).forEach(f => {
                                const name = f.name.value;
                                let fieldType = f.type;
                                if (f.defaultValue !== undefined && fieldType.kind === "NonNullType") {
                                    fieldType = fieldType.type;
                                }
                                schema.properties[name] = typeSchema(schema, graphQLSchema, maxDepth, depth + 1, fieldType, name);
                            });
                            break;
                    }
                    return schema;
            }
    }
    return {};
};
const operationResponseToJSONSchema = (graphQLSchema, operationDocument, operationNode) => {
    const dataSchema = {
        type: "object",
        properties: {},
        additionalProperties: false,
    };
    const schema = {
        type: "object",
        properties: {
            "data": dataSchema,
        },
        additionalProperties: false,
    };
    const typeName = operationRootTypeName(operationNode, graphQLSchema);
    resolveSelections(graphQLSchema, operationDocument, operationNode.selectionSet.selections, typeName, dataSchema);
    return schema;
};
exports.operationResponseToJSONSchema = operationResponseToJSONSchema;
const operationRootTypeName = (node, graphQLSchema) => {
    switch (node.operation) {
        case "query":
            return (graphQLSchema.getQueryType() || {}).name || "";
        case "mutation":
            return (graphQLSchema.getMutationType() || {}).name || "";
        case "subscription":
            return (graphQLSchema.getSubscriptionType() || {}).name || "";
        default:
            return "";
    }
};
const resolveSelections = (graphQLSchema, operationDocument, selections, parentTypeName, parentObject) => {
    const parentType = graphQLSchema.getType(parentTypeName);
    if (!parentType || !parentType.astNode) {
        return;
    }
    if (parentType.astNode.kind === "UnionTypeDefinition") {
        selections.forEach(selection => {
            switch (selection.kind) {
                case "Field":
                    const fieldName = selection.name.value;
                    const propName = selection.alias !== undefined ? selection.alias.value : selection.name.value;
                    if (fieldName !== "__typename") {
                        return;
                    }
                    parentObject.properties[propName] = {
                        type: "string"
                    };
                    return;
                case "InlineFragment":
                    if (!selection.typeCondition) {
                        return;
                    }
                    const typeName = selection.typeCondition.name.value;
                    resolveSelections(graphQLSchema, operationDocument, selection.selectionSet.selections, typeName, parentObject);
                    delete parentObject.required; // union root fields are always optional
                    return;
                case "FragmentSpread":
                    const fragmentDefinition = operationDocument.definitions.find(node => node.kind === "FragmentDefinition" && node.name.value === selection.name.value);
                    if (fragmentDefinition) {
                        const typeName = fragmentDefinition.typeCondition.name.value;
                        const selections = fragmentDefinition.selectionSet.selections;
                        resolveSelections(graphQLSchema, operationDocument, selections, typeName, parentObject);
                        delete parentObject.required; // union root fields are always optional
                        return;
                    }
            }
        });
        return;
    }
    if ((parentType.astNode.kind !== "ObjectTypeDefinition" && parentType.astNode.kind !== "InterfaceTypeDefinition") || !parentType.astNode.fields) {
        return;
    }
    selections.forEach(selection => {
        switch (selection.kind) {
            case "Field":
                const fieldName = selection.name.value;
                const propName = selection.alias !== undefined ? selection.alias.value : selection.name.value;
                const definition = parentType.astNode.fields.find(f => f.name.value === fieldName);
                if (!definition) {
                    return;
                }
                const schema = resolveFieldSchema(graphQLSchema, operationDocument, propName, selection, definition.type, parentObject);
                parentObject.properties[propName] = schema;
                break;
            case "FragmentSpread":
                const fragmentDefinition = operationDocument.definitions.find(node => node.kind === "FragmentDefinition" && node.name.value === selection.name.value);
                resolveSelections(graphQLSchema, operationDocument, fragmentDefinition.selectionSet.selections, parentTypeName, parentObject);
                break;
            case "InlineFragment":
                resolveSelections(graphQLSchema, operationDocument, selection.selectionSet.selections, parentTypeName, parentObject);
                break;
        }
    });
};
const resolveFieldSchema = (graphQLSchema, operationDocument, propName, field, fieldType, parent) => {
    switch (fieldType.kind) {
        case "NonNullType":
            switch (parent.type) {
                case "object":
                    parent.required = [...new Set([...parent.required || [], propName])];
                    return resolveFieldSchema(graphQLSchema, operationDocument, propName, field, fieldType.type, parent);
                case "array":
                    parent.minItems = 1;
                    return resolveFieldSchema(graphQLSchema, operationDocument, propName, field, fieldType.type, parent);
                default:
                    return {};
            }
        case "ListType":
            return {
                type: "array",
                items: resolveFieldSchema(graphQLSchema, operationDocument, propName, field, fieldType.type, parent)
            };
        case "NamedType":
            switch (fieldType.name.value) {
                case 'Int':
                    return {
                        type: "integer"
                    };
                case 'Boolean':
                    return {
                        type: "boolean"
                    };
                case 'ID':
                    return {
                        type: "string"
                    };
                case 'Float':
                    return {
                        type: "number"
                    };
                case 'String':
                    return {
                        type: "string"
                    };
                default:
                    let schema = {};
                    const namedType = graphQLSchema.getType(fieldType.name.value);
                    if (namedType === null || namedType === undefined || !namedType.astNode) {
                        return {};
                    }
                    switch (namedType.astNode.kind) {
                        case "ScalarTypeDefinition":
                            return {
                                type: "string",
                            };
                        case "EnumTypeDefinition":
                            schema.type = "string";
                            schema.enum = (namedType.astNode.values || []).map(e => {
                                return e.name.value;
                            });
                            break;
                        case "UnionTypeDefinition":
                        case "InterfaceTypeDefinition":
                        case "ObjectTypeDefinition":
                            schema.type = "object";
                            schema.properties = {};
                            schema.additionalProperties = false;
                            if (!field.selectionSet) {
                                return schema;
                            }
                            resolveSelections(graphQLSchema, operationDocument, field.selectionSet.selections, namedType.name, schema);
                            break;
                    }
                    return schema;
            }
    }
    return {};
};
const loadOperations = () => {
    var _a, _b, _c;
    const operationsPath = path_1.default.join(process.cwd(), "operations");
    const result = (0, wunderctlexec_1.wunderctlExec)({
        cmd: ["loadoperations", operationsPath]
    });
    if (result === undefined || result.status !== 0) {
        return "";
    }
    const output = result.output.join("");
    const out = JSON.parse(output);
    (_a = out.info) === null || _a === void 0 ? void 0 : _a.forEach(info => console.log(JSON.stringify({ "level": "info", "message": info })));
    (_b = out.errors) === null || _b === void 0 ? void 0 : _b.forEach(info => console.log(JSON.stringify({ "level": "error", "message": info })));
    return ((_c = out.files) === null || _c === void 0 ? void 0 : _c.map(file => file.content).join(" ")) || "";
};
exports.loadOperations = loadOperations;
const removeHookVariables = (operation) => {
    const document = (0, graphql_1.parse)(operation);
    const updated = (0, graphql_1.visit)(document, {
        VariableDefinition: node => {
            var _a;
            const isHooksVariable = ((_a = node.directives) === null || _a === void 0 ? void 0 : _a.find(d => d.name.value === "hooksVariable")) !== undefined;
            if (isHooksVariable) {
                return null;
            }
            return node;
        }
    });
    return (0, graphql_1.print)(updated);
};
exports.removeHookVariables = removeHookVariables;
