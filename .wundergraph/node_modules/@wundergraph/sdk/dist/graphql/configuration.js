"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRootType = exports.configuration = void 0;
const graphql_1 = require("graphql");
const wundernode_config_1 = require("@wundergraph/protobuf/dist/wundernode_config");
const configuration = (schema, serviceSDL) => {
    const config = {
        RootNodes: [],
        ChildNodes: [],
        Fields: [],
        Types: [],
    };
    if (serviceSDL !== undefined) {
        visitSchema(serviceSDL, config);
    }
    else {
        visitSchema(schema, config);
    }
    return config;
};
exports.configuration = configuration;
const visitSchema = (schema, config) => {
    let typeName;
    let fieldName;
    let isExtensionType = false;
    let hasExtensionDirective = false;
    let isEntity = false;
    let isExternalField = false;
    let entityFields = [];
    const graphQLSchema = (0, graphql_1.buildASTSchema)(schema, { assumeValidSDL: true });
    (0, graphql_1.visit)(schema, {
        ObjectTypeDefinition: {
            enter: node => {
                typeName = node.name.value;
                isExtensionType = false;
                isEntity = false;
            },
            leave: () => {
                typeName = undefined;
                isExtensionType = false;
                hasExtensionDirective = false;
                entityFields = [];
                isEntity = false;
            }
        },
        ObjectTypeExtension: {
            enter: node => {
                typeName = node.name.value;
                isExtensionType = true;
                isEntity = false;
            },
            leave: () => {
                typeName = undefined;
                isExtensionType = false;
                hasExtensionDirective = false;
                entityFields = [];
            }
        },
        Directive: {
            enter: node => {
                switch (node.name.value) {
                    case "extends":
                        hasExtensionDirective = true;
                        return;
                    case "key":
                        isEntity = true;
                        if (!node.arguments) {
                            return;
                        }
                        const fields = node.arguments.find(arg => arg.name.value === "fields");
                        if (!fields) {
                            return;
                        }
                        if (fields.value.kind !== "StringValue") {
                            return;
                        }
                        const fieldsValue = fields.value.value;
                        const fieldsSelection = parseSelectionSet("{ " + fieldsValue + " }");
                        fieldsSelection.selections.forEach(s => {
                            if (s.kind !== "Field") {
                                return;
                            }
                            entityFields.push(s.name.value);
                        });
                        return;
                    case "external":
                        isExternalField = true;
                }
            }
        },
        FieldDefinition: {
            enter: node => {
                fieldName = node.name.value;
            },
            leave: () => {
                if (typeName === undefined || fieldName === undefined) {
                    return;
                }
                const isRoot = (0, exports.isRootType)(typeName, graphQLSchema);
                if (isRoot) {
                    addTypeField(config.RootNodes, typeName, fieldName);
                }
                const isExtension = isExtensionType || hasExtensionDirective;
                const isFederationRootNode = isExtension && isEntity && !isExternalField;
                const isEntityField = entityFields.find(f => f === fieldName) !== undefined;
                if (isEntity && !isExternalField) {
                    addTypeField(config.RootNodes, typeName, fieldName);
                }
                if (isFederationRootNode) {
                    addTypeField(config.RootNodes, typeName, fieldName);
                    addRequiredFields(typeName, fieldName, config, entityFields);
                }
                if (!isRoot && !isFederationRootNode && !isExternalField) {
                    addTypeField(config.ChildNodes, typeName, fieldName);
                }
                if (isExternalField && isEntityField) {
                    addTypeField(config.ChildNodes, typeName, fieldName);
                }
                fieldName = undefined;
                isExternalField = false;
            }
        },
        InputValueDefinition: {
            enter: node => {
                if (!fieldName || !typeName) {
                    return;
                }
                addFieldArgument(typeName, fieldName, node.name.value, config);
            }
        }
    });
};
const parseSelectionSet = (selectionSet) => {
    const query = (0, graphql_1.parse)(selectionSet).definitions[0];
    return query.selectionSet;
};
const isRootType = (typeName, schema) => {
    const queryType = schema.getQueryType();
    if (queryType && queryType.astNode && queryType.astNode.name.value === typeName) {
        return true;
    }
    const mutationType = schema.getMutationType();
    if (mutationType && mutationType.astNode && mutationType.astNode.name.value === typeName) {
        return true;
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType && subscriptionType.astNode && subscriptionType.astNode.name.value === typeName) {
        return true;
    }
    const typeDefinition = schema.getType(typeName);
    if (typeDefinition === undefined || typeDefinition === null || typeDefinition.astNode === undefined || typeDefinition.astNode === null) {
        return;
    }
    return false;
};
exports.isRootType = isRootType;
const addTypeField = (typeFields, typeName, fieldName) => {
    const i = typeFields.findIndex(t => t.typeName === typeName);
    if (i !== -1) {
        addField(typeFields[i], fieldName);
        return;
    }
    const typeField = {
        typeName: typeName,
        fieldNames: []
    };
    addField(typeField, fieldName);
    typeFields.push(typeField);
};
const addField = (typeField, field) => {
    const i = typeField.fieldNames.findIndex(f => f === field);
    if (i !== -1) {
        return;
    }
    typeField.fieldNames.push(field);
};
const addFieldArgument = (typeName, fieldName, argName, config) => {
    const arg = {
        name: argName,
        sourceType: wundernode_config_1.ArgumentSource.FIELD_ARGUMENT,
        sourcePath: [],
        renderConfiguration: wundernode_config_1.ArgumentRenderConfiguration.RENDER_ARGUMENT_DEFAULT,
    };
    let field = config.Fields.find(f => f.typeName === typeName && f.typeName === fieldName);
    if (!field) {
        config.Fields.push({
            typeName: typeName,
            fieldName: fieldName,
            argumentsConfiguration: [arg],
            disableDefaultFieldMapping: false,
            path: [],
            requiresFields: [],
        });
        return;
    }
    if (!field.argumentsConfiguration) {
        field.argumentsConfiguration = [arg];
        return;
    }
    const i = field.argumentsConfiguration.findIndex(a => a.name === argName);
    if (i !== -1) {
        field.argumentsConfiguration[i] = arg;
        return;
    }
    field.argumentsConfiguration.push(arg);
};
const addRequiredFields = (typeName, fieldName, config, requiredFieldNames) => {
    requiredFieldNames.forEach(f => {
        addRequiredField(typeName, fieldName, config, f);
    });
};
const addRequiredField = (typeName, fieldName, config, requiredFieldName) => {
    const field = config.Fields.find(f => f.typeName === typeName && f.typeName === fieldName);
    if (!field) {
        config.Fields.push({
            typeName: typeName,
            fieldName: fieldName,
            requiresFields: [requiredFieldName],
            argumentsConfiguration: [],
            path: [],
            disableDefaultFieldMapping: false,
        });
        return;
    }
    if (!field.requiresFields) {
        field.requiresFields = [requiredFieldName];
        return;
    }
    const exists = field.requiresFields.find(f => f === requiredFieldName) !== undefined;
    if (exists) {
        return;
    }
    field.requiresFields.push(requiredFieldName);
};
