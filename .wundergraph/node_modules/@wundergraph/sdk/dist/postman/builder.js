"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPath = exports.PostmanBuilder = void 0;
const wundernode_config_1 = require("@wundergraph/protobuf/dist/wundernode_config");
const postman_collection_1 = require("postman-collection");
// TS types of this modules are so bad, I opt out!
// docs: https://www.postmanlabs.com/postman-collection/
const PostmanBuilder = (operations, options) => {
    const queryGroup = new postman_collection_1.Collection();
    queryGroup.name = "Queries";
    queryGroup.describe("All your query operations");
    const mutationGroup = new postman_collection_1.Collection();
    mutationGroup.name = "Mutations";
    mutationGroup.describe("All your mutation operations");
    operations.forEach((op) => {
        if (op.OperationType !== wundernode_config_1.OperationType.MUTATION) {
            const request = new postman_collection_1.Request({
                url: `{{apiBaseUrl}}/api/main/operations/${op.Name}`,
                method: "GET",
            });
            request.addHeader({
                key: "Content-Type",
                value: "application/json",
            });
            let paths = [];
            buildPath([], false, op.VariablesSchema, paths);
            paths.sort(function (a, b) {
                return a.path.length - b.path.length;
            });
            for (const path of paths) {
                request.addQueryParams([
                    {
                        key: path.path.join("."),
                        disabled: !path.required,
                        value: "",
                        description: `Type ${path.type}, ${path.required ? "Required" : "Optional"}`,
                    },
                ]);
            }
            queryGroup.items.add({
                name: op.Name,
                request: request.toJSON(),
            });
        }
        else if (op.OperationType === wundernode_config_1.OperationType.MUTATION) {
            const request = new postman_collection_1.Request({
                url: `{{apiBaseUrl}}/api/main/operations/${op.Name}`,
                method: "POST",
                body: {
                    mode: "urlencoded",
                    urlencoded: [],
                    description: "Your GraphQL variables in JSON",
                },
            });
            let paths = [];
            buildPath([], false, op.VariablesSchema, paths);
            paths.sort(function (a, b) {
                return a.path.length - b.path.length;
            });
            for (const path of paths) {
                request.body.urlencoded.add({
                    key: path.path.join("."),
                    disabled: !path.required,
                    description: `Type ${path.type}, ${path.required ? "Required" : "Optional"}`,
                    value: "",
                    type: "text",
                });
            }
            mutationGroup.items.add({
                name: op.Name,
                request: request.toJSON(),
            });
        }
    });
    const myCollection = new postman_collection_1.Collection();
    myCollection.describe("Your Wundergraph collection");
    myCollection.name = "Wundergraph";
    // add variables
    myCollection.variables.add({
        key: "apiBaseUrl",
        value: options.baseURL,
        type: "string",
    });
    // add sub collections
    myCollection.items.add(queryGroup.toJSON());
    myCollection.items.add(mutationGroup.toJSON());
    return myCollection;
};
exports.PostmanBuilder = PostmanBuilder;
// TODO: Add "default" values
// path syntax follows https://github.com/tidwall/sjson#path-syntax
function buildPath(path, required, obj, paths) {
    if (typeof obj === "boolean")
        return;
    if (obj.type === "array") {
        if (typeof obj.items === "boolean")
            return;
        if (!obj.items)
            return;
        let items = [];
        if (!Array.isArray(obj.items))
            items.push(obj.items);
        items.forEach((obj, index) => buildPath([...path, index.toString()], false, obj, paths));
        return;
    }
    // those nodes are limited due to recursion
    if (!obj.type)
        return;
    if (obj.properties) {
        Object.keys(obj.properties).forEach((key) => {
            var _a;
            if (obj.properties) {
                buildPath([...path, key], ((_a = obj.required) === null || _a === void 0 ? void 0 : _a.includes(key)) || required, obj.properties[key], paths);
            }
        });
        return;
    }
    paths.push({
        path,
        required: false,
        type: typeof obj.type === "string" ? obj.type : "any",
    });
}
exports.buildPath = buildPath;
