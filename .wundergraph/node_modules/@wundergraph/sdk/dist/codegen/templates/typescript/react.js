"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasInternalInput = exports.hasInput = exports.isNotInternal = exports.TypescriptReactHooks = exports.TypescriptReactNativeProvider = exports.TypescriptReactProvider = void 0;
const index_1 = require("./index");
const handlebars_1 = __importDefault(require("handlebars"));
const wundernode_config_1 = require("@wundergraph/protobuf/dist/wundernode_config");
// @ts-ignore
const react_provider_tsx_handlebars_1 = __importDefault(require("./react.provider.tsx.handlebars"));
// @ts-ignore
const react_native_provider_tsx_handlebars_1 = __importDefault(require("./react.native.provider.tsx.handlebars"));
// @ts-ignore
const react_hooks_tsx_handlebars_1 = __importDefault(require("./react.hooks.tsx.handlebars"));
class TypescriptReactProvider {
    generate(config) {
        const input = (0, index_1.loadFile)(react_provider_tsx_handlebars_1.default);
        const tmpl = handlebars_1.default.compile(input);
        const content = tmpl({
            hasAuthProviders: config.authentication.cookieBased.length !== 0,
        });
        return Promise.resolve([
            {
                path: "provider.tsx",
                content: (0, index_1.formatTypeScript)(content),
                doNotEditHeader: true,
            }
        ]);
    }
}
exports.TypescriptReactProvider = TypescriptReactProvider;
class TypescriptReactNativeProvider {
    generate(config) {
        const input = (0, index_1.loadFile)(react_native_provider_tsx_handlebars_1.default);
        const tmpl = handlebars_1.default.compile(input);
        const content = tmpl({
            hasAuthProviders: config.authentication.cookieBased.length !== 0,
        });
        return Promise.resolve([
            {
                path: "provider.tsx",
                content: (0, index_1.formatTypeScript)(content),
                doNotEditHeader: true,
            }
        ]);
    }
}
exports.TypescriptReactNativeProvider = TypescriptReactNativeProvider;
class TypescriptReactHooks {
    constructor(reactNative) {
        this.reactNative = reactNative || false;
    }
    generate(config) {
        const input = (0, index_1.loadFile)(react_hooks_tsx_handlebars_1.default);
        const tmpl = handlebars_1.default.compile(input);
        const _imports = imports(config.application);
        _imports.push(...queryResponseImports(config.application));
        const _queries = queries(config.application);
        const _liveQueries = liveQueries(config.application);
        const _mutations = mutations(config.application);
        const _subscriptions = subscriptions(config.application);
        const content = tmpl({
            imports: _imports,
            hasImports: _imports.length !== 0,
            queries: _queries,
            hasQueries: _queries.length !== 0,
            liveQueries: _liveQueries,
            hasLiveQueries: _liveQueries.length !== 0,
            mutations: _mutations,
            hasMutations: _mutations.length !== 0,
            subscriptions: _subscriptions,
            hasSubscriptions: _subscriptions.length !== 0,
            hasSubscriptionsOrLiveQueries: _subscriptions.length + _liveQueries.length !== 0,
            hasAuthProviders: config.authentication.cookieBased.length !== 0,
            reactNative: this.reactNative,
        });
        return Promise.resolve([
            {
                path: "hooks.ts",
                content: (0, index_1.formatTypeScript)(content),
                doNotEditHeader: true,
            }
        ]);
    }
}
exports.TypescriptReactHooks = TypescriptReactHooks;
const isNotInternal = (op) => !op.Internal;
exports.isNotInternal = isNotInternal;
const hasInput = (op) => op.VariablesSchema.properties !== undefined && Object.keys(op.VariablesSchema.properties).length !== 0;
exports.hasInput = hasInput;
const hasInternalInput = (op) => op.InjectedVariablesSchema.properties !== undefined && Object.keys(op.InjectedVariablesSchema.properties).length !== 0;
exports.hasInternalInput = hasInternalInput;
const mustOperationTypeQuery = (op) => op.OperationType === wundernode_config_1.OperationType.QUERY;
const mustLiveQuery = (op) => op.LiveQuery !== undefined && op.LiveQuery.enable;
const mustOperationTypeMutation = (op) => op.OperationType === wundernode_config_1.OperationType.MUTATION;
const mustOperationTypeSubscription = (op) => op.OperationType === wundernode_config_1.OperationType.SUBSCRIPTION;
const imports = (application) => application.Operations
    .filter(exports.hasInput)
    .filter(exports.isNotInternal)
    .map(op => op.Name + "Input");
const queryResponseImports = (application) => application.Operations
    .filter(exports.isNotInternal)
    .filter(op => op.OperationType === wundernode_config_1.OperationType.QUERY)
    .map(op => op.Name + "Response");
const operation = (op) => ({
    name: op.Name,
    hasInput: (0, exports.hasInput)(op),
    requiresAuthentication: op.AuthenticationConfig.required,
});
const queries = (application) => application.Operations
    .filter(exports.isNotInternal)
    .filter(mustOperationTypeQuery)
    .map(operation);
const subscriptions = (application) => application.Operations
    .filter(exports.isNotInternal)
    .filter(mustOperationTypeSubscription)
    .map(operation);
const liveQueries = (application) => application.Operations
    .filter(exports.isNotInternal)
    .filter(mustOperationTypeQuery)
    .filter(mustLiveQuery)
    .map(operation);
const mutations = (application) => application.Operations
    .filter(exports.isNotInternal)
    .filter(mustOperationTypeMutation)
    .map(operation);
