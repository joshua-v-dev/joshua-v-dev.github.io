"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadFile = exports.TypeScriptResponseDataModels = exports.TypeScriptResponseModels = exports.TypeScriptInjectedInputModels = exports.TypeScriptInternalInputModels = exports.TypeScriptInputModels = exports.formatTypeScript = void 0;
const index_1 = require("../../index");
const prettier_1 = __importDefault(require("prettier"));
const react_1 = require("./react");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const formatTypeScript = (input) => {
    return prettier_1.default.format(input, {
        parser: "typescript",
        printWidth: 120,
        useTabs: true,
        tabWidth: 2,
    });
};
exports.formatTypeScript = formatTypeScript;
class TypeScriptInputModels {
    async generate(config) {
        const content = config.application.Operations
            .filter(react_1.hasInput)
            .map(op => {
            return JSONSchemaToTypescriptInterface(op.VariablesSchema, op.Name + "Input", false);
        }).join("\n\n");
        return Promise.resolve([
            {
                path: "models.ts",
                content: (0, exports.formatTypeScript)(content),
                doNotEditHeader: true,
            }
        ]);
    }
}
exports.TypeScriptInputModels = TypeScriptInputModels;
class TypeScriptInternalInputModels {
    async generate(config) {
        const content = config.application.Operations
            .filter(react_1.hasInternalInput)
            .map(op => {
            return JSONSchemaToTypescriptInterface(op.InternalVariablesSchema, "Internal" + op.Name + "Input", false);
        }).join("\n\n");
        return Promise.resolve([
            {
                path: "models.ts",
                content: (0, exports.formatTypeScript)(content),
                doNotEditHeader: true,
            }
        ]);
    }
}
exports.TypeScriptInternalInputModels = TypeScriptInternalInputModels;
class TypeScriptInjectedInputModels {
    async generate(config) {
        const content = config.application.Operations
            .filter(react_1.hasInternalInput)
            .map(op => {
            return JSONSchemaToTypescriptInterface(op.InjectedVariablesSchema, "Injected" + op.Name + "Input", false);
        }).join("\n\n");
        return Promise.resolve([
            {
                path: "models.ts",
                content: (0, exports.formatTypeScript)(content),
                doNotEditHeader: true,
            }
        ]);
    }
}
exports.TypeScriptInjectedInputModels = TypeScriptInjectedInputModels;
class TypeScriptResponseModels {
    generate(config) {
        const content = config.application.Operations.map(op => {
            return JSONSchemaToTypescriptInterface(op.ResponseSchema, op.Name + "Response", true);
        }).join("\n\n");
        const withErrorDefinition = graphQLErrorDefinition + "\n\n" + content;
        return Promise.resolve([
            {
                path: "models.ts",
                content: (0, exports.formatTypeScript)(withErrorDefinition),
                doNotEditHeader: true,
            }
        ]);
    }
}
exports.TypeScriptResponseModels = TypeScriptResponseModels;
class TypeScriptResponseDataModels {
    generate(config) {
        const content = config.application.Operations
            .filter(op => op.ResponseSchema.properties !== undefined && op.ResponseSchema.properties["data"] !== undefined)
            .map(op => {
            return JSONSchemaToTypescriptInterface(op.ResponseSchema.properties["data"], op.Name + "ResponseData", false);
        }).join("\n\n");
        const withErrorDefinition = graphQLErrorDefinition + "\n\n" + content;
        return Promise.resolve([
            {
                path: "models.ts",
                content: (0, exports.formatTypeScript)(withErrorDefinition),
                doNotEditHeader: true,
            }
        ]);
    }
}
exports.TypeScriptResponseDataModels = TypeScriptResponseDataModels;
const graphQLErrorDefinition = `
export interface GraphQLError {
    message: string;
    path?: ReadonlyArray<string | number>;
}`;
const JSONSchemaToTypescriptInterface = (schema, interfaceName, withErrors) => {
    let out = "";
    const writeType = (name, isRequired, typeName) => {
        out += `${name + (isRequired ? "" : "?")}: ${typeName}\n`;
    };
    (0, index_1.visitJSONSchema)(schema, {
        root: {
            enter: () => {
                out += `export interface ${interfaceName} {\n`;
            },
            leave: () => {
                if (withErrors) {
                    out += `errors?: ReadonlyArray<GraphQLError>;\n`;
                }
                out += "}";
            }
        },
        number: (name, isRequired, isArray) => {
            if (isArray) {
                out += "number";
            }
            else {
                writeType(name, isRequired, "number");
            }
        },
        array: {
            enter: (name, isRequired, isArray) => {
                out += `${name + (isRequired ? "" : "?")}: `;
            },
            leave: (name, isRequired, isArray) => {
                out += "[],";
            },
        },
        string: (name, isRequired, isArray, enumValues) => {
            if (enumValues !== undefined) {
                const values = enumValues.map(v => `"${v}"`).join(" | ");
                if (isArray) {
                    out += values;
                }
                else {
                    writeType(name, isRequired, values);
                }
                return;
            }
            if (isArray) {
                out += "string";
            }
            else {
                writeType(name, isRequired, "string");
            }
        },
        object: {
            enter: (name, isRequired, isArray) => {
                if (isArray) {
                    out += "{\n";
                }
                else {
                    writeType(name, isRequired, "{");
                }
            },
            leave: (name, isRequired, isArray) => {
                out += "}";
                if (!isArray) {
                    out += ",\n";
                }
            }
        },
        boolean: (name, isRequired, isArray) => {
            if (isArray) {
                out += "boolean";
            }
            else {
                writeType(name, isRequired, "boolean");
            }
        }
    });
    return out;
};
const loadFile = (file) => {
    if (typeof file === "function") {
        return file();
    }
    if (typeof file !== "string") {
        return "";
    }
    try {
        if (path_1.default.basename(file) === file) { // doesn't contain path separators, not a file path
            return file;
        }
        return fs_1.default.readFileSync(path_1.default.resolve(__dirname, file)).toString();
    }
    catch (e) {
        return file;
    }
};
exports.loadFile = loadFile;
