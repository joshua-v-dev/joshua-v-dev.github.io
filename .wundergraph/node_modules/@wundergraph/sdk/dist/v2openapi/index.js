"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.openApiSpecificationToRESTApiObject = void 0;
const definition_1 = require("../definition");
const swagger2openapi_1 = __importDefault(require("swagger2openapi"));
const graphql_1 = require("graphql");
const wundernode_config_1 = require("@wundergraph/protobuf/dist/wundernode_config");
const js_yaml_1 = __importDefault(require("js-yaml"));
const namespacing_1 = require("../definition/namespacing");
const configure_1 = require("../configure");
const openApiSpecificationToRESTApiObject = async (oas, introspection) => {
    try {
        const specObject = JSON.parse(oas, fixOasReplacer);
        const spec = await convertOpenApiV3(specObject);
        const builder = new RESTApiBuilder(spec, introspection);
        return builder.build();
    }
    catch (e) {
        const obj = js_yaml_1.default.load(oas);
        if (obj) {
            const spec = await convertOpenApiV3(obj);
            const builder = new RESTApiBuilder(spec, introspection);
            return builder.build();
        }
        throw new Error("cannot read OAS");
    }
};
exports.openApiSpecificationToRESTApiObject = openApiSpecificationToRESTApiObject;
class RESTApiBuilder {
    constructor(spec, introspection) {
        this.headers = {};
        this.dataSources = [];
        this.fields = [];
        this.build = () => {
            Object.keys(this.spec.paths).forEach(path => {
                const pathObject = this.spec.paths[path];
                if (pathObject === undefined) {
                    return;
                }
                if (pathObject.get) {
                    this.traversePath(pathObject.get, pathObject, path, wundernode_config_1.HTTPMethod.GET);
                }
                if (pathObject.post) {
                    this.traversePath(pathObject.post, pathObject, path, wundernode_config_1.HTTPMethod.POST);
                }
                if (pathObject.put) {
                    this.traversePath(pathObject.put, pathObject, path, wundernode_config_1.HTTPMethod.PUT);
                }
                if (pathObject.delete) {
                    this.traversePath(pathObject.delete, pathObject, path, wundernode_config_1.HTTPMethod.DELETE);
                }
            });
            const filtered = this.filterEmptyTypes(this.graphQLSchema);
            //const filtered = this.graphQLSchema;
            //const debug = print(filtered);
            const schema = (0, graphql_1.buildASTSchema)(filtered);
            const schemaString = (0, graphql_1.printSchema)(schema);
            const dataSources = this.dataSources.map(ds => {
                return {
                    ...ds,
                    RootNodes: (0, namespacing_1.applyNameSpaceToTypeFields)(ds.RootNodes, schema, this.apiNamespace),
                    ChildNodes: (0, namespacing_1.applyNameSpaceToTypeFields)(ds.ChildNodes, schema, this.apiNamespace),
                };
            });
            return new definition_1.RESTApi((0, namespacing_1.applyNameSpaceToGraphQLSchema)(schemaString, this.apiNamespace), dataSources, (0, namespacing_1.applyNamespaceToExistingRootFieldConfigurations)(this.fields, schema, this.apiNamespace), []);
        };
        this.traversePath = (operationObject, pathItemObject, path, verb) => {
            const fieldName = this.prettyFieldName(this.resolveFieldName(operationObject, path, verb));
            if (!operationObject.responses) {
                console.log("handle empty response");
                return;
            }
            const parentType = verb === wundernode_config_1.HTTPMethod.GET ? "Query" : "Mutation";
            this.dataSources.push({
                RootNodes: [
                    {
                        typeName: parentType,
                        fieldNames: [fieldName]
                    }
                ],
                Kind: wundernode_config_1.DataSourceKind.REST,
                Custom: {
                    Fetch: {
                        method: verb,
                        url: (0, configure_1.mapInputVariable)(this.buildURL(path)),
                        body: (0, configure_1.mapInputVariable)(""),
                        header: this.headers,
                        query: [],
                        upstreamAuthentication: (0, definition_1.buildUpstreamAuthentication)(this.httpUpstream),
                    },
                    Subscription: {
                        Enabled: false,
                    },
                    DefaultTypeName: this.statusCodeUnions ? "UnspecifiedHttpResponse" : "",
                    StatusCodeTypeMappings: [],
                },
                ChildNodes: [],
                Directives: [],
            });
            this.fields.push({
                typeName: parentType,
                fieldName: fieldName,
                disableDefaultFieldMapping: true,
                argumentsConfiguration: [],
                requiresFields: [],
                path: [],
            });
            if (Object.keys(operationObject.responses).length === 0) {
                this.ensureType("scalar", "JSON");
                this.addField(parentType, "type", fieldName, "JSON", []);
            }
            Object.keys(operationObject.responses).forEach(statusCode => {
                if (!this.statusCodeUnions && statusCode !== "200") {
                    return;
                }
                const responseObject = this.resolveResponseObject(operationObject.responses[statusCode]);
                if (!responseObject) {
                    return;
                }
                if (!responseObject.content || !responseObject.content["application/json"]) {
                    if (this.statusCodeUnions) {
                        const fieldTypeName = this.buildFieldTypeName(fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1), responseObject.description || "", statusCode || "");
                        this.ensureStatusCodeObject(fieldTypeName);
                        this.addResponseUnionField(parentType, "type", fieldName, fieldTypeName, statusCode, true);
                    }
                    else {
                        this.ensureType("scalar", "JSON");
                        this.addField(parentType, "type", fieldName, "JSON", []);
                    }
                    return;
                }
                const mediaTypeObject = responseObject.content["application/json"];
                const schema = mediaTypeObject.schema;
                this.traverseSchema({
                    isRootField: true,
                    parentTypeName: parentType,
                    fieldName: fieldName,
                    schema: schema,
                    path: path,
                    verb: verb,
                    objectKind: "type",
                    enclosingTypes: [],
                    statusCode: statusCode,
                    responseObjectDescription: responseObject.description,
                });
            });
            const parameters = [...pathItemObject.parameters || [], ...operationObject.parameters || []];
            parameters.map(this.resolveParamsObject).forEach(param => {
                if (!param) {
                    return;
                }
                const schema = param.schema;
                this.traverseSchema({
                    parentTypeName: parentType,
                    fieldName: fieldName,
                    argumentName: param.name,
                    schema,
                    isRootField: true,
                    verb,
                    path,
                    objectKind: "input",
                    enclosingTypes: param.required ? ["non_null"] : [],
                });
                switch (param.in) {
                    case "query":
                        this.dataSources[this.dataSources.length - 1].Custom.Fetch.query = [
                            ...this.dataSources[this.dataSources.length - 1].Custom.Fetch.query || [],
                            {
                                name: param.name,
                                value: `{{ .arguments.${param.name} }}`
                            }
                        ];
                        break;
                    case "header":
                        this.dataSources[this.dataSources.length - 1].Custom.Fetch.header = {
                            ...this.dataSources[this.dataSources.length - 1].Custom.Fetch.header,
                            [param.name]: {
                                values: [{
                                        kind: wundernode_config_1.ConfigurationVariableKind.STATIC_CONFIGURATION_VARIABLE,
                                        staticVariableContent: `{{ .arguments.${param.name} }`,
                                        environmentVariableName: "",
                                        environmentVariableDefaultValue: "",
                                        placeholderVariableName: "",
                                    }]
                            },
                        };
                        break;
                    case "path":
                        this.dataSources[this.dataSources.length - 1].Custom.Fetch.url.staticVariableContent =
                            this.dataSources[this.dataSources.length - 1].Custom.Fetch.url.staticVariableContent.replace(`{${param.name}}`, `{{ .arguments.${param.name} }}`);
                        if (param.schema.type === "array") {
                            const rootNode = this.dataSources[this.dataSources.length - 1].RootNodes[0];
                            const fieldConfiguration = this.fields.find(field => field.typeName === rootNode.typeName && field.fieldName === rootNode.fieldNames[0]);
                            if (!fieldConfiguration) {
                                break;
                            }
                            fieldConfiguration.argumentsConfiguration.push({
                                name: param.name,
                                renderConfiguration: wundernode_config_1.ArgumentRenderConfiguration.RENDER_ARGUMENT_AS_ARRAY_CSV,
                                sourceType: wundernode_config_1.ArgumentSource.FIELD_ARGUMENT,
                                sourcePath: [param.name]
                            });
                        }
                        break;
                    case "cookie":
                        console.log("param.in not implemented for cookie");
                        break;
                }
            });
            if (operationObject.requestBody) {
                const body = this.resolveRequestBody(operationObject.requestBody);
                if (!body) {
                    return;
                }
                if (!body.content["application/json"]) {
                    return;
                }
                const applicationJSON = body.content["application/json"];
                const schema = applicationJSON.schema;
                const argumentName = this.resolveArgumentName(schema, path, verb);
                this.traverseSchema({
                    argumentName: argumentName,
                    fieldName: fieldName,
                    enclosingTypes: body.required ? ["non_null"] : [],
                    parentTypeName: parentType,
                    isRootField: true,
                    objectKind: "input",
                    path,
                    verb,
                    schema,
                });
                this.dataSources[this.dataSources.length - 1].Custom.Fetch.body = {
                    kind: wundernode_config_1.ConfigurationVariableKind.STATIC_CONFIGURATION_VARIABLE,
                    staticVariableContent: `{{ .arguments.${argumentName} }}`,
                    environmentVariableName: "",
                    environmentVariableDefaultValue: "",
                    placeholderVariableName: "",
                };
            }
        };
        this.traverseSchema = (options) => {
            var _a;
            let { argumentName, schema, objectKind, enclosingTypes, parentTypeName, fieldName, path, verb, isRootField, statusCode, responseObjectDescription, } = options;
            schema = this.resolveSingleSchemaOneOf(schema);
            const ref = this.resolveSchemaRef(schema);
            if (ref) {
                const componentSchema = this.spec.components && this.spec.components.schemas && this.spec.components.schemas[ref];
                if (!componentSchema) {
                    return;
                }
                let fieldTypeName = ref;
                if (argumentName) {
                    this.addArgument(parentTypeName, fieldName, argumentName, ref, enclosingTypes);
                }
                else if (this.statusCodeUnions && isRootField && objectKind === "type") {
                    fieldTypeName = this.buildFieldTypeName(ref, responseObjectDescription || "", statusCode || "");
                    this.addResponseUnionField(parentTypeName, objectKind, fieldName, fieldTypeName, statusCode || "", false);
                }
                else {
                    this.addField(parentTypeName, objectKind, fieldName, ref, enclosingTypes);
                }
                const created = this.ensureType(componentSchema.enum ? "enum" : objectKind, fieldTypeName);
                if (!created) {
                    return;
                }
                this.traverseSchema({
                    isRootField: false,
                    objectKind,
                    schema: componentSchema,
                    enclosingTypes: [],
                    parentTypeName: fieldTypeName,
                    fieldName: "",
                    verb,
                    path,
                });
                return;
            }
            if (schema.allOf) {
                schema = schema.allOf.map(this.resolveSchema).reduce(this.mergeJSONSchemas);
            }
            if (schema.type === undefined) {
                this.ensureType("scalar", "JSON");
                if (argumentName) {
                    this.addArgument(parentTypeName, fieldName, argumentName, "JSON", enclosingTypes);
                    return;
                }
                this.addField(parentTypeName, objectKind, fieldName, "JSON", enclosingTypes);
                return;
            }
            switch (schema.type) {
                case "integer":
                    if (argumentName) {
                        this.addArgument(parentTypeName, fieldName, argumentName, "Int", enclosingTypes);
                        return;
                    }
                    this.addField(parentTypeName, objectKind, fieldName, "Int", enclosingTypes);
                    return;
                case "null":
                    return;
                case "string":
                    if (schema.enum) {
                        if (argumentName && schema.enum.constructor === Array && schema.enum.length !== 0 && typeof schema.enum[0] === "number") {
                            this.addArgument(parentTypeName, fieldName, argumentName, "Int", enclosingTypes);
                            return;
                        }
                        if (argumentName) {
                            this.ensureType("enum", fieldName);
                            this.addArgument(parentTypeName, fieldName, argumentName, argumentName, enclosingTypes);
                            this.addEnumValues(argumentName, schema.enum);
                            return;
                        }
                        this.addEnumValues(parentTypeName, schema.enum);
                        return;
                    }
                    if (argumentName) {
                        this.addArgument(parentTypeName, fieldName, argumentName, "String", enclosingTypes);
                        return;
                    }
                    this.addField(parentTypeName, objectKind, fieldName, "String", enclosingTypes);
                    return;
                case "boolean":
                    if (argumentName) {
                        this.addArgument(parentTypeName, fieldName, argumentName, "Boolean", enclosingTypes);
                        return;
                    }
                    this.addField(parentTypeName, objectKind, fieldName, "Boolean", enclosingTypes);
                    return;
                case "number":
                    if (argumentName) {
                        this.addArgument(parentTypeName, fieldName, argumentName, "Int", enclosingTypes);
                        return;
                    }
                    this.addField(parentTypeName, objectKind, fieldName, "Int", enclosingTypes);
                    return;
                case "array":
                    this.traverseSchema({
                        ...options,
                        schema: schema.items,
                        enclosingTypes: [
                            ...enclosingTypes,
                            "list",
                        ]
                    });
                    return;
                case "object":
                    if (!schema.properties) {
                        return;
                    }
                    if (argumentName) {
                        if ((_a = schema.required) === null || _a === void 0 ? void 0 : _a.length) {
                            if (enclosingTypes.length !== 0 && enclosingTypes[enclosingTypes.length - 1] !== "non_null") {
                                enclosingTypes.push("non_null");
                            }
                        }
                        this.addArgument(parentTypeName, fieldName, argumentName, argumentName, enclosingTypes);
                        this.ensureType("input", argumentName);
                        Object.keys(schema.properties).forEach(prop => {
                            var _a;
                            this.traverseSchema({
                                isRootField: false,
                                enclosingTypes: ((_a = schema.required) === null || _a === void 0 ? void 0 : _a.find(req => req === prop)) !== undefined ? ["non_null"] : [],
                                fieldName: prop,
                                objectKind: "input",
                                parentTypeName: argumentName,
                                path,
                                verb,
                                schema: schema.properties[prop],
                            });
                        });
                        return;
                    }
                    if (fieldName !== "") {
                        let typeName = schema.title ? schema.title.replace(" ", "") : fieldName[0].toUpperCase() + fieldName.substring(1);
                        if (objectKind === "input") {
                            typeName += "Input";
                        }
                        let fieldTypeName = typeName;
                        if (this.statusCodeUnions && isRootField && objectKind === "type") {
                            fieldTypeName = this.buildFieldTypeName(typeName, responseObjectDescription || "", statusCode || "");
                            this.addResponseUnionField(parentTypeName, objectKind, fieldName, fieldTypeName, statusCode || "", false);
                        }
                        else {
                            this.addField(parentTypeName, objectKind, fieldName, typeName, enclosingTypes);
                        }
                        const created = this.ensureType(objectKind, fieldTypeName);
                        if (!created) {
                            return;
                        }
                        Object.keys(schema.properties).forEach(prop => {
                            var _a;
                            this.traverseSchema({
                                isRootField: false,
                                enclosingTypes: ((_a = schema.required) === null || _a === void 0 ? void 0 : _a.find(req => req === prop)) !== undefined ? ["non_null"] : [],
                                fieldName: prop,
                                objectKind: objectKind,
                                parentTypeName: fieldTypeName,
                                path,
                                verb,
                                schema: schema.properties[prop]
                            });
                        });
                        return;
                    }
                    Object.keys(schema.properties).forEach(prop => {
                        var _a;
                        this.traverseSchema({
                            isRootField: false,
                            enclosingTypes: ((_a = schema.required) === null || _a === void 0 ? void 0 : _a.find(req => req === prop)) !== undefined ? ["non_null"] : [],
                            fieldName: prop,
                            objectKind: objectKind,
                            parentTypeName: parentTypeName,
                            path,
                            verb,
                            schema: schema.properties[prop]
                        });
                    });
            }
        };
        this.buildFieldTypeName = (fieldTypeName, description, statusCode) => {
            if (description !== "") {
                const parts = description.split(" ").map(part => part.substring(0, 1).toUpperCase() + part.substring(1));
                const combined = fieldTypeName + parts.join("");
                if (/^[a-zA-Z0-9]+$/.test(combined)) {
                    return combined;
                }
            }
            return fieldTypeName + statusCode;
        };
        this.ensureStatusCodeObject = (name) => {
            const object = {
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: name,
                },
                kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
                fields: [
                    {
                        kind: graphql_1.Kind.FIELD_DEFINITION,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: "statusCode",
                        },
                        type: {
                            kind: graphql_1.Kind.NON_NULL_TYPE,
                            type: {
                                kind: graphql_1.Kind.NAMED_TYPE,
                                name: {
                                    kind: graphql_1.Kind.NAME,
                                    value: "Int"
                                }
                            }
                        }
                    }
                ]
            };
            this.graphQLSchema = {
                ...this.graphQLSchema,
                definitions: [
                    ...this.graphQLSchema.definitions,
                    object,
                ]
            };
        };
        this.ensureType = (objectKind, ref) => {
            const exists = this.graphQLSchema.definitions.find(value => {
                switch (objectKind) {
                    case "type":
                        return value.kind === "ObjectTypeDefinition" && value.name.value === ref;
                    case "input":
                        return value.kind === "InputObjectTypeDefinition" && value.name.value === ref;
                    case "enum":
                        return value.kind === "EnumTypeDefinition" && value.name.value === ref;
                    case "scalar":
                        return value.kind === "ScalarTypeDefinition" && value.name.value === ref;
                    default:
                        throw new Error("must implement objectKind");
                }
            }) !== undefined;
            if (exists) {
                return false;
            }
            let node;
            switch (objectKind) {
                case "type":
                    node = this.buildObjectTypeDefinitionNode(ref, []);
                    break;
                case "input":
                    node = this.buildInputObjectTypeDefinitionNode(ref, []);
                    break;
                case "enum":
                    node = this.buildEnumTypeDefinitionNode(ref, []);
                    break;
                case "scalar":
                    node = this.buildScalarTypeDefinitionNode(ref);
                    break;
            }
            if (!node) {
                return false;
            }
            this.graphQLSchema = {
                ...this.graphQLSchema,
                definitions: [
                    ...this.graphQLSchema.definitions,
                    node,
                ]
            };
            return true;
        };
        this.baseURL = () => {
            if (!this.spec.servers || this.spec.servers.length === 0) {
                throw new Error("OpenAPISpecification must contain server + url");
            }
            const secure = this.spec.servers.find(server => server.url.startsWith("https"));
            if (secure) {
                return secure.url;
            }
            return this.spec.servers[0].url;
        };
        this.buildURL = (path) => {
            const base = this.baseURL();
            return base + path;
        };
        this.buildScalarTypeDefinitionNode = (name) => {
            return {
                kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: name,
                },
            };
        };
        this.addArgument = (typeName, fieldName, argumentName, argumentType, enclosingTypes) => {
            const resolvedArgType = this.resolveTypeNode(argumentType, enclosingTypes);
            let done = false;
            this.graphQLSchema = (0, graphql_1.visit)(this.graphQLSchema, {
                ObjectTypeDefinition: node => {
                    if (node.name.value !== typeName) {
                        return false;
                    }
                },
                FieldDefinition: {
                    enter: node => {
                        if (node.name.value !== fieldName) {
                            return;
                        }
                        const update = {
                            ...node,
                            arguments: [
                                ...node.arguments || [],
                                {
                                    kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
                                    name: {
                                        kind: graphql_1.Kind.NAME,
                                        value: argumentName,
                                    },
                                    type: resolvedArgType,
                                }
                            ],
                        };
                        done = true;
                        return update;
                    },
                },
            });
        };
        this.addResponseUnionField = (parentName, objectKind, fieldName, fieldTypeName, statusCode, statusCodeOnly) => {
            const fieldType = {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: fieldTypeName,
                }
            };
            if (objectKind !== "type") {
                return;
            }
            const unionTypeName = fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1) + "Response";
            const unionExists = this.graphQLSchema.definitions.find(node => node.kind === "UnionTypeDefinition" && node.name.value === unionTypeName) !== undefined;
            const defaultResponseDefinitionExists = this.graphQLSchema.definitions.find(node => node.kind === "ObjectTypeDefinition" && node.name.value === "UnspecifiedHttpResponse") !== undefined;
            this.dataSources[this.dataSources.length - 1].Custom.StatusCodeTypeMappings.push({
                typeName: this.apiNamespace ? this.apiNamespace + "_" + fieldTypeName : fieldTypeName,
                statusCode: parseInt(statusCode, 10),
                injectStatusCodeIntoBody: statusCodeOnly,
            });
            if (unionExists) {
                this.graphQLSchema = (0, graphql_1.visit)(this.graphQLSchema, {
                    UnionTypeDefinition: node => {
                        var _a;
                        if (node.name.value === unionTypeName) {
                            if (((_a = node.types) === null || _a === void 0 ? void 0 : _a.find(t => t.name.value === fieldTypeName)) !== undefined) {
                                return;
                            }
                            const updated = {
                                ...node,
                                types: [
                                    ...node.types || [],
                                    fieldType,
                                ]
                            };
                            return updated;
                        }
                    }
                });
                return;
            }
            const extension = `
        union ${unionTypeName} = UnspecifiedHttpResponse | ${fieldTypeName}
        `;
            const defaultResponseDefinition = `
        type UnspecifiedHttpResponse {
            statusCode: Int!
        }
        `;
            const allExtension = defaultResponseDefinitionExists ? extension : extension + defaultResponseDefinition;
            const existingSchema = (0, graphql_1.print)(this.graphQLSchema);
            this.graphQLSchema = (0, graphql_1.parse)(existingSchema + allExtension);
            this.graphQLSchema = (0, graphql_1.visit)(this.graphQLSchema, {
                ObjectTypeDefinition: node => {
                    if (node.name.value !== parentName) {
                        return;
                    }
                    const updated = {
                        ...node,
                        fields: [
                            ...node.fields || [],
                            {
                                kind: graphql_1.Kind.FIELD_DEFINITION,
                                name: {
                                    kind: graphql_1.Kind.NAME,
                                    value: fieldName,
                                },
                                type: {
                                    kind: "NamedType",
                                    name: {
                                        kind: "Name",
                                        value: unionTypeName,
                                    }
                                },
                            }
                        ]
                    };
                    return updated;
                }
            });
        };
        this.addField = (parentName, objectKind, fieldName, fieldTypeName, enclosingTypes) => {
            const fieldType = this.resolveTypeNode(fieldTypeName, enclosingTypes);
            if (objectKind === "type") {
                this.graphQLSchema = (0, graphql_1.visit)(this.graphQLSchema, {
                    ObjectTypeDefinition: node => {
                        if (node.name.value !== parentName) {
                            return;
                        }
                        const updated = {
                            ...node,
                            fields: [
                                ...node.fields || [],
                                {
                                    kind: graphql_1.Kind.FIELD_DEFINITION,
                                    name: {
                                        kind: graphql_1.Kind.NAME,
                                        value: fieldName,
                                    },
                                    type: fieldType,
                                }
                            ]
                        };
                        return updated;
                    }
                });
            }
            else if (objectKind === "input") {
                this.graphQLSchema = (0, graphql_1.visit)(this.graphQLSchema, {
                    InputObjectTypeDefinition: node => {
                        if (node.name.value !== parentName) {
                            return;
                        }
                        const updated = {
                            ...node,
                            fields: [
                                ...node.fields || [],
                                {
                                    kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
                                    name: {
                                        kind: graphql_1.Kind.NAME,
                                        value: fieldName,
                                    },
                                    type: fieldType,
                                }
                            ]
                        };
                        return updated;
                    }
                });
            }
        };
        this.addEnumValues = (enumTypeName, values) => {
            const nodes = [];
            values.forEach(value => {
                if (typeof value !== "string") {
                    return;
                }
                const exists = nodes.find(node => node.name.value === value) !== undefined;
                if (exists) {
                    return;
                }
                nodes.push({
                    kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: value,
                    },
                });
            });
            if (nodes.length === 0) {
                return;
            }
            this.graphQLSchema = (0, graphql_1.visit)(this.graphQLSchema, {
                EnumTypeDefinition: node => {
                    if (node.name.value !== enumTypeName) {
                        return;
                    }
                    const update = {
                        ...node,
                        values: [
                            ...node.values || [],
                            ...nodes,
                        ]
                    };
                    return update;
                }
            });
        };
        this.resolveTypeNode = (namedTypeName, enclosingTypes, suffix) => {
            if (enclosingTypes.length !== 0) {
                const first = enclosingTypes.shift();
                switch (first) {
                    case "list":
                        return {
                            kind: graphql_1.Kind.LIST_TYPE,
                            type: this.resolveTypeNode(namedTypeName, enclosingTypes)
                        };
                    case "non_null":
                        return {
                            kind: graphql_1.Kind.NON_NULL_TYPE,
                            type: this.resolveTypeNode(namedTypeName, enclosingTypes)
                        };
                }
            }
            return {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: suffix ? namedTypeName + suffix : namedTypeName,
                }
            };
        };
        this.resolveSingleSchemaOneOf = (schema) => {
            if (schema.oneOf && schema.oneOf.length === 1) {
                return schema.oneOf[0];
            }
            return schema;
        };
        this.resolveParamsObject = (object) => {
            if (object.$ref) {
                const ref = object.$ref;
                if (this.spec.components && this.spec.components.parameters)
                    return this.spec.components.parameters[ref];
                return undefined;
            }
            return object;
        };
        this.resolveRequestBody = (request) => {
            if (request.$ref) {
                const ref = request.$ref;
                if (this.spec.components && this.spec.components.requestBodies) {
                    return this.spec.components.requestBodies[ref];
                }
            }
            return request;
        };
        this.resolveResponseObject = (responseObject) => {
            const ref = responseObject.$ref || undefined;
            if (ref) {
                const schemaName = this.componentName(ref, "responses");
                if (!schemaName) {
                    return;
                }
                const resolvedSchema = this.spec.components && this.spec.components.responses && this.spec.components.responses[schemaName];
                if (!resolvedSchema) {
                    return;
                }
                if (resolvedSchema.$ref) {
                    return;
                }
                return resolvedSchema;
            }
            return responseObject;
        };
        this.filterEmptyTypes = (document) => {
            return (0, graphql_1.visit)(document, {
                ObjectTypeDefinition: node => {
                    if (!node.fields || node.fields.length === 0) {
                        return null;
                    }
                },
                InterfaceTypeDefinition: node => {
                    if (!node.fields || node.fields.length === 0) {
                        return null;
                    }
                },
                EnumTypeDefinition: node => {
                    if (!node.values || node.values.length === 0) {
                        return null;
                    }
                },
                UnionTypeDefinition: node => {
                    if (!node.types || node.types.length === 0) {
                        return null;
                    }
                }
            });
        };
        this.resolveSchema = (value) => {
            if (value.$ref) {
                const refPath = value.$ref.substring(2).split("/");
                if (refPath.length !== 3 || refPath[0] !== "components" || refPath[1] !== "schemas") {
                    return {};
                }
                const typeName = refPath[2];
                if (!this.spec.components || !this.spec.components.schemas) {
                    return {};
                }
                const schema = this.spec.components.schemas[typeName];
                return this.resolveSchema(schema);
            }
            if (value.oneOf && value.oneOf.length === 1) {
                return this.resolveSchema(value.oneOf[0]);
            }
            if (value.allOf) {
                return value.allOf.map(this.resolveSchema).reduce(this.mergeJSONSchemas);
            }
            return value;
        };
        this.componentName = (ref, componentType) => {
            if (ref.startsWith("#/")) {
                const refPath = ref.substring(2).split("/");
                if (refPath.length !== 3 || refPath[0] !== "components" || refPath[1] !== componentType) {
                    return;
                }
                return refPath[2];
            }
        };
        this.resolveSchemaRef = (schema) => {
            if (schema.$ref && schema.$ref.startsWith("#/")) {
                const refPath = schema.$ref.substring(2).split("/");
                if (refPath.length !== 3 || refPath[0] !== "components" || refPath[1] !== "schemas") {
                    return;
                }
                return refPath[2];
            }
        };
        this.mergeJSONSchemas = (previous, next) => {
            if (previous.type !== next.type) {
                return previous;
            }
            return {
                ...previous,
                properties: {
                    ...previous.properties,
                    ...next.properties,
                },
                required: [
                    ...(previous.required || []),
                    ...(next.required || [])
                ],
                additionalProperties: previous.additionalProperties || next.additionalProperties,
            };
        };
        this.buildObjectTypeDefinitionNode = (name, fields) => {
            return {
                kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
                fields: fields,
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: name,
                }
            };
        };
        this.buildInputObjectTypeDefinitionNode = (name, fields) => {
            return {
                kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
                fields: fields,
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: name,
                }
            };
        };
        this.buildEnumTypeDefinitionNode = (name, values) => {
            return {
                kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
                values,
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: name,
                }
            };
        };
        this.prettyFieldName = (input) => {
            const underscore = input.split("_").reduce((prev, next) => prev + next[0].toUpperCase() + next.substring(1));
            return underscore.split("-").reduce((prev, next) => prev + next[0].toUpperCase() + next.substring(1));
        };
        this.resolveFieldName = (operationObject, path, verb) => {
            if (operationObject.operationId) {
                if (operationObject.operationId.startsWith("/")) {
                    return operationObject.operationId.substring(1);
                }
                return operationObject.operationId;
            }
            const formattedPath = path.split("/").filter(element => element !== "")
                .reduce((prev, current) => {
                if (current.startsWith("{") && current.endsWith("}")) {
                    const trimmed = current.substring(1, current.length - 1);
                    return prev + "By" + trimmed[0].toUpperCase() + trimmed.substring(1);
                }
                return prev + current[0].toUpperCase() + current.substring(1);
            });
            return (0, wundernode_config_1.hTTPMethodToJSON)(verb).toLowerCase() + formattedPath[0].toUpperCase() + formattedPath.substring(1);
        };
        this.spec = spec;
        this.graphQLSchema = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: [
                this.buildObjectTypeDefinitionNode("Query", []),
                this.buildObjectTypeDefinitionNode("Mutation", []),
                this.buildObjectTypeDefinitionNode("Subscription", []),
            ]
        };
        this.statusCodeUnions = introspection.statusCodeUnions || false;
        this.httpUpstream = introspection;
        this.apiNamespace = introspection.apiNamespace;
        introspection.headers !== undefined && introspection.headers(new definition_1.HeadersBuilder()).build().forEach(config => {
            const values = [];
            switch (config.valueSource) {
                case "clientRequest":
                    values.push({
                        kind: wundernode_config_1.ConfigurationVariableKind.STATIC_CONFIGURATION_VARIABLE,
                        staticVariableContent: `{{ .request.headers.${config.value} }}`,
                        environmentVariableName: "",
                        environmentVariableDefaultValue: "",
                        placeholderVariableName: "",
                    });
                    break;
                case "static":
                    values.push({
                        kind: wundernode_config_1.ConfigurationVariableKind.STATIC_CONFIGURATION_VARIABLE,
                        staticVariableContent: config.value,
                        environmentVariableDefaultValue: "",
                        environmentVariableName: "",
                        placeholderVariableName: "",
                    });
                    break;
                case "env":
                    values.push({
                        kind: wundernode_config_1.ConfigurationVariableKind.ENV_CONFIGURATION_VARIABLE,
                        staticVariableContent: "",
                        environmentVariableDefaultValue: "",
                        environmentVariableName: config.value,
                        placeholderVariableName: "",
                    });
                    break;
            }
            this.headers[config.key] = {
                values,
            };
        });
    }
    resolveArgumentName(schema, path, verb) {
        if (schema.title) {
            return schema.title.replace(" ", "") + "Input";
        }
        const formattedPath = path.split("/").reduce((prev, current) => prev + current[0].toUpperCase() + current.substring(1));
        return (0, wundernode_config_1.hTTPMethodToJSON)(verb).toLowerCase() + formattedPath[0] + formattedPath.substring(1) + "Input";
    }
}
const convertOpenApiV3 = async (openApiSpec) => {
    const converted = await swagger2openapi_1.default.convertObj(openApiSpec, {});
    return converted.openapi;
};
const fixOasReplacer = (key, value) => {
    switch (key) {
        case "$type":
            // remove the field
            return undefined;
        case "oneOf":
        case "allOf":
        case "anyOf":
        case "enum":
            if (value.constructor === Array) {
                return value;
            }
            if (value["$values"] !== undefined) {
                return value["$values"];
            }
            return value;
        default:
            return value;
    }
};
